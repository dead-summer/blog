<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.24" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.159" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" href="favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png"><title>分布式缓存 | Summer Reverie</title><meta name="description" content="以文字为舟，停泊在夏日岛屿。"><link rel="preload" href="/blog/assets/style-Bgyj1d4F.css" as="style"><link rel="stylesheet" href="/blog/assets/style-Bgyj1d4F.css"><link rel="modulepreload" href="/blog/assets/app-CAzY0Upz.js"><link rel="modulepreload" href="/blog/assets/index.html-BEQRzrdI.js"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-203c4ba0><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-99d41955></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-99d41955> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-203c4ba0 data-v-87c1601e><div class="vp-navbar" vp-navbar data-v-87c1601e data-v-8aa02444><div class="wrapper" data-v-8aa02444><div class="container" data-v-8aa02444><div class="title" data-v-8aa02444><div class="vp-navbar-title has-sidebar" data-v-8aa02444 data-v-ab2a1d26><a class="vp-link link no-icon title" href="/blog/" data-v-ab2a1d26><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="/blog/logo.svg" alt data-v-66df59b9><!--]--><!--[--><img class="vp-image light logo" style="" src="/blog/logo.svg" alt data-v-66df59b9><!--]--><!--]--><!--]--><span data-v-ab2a1d26>Summer Reverie</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-8aa02444><div class="content-body" data-v-8aa02444><!--[--><!--]--><div class="vp-navbar-search search" data-v-8aa02444><div class="search-wrapper" data-v-c5bd895d><!----><div id="local-search" data-v-c5bd895d><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-c5bd895d><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><!--[--><!--]--><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-8aa02444 data-v-ad7ba5ad><span id="main-nav-aria-label" class="visually-hidden" data-v-ad7ba5ad>Main Navigation</span><!--[--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/" tabindex="0" data-v-ad7ba5ad data-v-fe68a192><!--[--><!----><span data-v-fe68a192>首页</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/blog/" tabindex="0" data-v-ad7ba5ad data-v-fe68a192><!--[--><!----><span data-v-fe68a192>博客</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/blog/categories/" tabindex="0" data-v-ad7ba5ad data-v-fe68a192><!--[--><!----><span data-v-fe68a192>分类</span><!----><!--]--><!----></a><!--]--><!--[--><a class="vp-link link navbar-menu-link" href="/blog/notes/" tabindex="0" data-v-ad7ba5ad data-v-fe68a192><!--[--><!----><span data-v-fe68a192>笔记</span><!----><!--]--><!----></a><!--]--><!--]--></nav><!--[--><!--]--><!----><div class="vp-navbar-appearance appearance" data-v-8aa02444 data-v-a9dcbd44><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a9dcbd44 data-v-c9a2ba73 data-v-cea33b13><span class="check" data-v-cea33b13><span class="icon" data-v-cea33b13><!--[--><span class="vpi-sun sun" data-v-c9a2ba73></span><span class="vpi-moon moon" data-v-c9a2ba73></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-8aa02444 data-v-beb0c7f0 data-v-0f2ab498><!--[--><a class="vp-social-link no-icon" href="https://github.com/dead-summer" aria-label="github" target="_blank" rel="noopener" data-v-0f2ab498 data-v-42c2bc06><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-8aa02444 data-v-a9c937da data-v-11ad119f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-11ad119f><span class="vpi-more-horizontal icon" data-v-11ad119f></span></button><div class="menu" data-v-11ad119f><div class="vp-menu" data-v-11ad119f data-v-a9cef2e9><!----><!--[--><!--[--><!----><div class="group" data-v-a9c937da><div class="item appearance" data-v-a9c937da><p class="label" data-v-a9c937da>外观</p><div class="appearance-action" data-v-a9c937da><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a9c937da data-v-c9a2ba73 data-v-cea33b13><span class="check" data-v-cea33b13><span class="icon" data-v-cea33b13><!--[--><span class="vpi-sun sun" data-v-c9a2ba73></span><span class="vpi-moon moon" data-v-c9a2ba73></span><!--]--></span></span></button></div></div></div><div class="group" data-v-a9c937da><div class="item social-links" data-v-a9c937da><div class="vp-social-links social-links-list" data-v-a9c937da data-v-0f2ab498><!--[--><a class="vp-social-link no-icon" href="https://github.com/dead-summer" aria-label="github" target="_blank" rel="noopener" data-v-0f2ab498 data-v-42c2bc06><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-8aa02444 data-v-91de03ad><span class="container" data-v-91de03ad><span class="top" data-v-91de03ad></span><span class="middle" data-v-91de03ad></span><span class="bottom" data-v-91de03ad></span></span></button></div></div></div></div><div class="divider" data-v-8aa02444><div class="divider-line" data-v-8aa02444></div></div></div><!----></header><div class="vp-local-nav reached-top" data-v-203c4ba0 data-v-c553d6dd><button class="menu" aria-expanded="false" aria-controls="SidebarNav" data-v-c553d6dd><span class="vpi-align-left menu-icon" data-v-c553d6dd></span><span class="menu-text" data-v-c553d6dd>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-c553d6dd data-v-8c3ac3e6><button data-v-8c3ac3e6>返回顶部</button><!----></div></div><aside class="vp-sidebar" vp-sidebar data-v-203c4ba0 data-v-bb1063b0><div class="curtain" data-v-bb1063b0></div><nav id="SidebarNav" class="nav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-bb1063b0><span id="sidebar-aria-label" class="visually-hidden" data-v-bb1063b0> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-74a29627><section class="vp-sidebar-item sidebar-item level-0 collapsible" data-v-74a29627 data-v-57d0d9d8><div class="item" role="button" tabindex="0" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><h2 class="text" data-v-57d0d9d8><span data-v-57d0d9d8>基础篇</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-57d0d9d8><span class="vpi-chevron-right caret-icon" data-v-57d0d9d8></span></div></div><div data-v-57d0d9d8 data-v-57d0d9d8><div class="items" data-v-57d0d9d8><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/e1payz4v/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>初识Redis</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/pjp85kqg/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>Redis常见命令</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/2c3djeie/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>Redis的Java客户端</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><div class="no-transition group" data-v-74a29627><section class="vp-sidebar-item sidebar-item level-0 collapsible" data-v-74a29627 data-v-57d0d9d8><div class="item" role="button" tabindex="0" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><h2 class="text" data-v-57d0d9d8><span data-v-57d0d9d8>实战篇</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-57d0d9d8><span class="vpi-chevron-right caret-icon" data-v-57d0d9d8></span></div></div><div data-v-57d0d9d8 data-v-57d0d9d8><div class="items" data-v-57d0d9d8><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/fsqha3c4/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>短信登陆</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/ypglbvn3/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>商户查询缓存</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/7tkkc3e7/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>优惠卷秒杀</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/8crid5vo/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>分布式锁</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/mvf4gmwd/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>分布式锁-redission</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/cl0wi4wa/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>秒杀优化</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/335knvfo/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>Redis消息队列</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/yf15ouip/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>达人探店</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/eb4lyjir/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>好友关注</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/djpov50v/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>附近商户</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/oqrahn7k/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>用户签到</span><!----></p><!--]--><!----></a><!----></div><!----></div><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/th925a73/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>UV统计</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><div class="no-transition group" data-v-74a29627><section class="vp-sidebar-item sidebar-item level-0 collapsible has-active" data-v-74a29627 data-v-57d0d9d8><div class="item" role="button" tabindex="0" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><h2 class="text" data-v-57d0d9d8><span data-v-57d0d9d8>高级篇</span><!----></h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-57d0d9d8><span class="vpi-chevron-right caret-icon" data-v-57d0d9d8></span></div></div><div data-v-57d0d9d8 data-v-57d0d9d8><div class="items" data-v-57d0d9d8><!--[--><div class="vp-sidebar-item sidebar-item level-1 is-link" data-v-57d0d9d8 data-v-57d0d9d8><div class="item" data-v-57d0d9d8><div class="indicator" data-v-57d0d9d8></div><!----><a class="vp-link link link" href="/blog/notes/HMRedis/wynrwt9h/" data-v-57d0d9d8><!--[--><p class="text" data-v-57d0d9d8><span data-v-57d0d9d8>分布式缓存</span><!----></p><!--]--><!----></a><!----></div><!----></div><!--]--></div></div></section></div><!--]--><!--[--><!--]--></nav></aside><!--[--><div id="VPContent" vp-content class="vp-content has-sidebar" data-v-203c4ba0 data-v-15f72782><div class="vp-doc-container has-sidebar has-aside" data-v-15f72782 data-v-a752cb74><!--[--><!--]--><div class="container" data-v-a752cb74><div class="aside" vp-outline data-v-a752cb74><div class="aside-curtain" data-v-a752cb74></div><div class="aside-container" data-v-a752cb74><div class="aside-content" data-v-a752cb74><div class="vp-doc-aside" data-v-a752cb74 data-v-4d99e404><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="vp-doc-aside-outline" role="navigation" data-v-4d99e404 data-v-6151742a><div class="content" data-v-6151742a><div class="outline-marker" data-v-6151742a></div><div id="doc-outline-aria-label" aria-level="2" class="outline-title" role="heading" data-v-6151742a><span data-v-6151742a>此页内容</span><span class="vpi-print icon" data-v-6151742a></span></div><ul class="root" data-v-6151742a data-v-bbb6b19b><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-4d99e404></div><!--[--><!--]--></div></div></div></div><div class="content" data-v-a752cb74><div class="content-container" data-v-a752cb74><!--[--><!--]--><main class="main" data-v-a752cb74><nav class="vp-breadcrumb" data-v-a752cb74 data-v-9134fa65><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-9134fa65><!--[--><li property="itemListElement" typeof="ListItem" data-v-9134fa65><a class="vp-link link breadcrumb" href="/blog/" property="item" typeof="WebPage" data-v-9134fa65><!--[-->首页<!--]--><!----></a><span class="vpi-chevron-right" data-v-9134fa65></span><meta property="name" content="首页" data-v-9134fa65><meta property="position" content="1" data-v-9134fa65></li><li property="itemListElement" typeof="ListItem" data-v-9134fa65><span class="vp-link breadcrumb" property="item" typeof="WebPage" data-v-9134fa65><!--[-->高级篇<!--]--><!----></span><span class="vpi-chevron-right" data-v-9134fa65></span><meta property="name" content="高级篇" data-v-9134fa65><meta property="position" content="2" data-v-9134fa65></li><li property="itemListElement" typeof="ListItem" data-v-9134fa65><a class="vp-link link breadcrumb current" href="/blog/notes/HMRedis/wynrwt9h/" property="item" typeof="WebPage" data-v-9134fa65><!--[-->分布式缓存<!--]--><!----></a><!----><meta property="name" content="分布式缓存" data-v-9134fa65><meta property="position" content="3" data-v-9134fa65></li><!--]--></ol></nav><!--[--><!--]--><!--[--><h1 class="vp-doc-title page-title" data-v-0716210e>分布式缓存 <!----></h1><div class="vp-doc-meta" data-v-0716210e><!--[--><!--]--><p class="reading-time" data-v-0716210e><span class="vpi-books icon" data-v-0716210e></span><span data-v-0716210e>约 7255 字</span><span data-v-0716210e>大约 24 分钟</span></p><!----><!--[--><!--]--><p class="create-time" data-v-0716210e><span class="vpi-clock icon" data-v-0716210e></span><span data-v-0716210e>2025-08-07</span></p></div><!--]--><!--[--><!--]--><div class="_notes_HMRedis_wynrwt9h_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-a752cb74><!--[--><!--]--><div data-v-a752cb74><p>单机 Redis 存在以下四大问题：</p><ul><li><strong>单点故障</strong>：一旦 Redis 实例发生故障，整个缓存系统将无法使用。</li><li><strong>容量瓶颈</strong>：单个 Redis 实例的内存容量有限，无法存储海量数据。</li><li><strong>并发瓶颈</strong>：单个 Redis 实例的并发处理能力有限，无法支持高并发访问。</li><li><strong>流量瓶颈</strong>：单个 Redis 实例的网络带宽有限，无法支持高流量访问。</li></ul><h2 id="_1-1-redis-持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-redis-持久化"><span>1.1 Redis 持久化</span></a></h2><p>为了解决单点故障导致的数据丢失问题，Redis 提供了两种持久化方案：</p><ul><li>RDB 持久化</li><li>AOF 持久化</li></ul><p>接下来，我们将分别介绍这两种持久化方案。</p><h3 id="_1-1-1-rdb-持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-1-rdb-持久化"><span>1.1.1 RDB 持久化</span></a></h3><p>RDB (Redis Database Backup file) 全称 Redis 数据库备份文件，也被称为 Redis 数据快照。简单来说，就是将内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，可以从磁盘读取快照文件，恢复数据。快照文件称为 RDB 文件，默认保存在当前运行目录。</p><h4 id="_1-1-1-1-执行时机" tabindex="-1"><a class="header-anchor" href="#_1-1-1-1-执行时机"><span>1.1.1.1 执行时机</span></a></h4><p>RDB 持久化在四种情况下会执行：</p><ol><li><p><strong><code>save</code> 命令</strong> 执行 <code>save</code> 命令可以立即执行一次 RDB：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">save</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>save</code> 命令会导致主进程执行 RDB，这个过程中其它所有命令都会被阻塞。通常只在数据迁移时使用。</p></li><li><p><strong><code>bgsave</code> 命令</strong> 下面的命令可以异步执行 RDB：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bgsave</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个命令执行后会开启独立进程完成 RDB，主进程可以持续处理用户请求，不受影响。</p></li><li><p><strong>Redis 停机时</strong> Redis 停机时会执行一次 <code>save</code> 命令，实现 RDB 持久化。</p></li><li><p><strong>触发 RDB 条件</strong> Redis 内部有触发 RDB 的机制，可以在 <code>redis.conf</code> 文件中找到，格式如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>save 900 1</span></span>
<span class="line"><span>save 300 10</span></span>
<span class="line"><span>save 60 10000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上配置的含义是：</p><ul><li>900 秒内，如果至少有 1 个 key 被修改，则执行 <code>bgsave</code>。</li><li>300 秒内，如果至少有 10 个 key 被修改，则执行 <code>bgsave</code>。</li><li>60 秒内，如果至少有 10000 个 key 被修改，则执行 <code>bgsave</code>。</li></ul><p>如果设置 <code>save &quot;&quot;</code>，则表示禁用 RDB 持久化。</p></li></ol><h4 id="_1-1-1-2-rdb-原理" tabindex="-1"><a class="header-anchor" href="#_1-1-1-2-rdb-原理"><span>1.1.1.2 RDB 原理</span></a></h4><p><code>bgsave</code> 开始时会 <code>fork</code> 主进程得到子进程，子进程共享主进程的内存数据。完成 <code>fork</code> 后，子进程读取内存数据并写入 RDB 文件。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807155633054-xP53aRYI.png" alt="1.分布式缓存-20250807155633054" width="750" style="display:block;margin:auto;"><p><code>fork</code> 采用的是 copy-on-write 技术：</p><ul><li>当主进程执行读操作时，访问共享内存。</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><h3 id="_1-1-2-aof-持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-2-aof-持久化"><span>1.1.2 AOF 持久化</span></a></h3><h4 id="_1-1-2-1-aof-原理" tabindex="-1"><a class="header-anchor" href="#_1-1-2-1-aof-原理"><span>1.1.2.1 AOF 原理</span></a></h4><p>AOF (Append Only File) 全称为追加文件。Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。</p><h4 id="_1-1-2-2-aof-配置" tabindex="-1"><a class="header-anchor" href="#_1-1-2-2-aof-配置"><span>1.1.2.2 AOF 配置</span></a></h4><p>AOF 默认是关闭的，需要修改 <code>redis.conf</code> 配置文件来开启 AOF：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 是否开启 AOF 功能，默认是 no</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendonly yes</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># AOF 文件的名称</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfilename </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">appendonly.aof</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF 的命令记录的频率也可以通过 <code>redis.conf</code> 文件来配置：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 表示每执行一次写命令，立即记录到 AOF 文件</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfsync always </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 写命令执行完先放入 AOF 缓冲区，然后表示每隔 1 秒将缓冲区数据写到 AOF 文件，是默认方案</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfsync everysec </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 写命令执行完先放入 AOF 缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfsync no</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三种策略的对比如下：</p><ul><li><code>always</code>：每次写命令都立即写入磁盘，性能最差，但数据安全性最高。</li><li><code>everysec</code>：每隔 1 秒将缓冲区数据写入磁盘，性能和数据安全性较好，是默认方案。</li><li><code>no</code>：由操作系统决定何时将缓冲区数据写入磁盘，性能最好，但数据安全性最低。</li></ul><h4 id="_1-1-2-3-aof-文件重写" tabindex="-1"><a class="header-anchor" href="#_1-1-2-3-aof-文件重写"><span>1.1.2.3 AOF 文件重写</span></a></h4><p>由于 AOF (Append Only File) 文件记录的是 Redis 的操作命令，因此 AOF 文件通常比 RDB (Redis DataBase) 文件大。AOF 会记录对同一个 Key 的多次写操作，但只有最后一次写操作的结果才是有效的。</p><p>为了优化 AOF 文件的大小，可以使用 <code>bgrewriteaof</code> 命令手动触发 AOF 文件重写。AOF 重写会创建一个新的 AOF 文件，其中只包含重建当前数据集所需的最少命令集合，从而减小 AOF 文件的大小。</p><p>例如，假设 AOF 文件中原本有以下三个命令，执行 <code>bgrewriteaof</code> 命令后，AOF 文件会被重写为：<code>mset name jack num 666</code>。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807160543998-BbtLRTz-.png" alt="1.分布式缓存-20250807160543998" width="750" style="display:block;margin:auto;"><p>Redis 也会在触发阈值时自动去重写 AOF 文件。阈值也可以在 <code>redis.conf</code> 中配置：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># AOF 文件比上次文件增长超过多少百分比则触发重写</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># AOF 文件体积最小多大以上才触发重写 </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">auto-aof-rewrite-min-size 64mb</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-3-rdb-与-aof-对比" tabindex="-1"><a class="header-anchor" href="#_1-1-3-rdb-与-aof-对比"><span>1.1.3 RDB 与 AOF 对比</span></a></h3><p>RDB 和 AOF 各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th>特性</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如 AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量 CPU 和内存消耗</td><td>低，主要是磁盘 I/O 资源，但 AOF 重写时会占用大量 CPU 和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table><h2 id="_1-2-redis-主从" tabindex="-1"><a class="header-anchor" href="#_1-2-redis-主从"><span>1.2 Redis 主从</span></a></h2><h3 id="_1-2-1-搭建主从架构" tabindex="-1"><a class="header-anchor" href="#_1-2-1-搭建主从架构"><span>1.2.1 搭建主从架构</span></a></h3><p>单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807161051852-DFnBegWz.png" alt="1.分布式缓存-20250807161051852" width="750" style="display:block;margin:auto;"><h3 id="_1-2-2-主从数据同步原理" tabindex="-1"><a class="header-anchor" href="#_1-2-2-主从数据同步原理"><span>1.2.2 主从数据同步原理</span></a></h3><h4 id="_1-2-2-1-全量同步" tabindex="-1"><a class="header-anchor" href="#_1-2-2-1-全量同步"><span>1.2.2.1 全量同步</span></a></h4><p>当主 (master) 从 (slave) 节点第一次建立连接时，会执行<strong>全量同步 (full synchronization)</strong>，即将 master 节点的所有数据都拷贝给 slave 节点。</p><p>全量同步过程可以概括为三个阶段，具体流程如下：</p><ol><li><strong>第一阶段：建立连接与版本信息交换</strong><ul><li>Slave 向 Master 请求数据同步。</li><li>Master 判断是否是第一次同步。判断依据是 Slave 发送的 <code>replid</code> 是否与 Master 的 <code>replid</code> 一致。</li><li>如果是第一次同步（<code>replid</code> 不一致），Master 返回其数据版本信息给 Slave。</li><li>Slave 保存 Master 的版本信息。</li></ul></li><li><strong>第二阶段：RDB 文件生成与传输</strong><ul><li>Master 执行 <code>bgsave</code> 命令，生成 RDB 文件。</li><li>在生成 RDB 文件的同时，Master 会记录期间的所有写命令到 <code>repl_baklog</code>（复制积压缓冲区）。</li><li>Master 将 RDB 文件发送给 Slave。</li><li>Slave 清空本地数据，并加载接收到的 RDB 文件。</li></ul></li><li><strong>第三阶段：增量命令同步</strong><ul><li>Master 将 <code>repl_baklog</code> 中的命令发送给 Slave。</li><li>Slave 执行接收到的命令，以保持与 Master 数据的一致性。</li></ul></li></ol><!--[--><div class="mermaid-actions"><button class="preview-button" title="preview"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1316 1024" fill="currentColor"><path d="M658.286 0C415.89 0 0 297.106 0 512c0 214.82 415.89 512 658.286 512 242.322 0 658.285-294.839 658.285-512S900.608 0 658.286 0zm0 877.714c-161.573 0-512-221.769-512-365.714 0-144.018 350.427-365.714 512-365.714 161.572 0 512 217.16 512 365.714s-350.428 365.714-512 365.714z"/><path d="M658.286 292.571a219.429 219.429 0 1 0 0 438.858 219.429 219.429 0 0 0 0-438.858zm0 292.572a73.143 73.143 0 1 1 0-146.286 73.143 73.143 0 0 1 0 146.286z"/></svg></button><button class="download-button" title="download"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor"><path d="M828.976 894.125H190.189c-70.55 0-127.754-57.185-127.754-127.753V606.674c0-17.634 14.31-31.933 31.933-31.933h63.889c17.634 0 31.932 14.299 31.932 31.933v95.822c0 35.282 28.596 63.877 63.877 63.877h511.033c35.281 0 63.877-28.595 63.877-63.877v-95.822c0-17.634 14.298-31.933 31.943-31.933h63.878c17.635 0 31.933 14.299 31.933 31.933v159.7c0 70.566-57.191 127.751-127.754 127.751zM249.939 267.51c12.921-12.92 33.885-12.92 46.807 0l148.97 148.972V94.893c0-17.634 14.302-31.947 31.934-31.947h63.876c17.638 0 31.946 14.313 31.946 31.947v321.589l148.97-148.972c12.922-12.92 33.876-12.92 46.797 0l46.814 46.818c12.922 12.922 12.922 33.874 0 46.807L552.261 624.93c-1.14 1.138-21.664 13.684-42.315 13.693-20.877.01-41.88-12.542-43.021-13.693L203.122 361.135c-12.923-12.934-12.923-33.885 0-46.807l46.817-46.818z"/></svg></button></div><div class="mermaid-wrapper"><div style="display:flex;align-items:center;justify-content:center;height:96px;" class="mermaid-loading"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)"></span></div></div><!--]--><p>Master 节点通过以下关键标识确认 Slave 是否为初次连接</p><ul><li><strong>Replication Id (<code>replid</code>)</strong>：数据集的标记，用于标识数据集的唯一性。如果 <code>replid</code> 一致，则说明是同一数据集。每个 Master 节点都有唯一的 <code>replid</code>，而 Slave 节点会继承 Master 节点的 <code>replid</code>。</li><li><strong>Offset</strong>：偏移量，表示 Master 已经复制的数据量。随着 <code>repl_baklog</code> 中数据增多而增大。Slave 在完成同步时会记录当前同步的 <code>offset</code>。如果 Slave 的 <code>offset</code> 小于 Master 的 <code>offset</code>，表示 Slave 数据落后于 Master，需要更新。</li></ul><p>Slave 在进行数据同步时，需要向 Master 声明自己的 <code>replid</code> 和 <code>offset</code>，Master 才能判断 Slave 需要同步哪些数据。</p><p>由于 Slave 原本也可能是一个 Master，拥有自己的 <code>replid</code> 和 <code>offset</code>。当 Slave 第一次与 Master 建立连接时，会发送自己的 <code>replid</code> 和 <code>offset</code>。</p><p>Master 通过比较 Slave 发送来的 <code>replid</code> 与自己的 <code>replid</code>，判断是否一致。如果不一致，则表示这是一个全新的 Slave，需要进行全量同步。随后，Master 会将自己的 <code>replid</code> 和 <code>offset</code> 发送给 Slave，Slave 保存这些信息，后续 Slave 的 <code>replid</code> 将与 Master 一致。</p><p><strong>因此，Master 判断节点是否是第一次同步的依据是看 <code>replid</code> 是否一致。</strong></p><h4 id="_1-2-2-2-增量同步" tabindex="-1"><a class="header-anchor" href="#_1-2-2-2-增量同步"><span>1.2.2.2 增量同步</span></a></h4><p>全量同步需要先执行 RDB 操作，然后通过网络传输 RDB 文件给 slave 节点，成本较高。因此，除了第一次同步采用全量同步外，后续 slave 节点与 master 节点通常采用<strong>增量同步</strong>。</p><p>增量同步指的是仅更新 slave 节点与 master 节点之间存在差异的数据部分。其流程如下：</p><ol><li><strong>第一阶段：同步请求</strong><ul><li>Slave 节点重启。</li><li>Slave 节点向 Master 节点发送 <code>psync replid offset</code> 命令。</li><li>Master 节点判断请求的 <code>replid</code> 是否一致。如果不是第一次同步，Master 节点回复 <code>continue</code>。</li></ul></li><li><strong>第二阶段：数据同步</strong><ul><li>Master 节点从 <code>repl_baklog</code> 中获取 <code>offset</code> 之后的数据。</li><li>Master 节点将 <code>offset</code> 后的命令发送给 Slave 节点。</li><li>Slave 节点执行接收到的命令，从而与 Master 节点保持同步。</li></ul></li></ol><!--[--><div class="mermaid-actions"><button class="preview-button" title="preview"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1316 1024" fill="currentColor"><path d="M658.286 0C415.89 0 0 297.106 0 512c0 214.82 415.89 512 658.286 512 242.322 0 658.285-294.839 658.285-512S900.608 0 658.286 0zm0 877.714c-161.573 0-512-221.769-512-365.714 0-144.018 350.427-365.714 512-365.714 161.572 0 512 217.16 512 365.714s-350.428 365.714-512 365.714z"/><path d="M658.286 292.571a219.429 219.429 0 1 0 0 438.858 219.429 219.429 0 0 0 0-438.858zm0 292.572a73.143 73.143 0 1 1 0-146.286 73.143 73.143 0 0 1 0 146.286z"/></svg></button><button class="download-button" title="download"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor"><path d="M828.976 894.125H190.189c-70.55 0-127.754-57.185-127.754-127.753V606.674c0-17.634 14.31-31.933 31.933-31.933h63.889c17.634 0 31.932 14.299 31.932 31.933v95.822c0 35.282 28.596 63.877 63.877 63.877h511.033c35.281 0 63.877-28.595 63.877-63.877v-95.822c0-17.634 14.298-31.933 31.943-31.933h63.878c17.635 0 31.933 14.299 31.933 31.933v159.7c0 70.566-57.191 127.751-127.754 127.751zM249.939 267.51c12.921-12.92 33.885-12.92 46.807 0l148.97 148.972V94.893c0-17.634 14.302-31.947 31.934-31.947h63.876c17.638 0 31.946 14.313 31.946 31.947v321.589l148.97-148.972c12.922-12.92 33.876-12.92 46.797 0l46.814 46.818c12.922 12.922 12.922 33.874 0 46.807L552.261 624.93c-1.14 1.138-21.664 13.684-42.315 13.693-20.877.01-41.88-12.542-43.021-13.693L203.122 361.135c-12.923-12.934-12.923-33.885 0-46.807l46.817-46.818z"/></svg></button></div><div class="mermaid-wrapper"><div style="display:flex;align-items:center;justify-content:center;height:96px;" class="mermaid-loading"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)"></span></div></div><!--]--><h4 id="_1-2-2-3-repl-backlog-原理" tabindex="-1"><a class="header-anchor" href="#_1-2-2-3-repl-backlog-原理"><span>1.2.2.3 <code>repl_backlog</code> 原理</span></a></h4><p><code>repl_backlog</code> 是实现增量同步的核心组件，通过记录命令日志的偏移量（<code>offset</code>）定位主从节点数据差异。</p><p><code>repl_baklog</code> 文件是一个固定大小的环形数组。当角标到达数组末尾后，读写操作会从 0 开始，覆盖头部的数据。<code>repl_baklog</code> 中会记录 Redis 处理过的命令日志以及对应的 <code>offset</code>，包括 Master 节点当前的 <code>offset</code> 和 Slave 节点已经拷贝到的 <code>offset</code>。Slave 节点与 Master 节点的 <code>offset</code> 之间的差异，就是 Slave 节点需要通过增量拷贝同步的数据。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182124284-DrV7V-TM.png" alt="1.分布式缓存-20250807182124284" width="750" style="display:block;margin:auto;"><p>随着数据不断写入，Master 节点的 <code>offset</code> 逐渐增大，Slave 节点也不断拷贝数据，追赶 Master 节点的 <code>offset</code>。直到数组被填满。此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，已经被同步到 Slave 节点的数据即使被覆盖也不会有影响。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182135804-C903XLu2.png" alt="1.分布式缓存-20250807182135804" width="750" style="display:block;margin:auto;"><p>然而，如果 Slave 节点出现网络阻塞，导致 Mater 节点的 <code>offset</code> 远远超过了 Slave 节点的 <code>offset</code>。Master 节点继续写入新数据，其 <code>offset</code> 就会覆盖旧的数据，直到将 Slave 节点当前的 <code>offset</code> 也覆盖。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182213979-VT_sR3_f.png" alt="1.分布式缓存-20250807182213979" width="750" style="display:block;margin:auto;"><p>此时，如果 Slave 节点恢复，需要同步数据，但发现自己的 <code>offset</code> 已经被覆盖，就无法完成增量同步，只能进行全量同步。</p><h3 id="_1-2-3-主从同步优化" tabindex="-1"><a class="header-anchor" href="#_1-2-3-主从同步优化"><span>1.2.3 主从同步优化</span></a></h3><p>主从同步用于保证主节点和从节点的数据一致性，这在 Redis 集群中至关重要。为了优化 Redis 主从集群，可以从以下几个方面入手：</p><ul><li><strong>配置无磁盘复制：</strong> 在 <code>master</code> 节点中配置 <code>repl-diskless-sync yes</code>，启用无磁盘复制，以避免全量同步时产生过多的磁盘 I/O 操作。</li><li><strong>控制内存占用：</strong> 避免 <code>Redis</code> 单节点上的内存占用过大，以减少 <code>RDB</code>（Redis Database）导致的磁盘 I/O。</li><li><strong>调整 backlog 大小：</strong> 适当调整 <code>repl_backlog</code> 的大小，以便 <code>slave</code> 节点在宕机后能够尽快恢复，并尽可能避免全量同步。<code>repl_backlog</code> 是一个环形缓冲区，用于存储 <code>master</code> 节点最近执行的命令，<code>slave</code> 节点可以通过这个缓冲区进行增量同步，从而避免全量同步。</li><li><strong>限制 slave 节点数量：</strong> 限制单个 <code>master</code> 节点上的 <code>slave</code> 节点数量。如果 <code>slave</code> 节点过多，可以采用 “主 - 从 - 从” 链式结构，以减轻 <code>master</code> 节点的压力。</li></ul><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182355001-BmLVsMHl.png" alt="1.分布式缓存-20250807182355001" width="750" style="display:block;margin:auto;"><p>在 “主 - 从 - 从” 链式结构中，<code>master</code> 节点只需要将数据同步给 <code>slave1</code> 节点，然后 <code>slave1</code> 节点再将数据同步给 <code>slave2</code> 和 <code>slave3</code> 节点，以此来降低 <code>master</code> 节点的压力。这种方式通过分担主节点的同步压力，提高了整个集群的性能和可用性。</p><h2 id="_1-3-redis-哨兵" tabindex="-1"><a class="header-anchor" href="#_1-3-redis-哨兵"><span>1.3 Redis 哨兵</span></a></h2><p>Redis 提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><h4 id="_1-3-1-集群结构和作用" tabindex="-1"><a class="header-anchor" href="#_1-3-1-集群结构和作用"><span>1.3.1 集群结构和作用</span></a></h4><p>哨兵的结构如图：</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182727200-BjyxxhhK.png" alt="1.分布式缓存-20250807182727200" width="750" style="display:block;margin:auto;"><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查 master 和 slave 是否按预期工作。</li><li><strong>自动故障恢复</strong>：如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主。</li><li><strong>通知</strong>：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端。</li></ul><h4 id="_1-3-2-集群监控原理" tabindex="-1"><a class="header-anchor" href="#_1-3-2-集群监控原理"><span>1.3.2 集群监控原理</span></a></h4><p>Sentinel 基于心跳机制监测服务状态，每隔 1 秒向集群的每个实例发送 ping 命令：</p><ul><li><strong>主观下线</strong>：如果某 sentinel 节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li><strong>客观下线</strong>：若超过指定数量（<code>quorum</code>）的 sentinel 都认为该实例主观下线，则该实例<strong>客观下线</strong>。<code>quorum</code> 值最好超过 Sentinel 实例数量的一半。 <img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182907041-BUK5Xj2T.png" alt="1.分布式缓存-20250807182907041" width="750" style="display:block;margin:auto;"></li></ul><h4 id="_1-3-3-集群故障恢复原理" tabindex="-1"><a class="header-anchor" href="#_1-3-3-集群故障恢复原理"><span>1.3.3 集群故障恢复原理</span></a></h4><p>当 Sentinel 监测到 Master 节点发生故障时，它会启动故障转移过程，从 Slave 节点中选举出一个新的 Master 节点。选举过程依据以下优先级顺序：</p><ol><li><strong>断开连接时长：</strong> 优先排除与原 Master 节点断开时间过长的 Slave 节点。断开时长的阈值为 <code>down-after-milliseconds * 10</code>。</li><li><strong>Slave 优先级：</strong> 检查 Slave 节点的 <code>slave-priority</code> 配置值。<code>slave-priority</code> 值越小，优先级越高。如果设置为 0，则该 Slave 节点永远不会参与选举。</li><li><strong>Offset 值：</strong> 如果 <code>slave-priority</code> 值相同，则比较 Slave 节点的 Offset 值。Offset 值越大，表示数据越新，优先级越高。</li><li><strong>运行 ID：</strong> 如果 Offset 值也相同，则比较 Slave 节点的运行 ID 大小。运行 ID 越小，优先级越高。</li></ol><p>确定新的 Master 节点后，Sentinel 将执行以下步骤完成切换：</p><p>假设 <code>slave1</code> 被选举为新的 Master 节点，其端口为 7002，切换流程如下：</p><ol><li><strong>提升为 Master：</strong> Sentinel 向备选的 <code>slave1</code> 节点发送 <code>slaveof no one</code> 命令，使其从 Slave 节点提升为 Master 节点，不再从任何 Master 节点同步数据。</li><li><strong>更新 Slave 节点：</strong> Sentinel 向所有其他的 Slave 节点发送 <code>slaveof &lt;ip&gt; 7002</code> 命令，使它们成为新 Master (<code>slave1</code>) 的 Slave 节点，开始从新的 Master 节点同步数据。</li><li><strong>故障节点处理：</strong> Sentinel 将发生故障的原 Master 节点标记为 Slave 节点。当该节点恢复后，会自动成为新的 Master 节点的 Slave 节点。 <img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807183442389-CRxc5C9l.png" alt="1.分布式缓存-20250807183442389" width="750" style="display:block;margin:auto;"></li></ol><h2 id="_1-4-redis-分片集群" tabindex="-1"><a class="header-anchor" href="#_1-4-redis-分片集群"><span>1.4 Redis 分片集群</span></a></h2><h3 id="_1-4-1-分片集群" tabindex="-1"><a class="header-anchor" href="#_1-4-1-分片集群"><span>1.4.1 分片集群</span></a></h3><p>主从复制和哨兵机制虽然解决了 Redis 的高可用性和高并发读问题，但仍存在海量数据存储和高并发写能力的局限性。为应对这两个挑战，可以采用 <strong>分片集群（Sharded Cluster）</strong> 方案。</p><img src="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807233100691-DbT23ZZH.png" alt="1.分布式缓存-20250807233100691" width="750" style="display:block;margin:auto;"><p>分片集群具有以下特点：</p><ul><li><strong>多 Master 节点</strong>：集群中包含多个 <code>master</code> 节点，每个 <code>master</code> 节点负责存储不同的数据子集。</li><li><strong>高可用性</strong>：每个 <code>master</code> 节点都可以配置一个或多个 <code>slave</code> 节点，以实现数据的冗余备份和故障切换，提升整体可用性。</li><li><strong>节点通信</strong>：<code>master</code> 节点之间通过 <code>PING</code> 命令相互监测彼此的健康状态，确保集群的正常运行。</li><li><strong>请求转发</strong>：客户端可以向集群中的任意节点发送请求，即使该节点不存储请求数据，请求也会被自动转发到负责存储该数据的正确节点。</li></ul><h3 id="_1-4-2-散列插槽-hash-slot" tabindex="-1"><a class="header-anchor" href="#_1-4-2-散列插槽-hash-slot"><span>1.4.2 散列插槽（Hash Slot）</span></a></h3><p>在 Redis 分片集群中，数据不是直接与节点绑定的，而是通过 <strong>散列插槽（Hash Slot）</strong> 机制进行管理。Redis 将整个键空间划分为 16384 个插槽，编号从 0 到 16383。每个 <code>master</code> 节点都会被 Redis 分配其中一部分插槽的所有权。</p><p>当数据 <code>key</code> 写入集群时，Redis 会根据 <code>key</code> 的有效部分计算其对应的插槽值。计算规则如下：</p><ul><li><strong>包含 <code>{}</code> 的 <code>key</code></strong>：如果 <code>key</code> 中包含 <code>&quot;{}&quot;</code> 且花括号内至少有一个字符，则花括号内的部分被视为有效部分，例如 <code>&quot;{itcast}num&quot;</code>，有效部分为 <code>&quot;itcast&quot;</code>。</li><li><strong>不包含 <code>{}</code> 的 <code>key</code></strong>：如果 <code>key</code> 中不包含 <code>&quot;{}&quot;</code>，则整个 <code>key</code> 都是有效部分，例如 <code>&quot;num&quot;</code>，有效部分为 <code>&quot;num&quot;</code>。</li></ul><p>插槽值的计算方法是：对 <code>key</code> 的有效部分执行 CRC16 算法得到一个哈希值，然后将该哈希值对 16384 取模，得到的结果即为该 <code>key</code> 对应的插槽值。通过这种方式，Redis 能够将不同的 <code>key</code> 分散到不同的插槽中，进而均匀分布到各个 <code>master</code> 节点上，实现了数据的水平扩展。</p><h3 id="_1-4-3-集群伸缩" tabindex="-1"><a class="header-anchor" href="#_1-4-3-集群伸缩"><span>1.4.3 集群伸缩</span></a></h3><p><code>redis-cli --cluster</code> 提供了丰富的功能来操作 Redis 集群，通过执行 <code>redis-cli --cluster help</code> 命令可以查看所有可用的集群命令。</p><h4 id="_1-4-3-1-需求分析" tabindex="-1"><a class="header-anchor" href="#_1-4-3-1-需求分析"><span>1.4.3.1 需求分析</span></a></h4><p>假设当前 Redis 集群配置如下，包含三个主节点和三个从节点：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>127.0.0.1</td><td>7001</td><td>master</td></tr><tr><td>127.0.0.1</td><td>7002</td><td>master</td></tr><tr><td>127.0.0.1</td><td>7003</td><td>master</td></tr><tr><td>127.0.0.1</td><td>8001</td><td>slave</td></tr><tr><td>127.0.0.1</td><td>8002</td><td>slave</td></tr><tr><td>127.0.0.1</td><td>8003</td><td>slave</td></tr></tbody></table><p>我们的目标是向集群中添加一个新的主节点，并确保某个特定的键（例如 <code>num</code>）能够存储到这个新节点上。具体步骤包括：</p><ol><li>启动一个新的 Redis 实例，端口为 7004。</li><li>将 7004 节点添加到现有集群中，并将其角色设置为 master 节点。</li><li>为 7004 节点分配插槽 (slots)，以便可以存储诸如 <code>num</code> 这样的键。</li></ol><p>这项任务涉及到两项核心功能：向集群添加新节点和将部分插槽重新分配给新节点。</p><h4 id="_1-4-3-2-创建新的-redis-实例" tabindex="-1"><a class="header-anchor" href="#_1-4-3-2-创建新的-redis-实例"><span>1.4.3.2 创建新的 Redis 实例</span></a></h4><p>首先，为新的 Redis 实例创建一个独立的文件夹：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">mkdir</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7004</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后，在该文件夹内编写 <code>redis.conf</code> 配置文件，以配置 7004 端口的 Redis 实例：</p><div class="language-ini line-numbers-mode" data-highlighter="shiki" data-ext="ini" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ini"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">port 7004</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 开启集群功能</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cluster-enabled yes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 节点心跳失败的超时时间，单位为毫秒</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cluster-node-timeout 5000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 绑定地址</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">bind 127.0.0.1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 集群的配置文件，用于记录集群状态、节点信息等</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cluster-config-file nodes.conf</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 持久化文件存放目录</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">dir .\</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 注册的实例 IP，用于在集群中广播本节点的 IP 地址</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">replica-announce-ip 127.0.0.1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 保护模式，yes 模式下，只有本地连接和配置文件中绑定的 IP 才能访问</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">protected-mode no</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 数据库数量</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">databases 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完成后，使用以下命令启动新的 Redis 实例：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-server</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 7004/redis.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_1-4-3-3-添加新节点到-redis-集群" tabindex="-1"><a class="header-anchor" href="#_1-4-3-3-添加新节点到-redis-集群"><span>1.4.3.3 添加新节点到 Redis 集群</span></a></h4><p>新的 Redis 实例启动后，需要使用 <code>redis-cli --cluster add-node</code> 命令将其添加到现有集群中。该命令的第一个参数是新节点的地址，第二个参数是集群中任意一个已存在节点的地址：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> add-node</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:7004</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:7001</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行此命令后，7004 节点将被添加到集群中。可以通过连接到集群中的任意一个节点（例如 7001）并执行 <code>cluster nodes</code> 命令来查看集群的当前状态：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7001</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> nodes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>输出信息中会包含 7004 节点，其角色默认为 <code>master</code>。然而，此时 7004 节点分配到的插槽数量为 0，这意味着它不能存储任何数据。例如，输出可能显示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>284f83b33d7b1794cb7893a7f335b6e935de6a07 127.0.0.1:7004@17004 master - 0 1754643918119 0 connected</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此行表示 7004 节点已连接，但没有分配任何插槽。</p><h4 id="_1-4-3-4-转移插槽" tabindex="-1"><a class="header-anchor" href="#_1-4-3-4-转移插槽"><span>1.4.3.4 转移插槽</span></a></h4><p>为了使新添加的 7004 节点能够存储数据，需要将一部分插槽从现有主节点迁移到 7004 节点。首先，我们需要确定目标键 <code>num</code> 对应的插槽。通过客户端尝试获取 <code>num</code> 键，Redis 集群会重定向到负责该插槽的节点，从而获取其插槽 ID：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">127.0.0.1:7002</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">get</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> num</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Redirected</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> to</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> slot</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [2765] located at 127.0.0.1:7001</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">&quot;124&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述结果可知，<code>num</code> 键位于插槽 2765，当前由 127.0.0.1:7001 节点负责。为了让 <code>num</code> 存储到 7004 节点，需要将包含插槽 2765 的一部分插槽从 7001 节点转移到 7004 节点。</p><p>使用 <code>redis-cli --cluster reshard</code> 命令启动插槽迁移流程。连接到集群中的任意主节点（例如 7001）来执行此命令：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7001</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> reshard</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:7001</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该命令会进入交互式模式，引导用户完成插槽迁移。</p><ol><li><strong>确定要移动的插槽数量</strong>：系统会提示“How many slots do you want to move (from 1 to 16384)?”。我们计划移动 3000 个插槽，因此输入 <code>3000</code>。<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>How many slots do you want to move (from 1 to 16384)? 3000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>指定接收插槽的节点 ID</strong>：系统会提示“What is the receiving node ID?”。这里需要提供 7004 节点的 ID。可以通过 <code>redis-cli -p 7001 cluster nodes</code> 命令查看 7004 节点的 ID，然后粘贴到控制台。<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>What is the receiving node ID? 284f83b33d7b1794cb7893a7f335b6e935de6a07</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>指定插槽的源节点 ID</strong>：系统会询问插槽来自哪些源节点。 <ul><li>输入 <code>all</code> 表示从所有主节点均匀地迁移插槽。</li><li>输入具体的节点 ID 表示只从该节点迁移插槽。</li><li>输入 <code>done</code> 表示已输入所有源节点 ID。 由于我们希望从 7001 节点迁移插槽，因此输入 7001 节点的 ID，然后输入 <code>done</code>。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Please enter all the source node IDs.</span></span>
<span class="line"><span>  Type &#39;all&#39; to use all the nodes as source nodes for the hash slots.</span></span>
<span class="line"><span>  Type &#39;done&#39; once you entered all the source nodes IDs.</span></span>
<span class="line"><span>Source node #1: b04e83dbc31ac2200b5f6adc7e83e01d0cd6bb35</span></span>
<span class="line"><span>Source node #2: done</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>确认重分片计划</strong>：在显示了提议的重分片计划后，系统会询问是否继续执行：“Do you want to proceed with the proposed reshard plan (yes/no)?”。输入 <code>yes</code> 确认。<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Do you want to proceed with the proposed reshard plan (yes/no)? yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><p>完成上述步骤后，插槽迁移将开始执行。迁移完成后，再次使用 <code>redis-cli -p 7001 cluster nodes</code> 命令查看集群状态，可以看到 7004 节点的插槽数量已经变为约 3000 个（0-2999），这表示插槽已成功转移，目标达成：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>284f83b33d7b1794cb7893a7f335b6e935de6a07 127.0.0.1:7004@17004 master - 0 1754644622000 7 connected 0-2999</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_1-4-4-故障转移" tabindex="-1"><a class="header-anchor" href="#_1-4-4-故障转移"><span>1.4.4 故障转移</span></a></h3><p>本章节主要介绍 Redis 集群的故障转移机制，包括自动故障转移和手动故障转移。</p><h4 id="_1-4-4-1-自动故障转移" tabindex="-1"><a class="header-anchor" href="#_1-4-4-1-自动故障转移"><span>1.4.4.1 自动故障转移</span></a></h4><p>当集群中的一个主节点（master）发生宕机时，Redis 集群会自动进行故障转移。假设集群的初始状态如下：</p><table><thead><tr><th style="text-align:left;">IP</th><th style="text-align:left;">PORT</th><th style="text-align:left;">角色</th></tr></thead><tbody><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">7001</td><td style="text-align:left;">master</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">7002</td><td style="text-align:left;">master</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">7003</td><td style="text-align:left;">master</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">8001</td><td style="text-align:left;">slave</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">8002</td><td style="text-align:left;">slave</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">8003</td><td style="text-align:left;">slave</td></tr></tbody></table><p>如果主节点 7002 宕机，其自动故障转移流程如下：</p><ol><li><strong>连接丢失</strong>：宕机实例（7002）首先会与集群中的其他实例失去连接。</li><li><strong>疑似宕机（PFAIL）</strong>：集群中的其他节点会检测到 7002 节点不可达，并将其标记为“可能宕机”（PFAIL）。</li><li><strong>确定下线（FAIL）</strong>：当集群中半数以上的主节点都认为 7002 节点不可用时，它就会被标记为“确定下线”（FAIL）。</li><li><strong>自动提升</strong>：集群会自动从 7002 的从节点（slave）中选举一个，将其提升为新的主节点。</li><li><strong>角色转变</strong>：当原宕机的 7002 节点重新启动后，它会自动作为新主节点的从节点加入集群。</li></ol><p>通过执行以下命令可以模拟 7002 主节点宕机：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7002</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> shutdown</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_1-4-4-2-手动故障转移" tabindex="-1"><a class="header-anchor" href="#_1-4-4-2-手动故障转移"><span>1.4.4.2 手动故障转移</span></a></h4><p>除了自动故障转移，Redis 也支持通过 <code>CLUSTER FAILOVER</code> 命令进行手动故障转移。此命令允许将集群中某个主节点的角色“转移”给其对应的从节点，从而实现无感知的客户端连接切换和数据迁移。</p><p>手动故障转移的流程图解如下：</p><!--[--><div class="mermaid-actions"><button class="preview-button" title="preview"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1316 1024" fill="currentColor"><path d="M658.286 0C415.89 0 0 297.106 0 512c0 214.82 415.89 512 658.286 512 242.322 0 658.285-294.839 658.285-512S900.608 0 658.286 0zm0 877.714c-161.573 0-512-221.769-512-365.714 0-144.018 350.427-365.714 512-365.714 161.572 0 512 217.16 512 365.714s-350.428 365.714-512 365.714z"/><path d="M658.286 292.571a219.429 219.429 0 1 0 0 438.858 219.429 219.429 0 0 0 0-438.858zm0 292.572a73.143 73.143 0 1 1 0-146.286 73.143 73.143 0 0 1 0 146.286z"/></svg></button><button class="download-button" title="download"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" fill="currentColor"><path d="M828.976 894.125H190.189c-70.55 0-127.754-57.185-127.754-127.753V606.674c0-17.634 14.31-31.933 31.933-31.933h63.889c17.634 0 31.932 14.299 31.932 31.933v95.822c0 35.282 28.596 63.877 63.877 63.877h511.033c35.281 0 63.877-28.595 63.877-63.877v-95.822c0-17.634 14.298-31.933 31.943-31.933h63.878c17.635 0 31.933 14.299 31.933 31.933v159.7c0 70.566-57.191 127.751-127.754 127.751zM249.939 267.51c12.921-12.92 33.885-12.92 46.807 0l148.97 148.972V94.893c0-17.634 14.302-31.947 31.934-31.947h63.876c17.638 0 31.946 14.313 31.946 31.947v321.589l148.97-148.972c12.922-12.92 33.876-12.92 46.797 0l46.814 46.818c12.922 12.922 12.922 33.874 0 46.807L552.261 624.93c-1.14 1.138-21.664 13.684-42.315 13.693-20.877.01-41.88-12.542-43.021-13.693L203.122 361.135c-12.923-12.934-12.923-33.885 0-46.807l46.817-46.818z"/></svg></button></div><div class="mermaid-wrapper"><div style="display:flex;align-items:center;justify-content:center;height:96px;" class="mermaid-loading"><span style="--loading-icon: url(&quot;data:image/svg+xml;utf8,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; preserveAspectRatio=&#39;xMidYMid&#39; viewBox=&#39;25 25 50 50&#39;%3E%3CanimateTransform attributeName=&#39;transform&#39; type=&#39;rotate&#39; dur=&#39;2s&#39; keyTimes=&#39;0;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;360&#39;%3E%3C/animateTransform%3E%3Ccircle cx=&#39;50&#39; cy=&#39;50&#39; r=&#39;20&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39; stroke-width=&#39;4&#39; stroke-linecap=&#39;round&#39;%3E%3Canimate attributeName=&#39;stroke-dasharray&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;1,200;90,200;1,200&#39;%3E%3C/animate%3E%3Canimate attributeName=&#39;stroke-dashoffset&#39; dur=&#39;1.5s&#39; keyTimes=&#39;0;0.5;1&#39; repeatCount=&#39;indefinite&#39; values=&#39;0;-35px;-125px&#39;%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E&quot;);--icon-size: 48px;display: inline-block;width: var(--icon-size);height: var(--icon-size);background-color: currentcolor;-webkit-mask-image: var(--loading-icon);mask-image: var(--loading-icon)"></span></div></div><!--]--><p>流程详情：</p><ol><li><strong>发起请求</strong>：从节点（slave）向其主节点（master）发送请求，告知主节点停止接受客户端写入请求。</li><li><strong>主节点响应</strong>：主节点返回当前的复制偏移量（replication offset）给从节点。</li><li><strong>数据同步</strong>：从节点等待，直到其复制偏移量与主节点的偏移量完全一致，确保数据完全同步。</li><li><strong>开始转移</strong>：从节点和主节点同时开始执行故障转移逻辑。</li><li><strong>角色切换</strong>：从节点将自己标记为新的主节点，并向集群中的其他主节点广播故障转移的结果。它也会向原主节点发送广播，告知其现在应作为从节点。</li><li><strong>处理读请求</strong>：其他收到广播的主节点会更新集群配置，并将对原主节点的读请求重定向到新的主节点。原主节点收到通知后，也会开始作为从节点处理读请求（不再接受写请求）。</li></ol><p><code>CLUSTER FAILOVER</code> 命令支持三种模式：</p><ul><li><strong>缺省（Default）</strong>：按照上述完整流程执行，包括数据一致性校验。</li><li><strong><code>FORCE</code></strong>：强制模式，省略了对数据偏移量（offset）一致性的校验，即使数据未完全同步也进行故障转移。这可能导致少量数据丢失，但在紧急情况下可以更快地完成转移。</li><li><strong><code>TAKEOVER</code></strong>：接管模式，直接执行第 5 步（将自己标记为 master 并广播），忽略数据一致性、忽略原主节点的状态以及其他主节点的意见。这种模式风险最高，通常用于特定运维场景，可能导致数据不一致和集群混乱。</li></ul><p>假设在之前的自动故障转移后，7002 已经变为了从节点。我们希望 7002 重新成为主节点。</p><p>执行步骤如下：</p><ol><li>通过 <code>redis-cli</code> 连接到 7002 节点。</li><li>执行 <code>CLUSTER FAILOVER</code> 命令。</li></ol><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7002</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> failover</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行效果展示了 7002 节点已经成功成为主节点，并显示其新的集群信息：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>c57872aef079f96eecde34aaf5e16c6bcdd2f360 127.0.0.1:7002@17002 master - 0 1754646722000 10 connected 5461-10922</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这表明 7002 节点成功重新变为 master 节点，并且负责管理哈希槽范围 5461-10922。</p></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-a752cb74 data-v-3b1a1da3><!--[--><!--]--><!----><div class="contributors" aria-label="Contributors" data-v-3b1a1da3><span class="contributors-label" data-v-3b1a1da3>贡献者: </span><span class="contributors-info" data-v-3b1a1da3><!--[--><!--[--><span class="contributor" data-v-3b1a1da3>dead_summer</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-3b1a1da3><div class="pager" data-v-3b1a1da3><a class="vp-link link pager-link prev" href="/blog/notes/HMRedis/th925a73/" data-v-3b1a1da3><!--[--><span class="desc" data-v-3b1a1da3>上一页</span><span class="title" data-v-3b1a1da3>UV统计</span><!--]--><!----></a></div><div class="pager" data-v-3b1a1da3><!----></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button style="display:none;" type="button" class="vp-back-to-top" aria-label="back to top" data-v-203c4ba0 data-v-f713c552><span class="percent" data-allow-mismatch data-v-f713c552>0%</span><span class="show icon vpi-back-to-top" data-v-f713c552></span><svg aria-hidden="true" data-v-f713c552><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-f713c552></circle></svg></button><footer class="vp-footer has-sidebar" vp-footer data-v-203c4ba0 data-v-b4deef1b><!--[--><div class="container" data-v-b4deef1b><p class="message" data-v-b4deef1b>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/blog/assets/app-CAzY0Upz.js" defer></script></body></html>