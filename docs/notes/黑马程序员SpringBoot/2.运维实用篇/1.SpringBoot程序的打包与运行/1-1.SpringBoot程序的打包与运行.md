---
title: 1-1.SpringBoot程序的打包与运行
createTime: 2025/06/20 19:27:14
permalink: /article/o61xl4bt/
---
通常，我们在 IDEA 中编写并运行程序。但实际开发完成后，项目需要部署在专用服务器上，而非开发者的个人电脑。服务器通常配置更高，安全性更强。因此，我们需要将程序打包成一个文件，然后传输到服务器上运行。这个过程包括打包和运行两个关键步骤。

## 1. 程序打包

SpringBoot 程序是基于 Maven 构建的。Maven 提供了 `package` 指令，用于将程序打包成可执行文件。可以在终端执行该指令。

```java
mvn package
```

执行打包命令后，会生成一个与工程名类似的 JAR 文件，其命名规则为 `模块名-版本号.jar`。

## 2. 程序运行

程序打包完成后，就可以直接运行了。在程序包所在的目录下，执行以下指令：

```java
java -jar 工程包名.jar
```

程序将正常运行，与在 IDEA 中运行没有区别。

**特别关注：**

* 如果计算机中没有安装 Java 的 JDK 环境，则无法正确执行上述操作，因为程序执行依赖 `java` 指令。
* 在使用向导创建 SpringBoot 工程时，`pom.xml` 文件中会包含以下配置。这段配置至关重要，不能删除，否则打包后程序可能无法正常执行。

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

## 3. SpringBoot 程序打包失败处理

有时，打包后的程序可能无法正常执行，例如出现 "failed to find Main-Class manifest attribute" 错误。要理解这个问题，需要了解 JAR 文件的工作机制。

![[1-1.SpringBoot程序的打包与运行_附件/1-1.SpringBoot程序的打包与运行-20250620192957350.png]]

平时开发中会接触到很多 JAR 包，例如 MySQL 的驱动 JAR 包。但并非所有的 JAR 包都可以直接用 `java -jar` 指令执行。SpringBoot 项目之所以能执行，是因为其打包方式不同。

在 SpringBoot 工程的 `pom.xml` 文件中，前面提到的 `<build>` 标签下的 `<plugins>` 配置决定了打包出来的程序包是否可执行。

为了更清晰地理解，我们可以分别开启和注释掉这段配置，然后执行两次打包，观察两次打包后的程序包的差别。主要有以下三个方面的不同：

* 打包后文件的大小不同
* 打包后所包含的内容不同
* 打包程序中个别文件内容不同

### **文件大小不同**

带有 `<plugins>` 配置时，打包生成的程序包体积通常比不带配置的大很多，这主要是因为包含了很多依赖的 JAR 包。

### **文件内容不同**

解压程序包后会发现，带有 `<plugins>` 配置的程序包中包含一个 `BOOT-INF` 目录，其中 `classes` 目录下存放着项目自身编译后的类文件，`lib` 目录下存放着项目依赖的所有 JAR 包。而没有 `<plugins>` 配置的程序包通常只包含编译后的类文件。

### **`MANIFEST.MF` 文件内容不同**

两个程序包的 `META-INF` 目录下都有一个名为 `MANIFEST.MF` 的文件，但内容不同。

* 小容量文件的 `MANIFEST.MF`：

    ```java
    Manifest-Version: 1.0
    Implementation-Title: springboot_08_ssmp
    Implementation-Version: 0.0.1-SNAPSHOT
    Build-Jdk-Spec: 1.8
    Created-By: Maven Jar Plugin 3.2.0
    ```
* 大容量文件的 `MANIFEST.MF`：

    ```java
    Manifest-Version: 1.0
    Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx
    Implementation-Title: springboot_08_ssmp
    Implementation-Version: 0.0.1-SNAPSHOT
    Spring-Boot-Layers-Index: BOOT-INF/layers.idx
    Start-Class: com.itheima.SSMPApplication
    Spring-Boot-Classes: BOOT-INF/classes/
    Spring-Boot-Lib: BOOT-INF/lib/
    Build-Jdk-Spec: 1.8
    Spring-Boot-Version: 2.5.4
    Created-By: Maven Jar Plugin 3.2.0
    Main-Class: org.springframework.boot.loader.JarLauncher
    ```

大文件比小文件多了几行信息，其中最关键的一行是 `Main-Class: org.springframework.boot.loader.JarLauncher`。这行配置指定了使用 `java -jar` 命令执行此程序包时，将执行 `org.springframework.boot.loader.JarLauncher` 类。

`JarLauncher` 类会查找 `Start-Class` 属性中配置的类，并执行对应的类。在本例中，`Start-Class` 属性对应的是引导类 `com.itheima.SSMPApplication`。

**总结：**

1.  SpringBoot 程序添加 `<plugins>` 配置后会打出一个特殊的包，包含 Spring 框架部分功能、原始工程内容以及原始工程依赖的 JAR 包。
2.  首先读取 `MANIFEST.MF` 文件中的 `Main-Class` 属性，用来标记执行 `java -jar` 命令后运行的类。
3.  `JarLauncher` 类执行时会找到 `Start-Class` 属性，也就是启动类类名。
4.  运行启动类时会运行当前工程的内容。
5.  运行当前工程时会使用依赖的 JAR 包，从 `lib` 目录中查找。

因此，SpringBoot 打包出来的程序包为了能够独立运行，将所有需要使用的资源都添加到了这个包里。

如果打包时没有使用 `<plugins>` 配置，则打包后形成一个普通的 JAR 包，在 `MANIFEST.MF` 文件中也就没有了 `Main-Class` 对应的属性，所以运行时会提示找不到主清单属性，这就是报错的原因。
