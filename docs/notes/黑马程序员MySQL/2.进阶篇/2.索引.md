---
title: 索引
createTime: 2025/07/29 15:36:24
permalink: /notes/HMMySQL/ko34x1iq/
---
## 2.1 索引概述

### 2.1.1 介绍

索引 (index) 是帮助 MySQL 高效获取数据的数据结构 (有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用 (指向) 数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

## 2.2 演示

考虑这样一张表：

![[2.索引_附件/2.索引-20250729153836548.png]]

1.  无索引情况：

    当执行 `SELECT * FROM user WHERE age = 45;` 时，在没有索引的情况下，MySQL 需要从表的第一行开始扫描，一直扫描到最后一行，这个过程称为全表扫描，性能很低。

    ![[2.索引_附件/2.索引-20250729153851665.png]]

2.  有索引情况：

    如果针对 age 字段建立了索引，假设索引结构是二叉树，那么会针对 age 这个字段建立一个二叉树的索引结构。

    ![[2.索引_附件/2.索引-20250729153911325.png]]

    通过这个索引结构，只需要扫描三次就可以找到 age = 45 的数据，极大地提高了查询效率。

### 2.3 特点

索引的特点可以概括为以下几点：

| 优势                                 | 劣势                                                                  |
| ---------------------------------- | ------------------------------------------------------------------- |
| 提高数据检索的效率，降低数据库的 I/O 成本            | 索引列也是要占用空间的。                                                        |
| 通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 `INSERT`, `UPDATE`, `DELETE` 时，效率降低。 |

## 2.2 索引结构

### 2.2.1 概述

MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 索引结构    | 描述                                                                         |
| --------- | ---------------------------------------------------------------------------- |
| B+Tree 索引 | 最常见的索引类型，大部分引擎都支持 B+ 树索引                                              |
| Hash 索引   | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询                                |
| R-tree 索引 | 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少                               |
| Full-text 索引 | 是一种通过建立倒排索引，快速匹配文档的方式。类似于 Lucene, Solr, ElasticSearch。 |

上述是 MySQL 中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。

| 索引       | InnoDB | MyISAM | Memory |
| ---------- | ------ | ------ | ------ |
| B+tree 索引 | 支持     | 支持     | 支持     |
| Hash 索引  | 不支持   | 不支持   | 支持     |
| R-tree 索引 | 不支持   | 支持     | 不支持   |
| Full-text  | 5.6 版本之后支持 | 支持     | 不支持   |

### 2.2.2 二叉树

假如 MySQL 的索引结构采用二叉树的数据结构，比较理想的结构如下：

![[2.索引_附件/2.索引-20250729154333155.png]]

但是，如果主键是顺序插入的，则会形成一个单向链表，结构如下：

![[2.索引_附件/2.索引-20250729154341134.png]]

所以，如果选择二叉树作为索引结构，会存在以下缺点：

* 顺序插入时，会形成一个链表，查询性能大大降低。
* 大数据量情况下，层级较深，检索速度慢。

### 2.2.3 B-Tree

虽然红黑树作为一种自平衡二叉树，在顺序插入数据时能保持平衡，但由于其本质仍然是二叉树，所以在面对大数据量时，层级会变得较深，导致检索速度变慢。

![[2.索引_附件/2.索引-20250729154555203.png]]

因此，MySQL 并没有选择二叉树或红黑树，而是选择了 B+Tree。为了更好地理解 B+Tree，首先介绍 B-Tree。

B-Tree（B 树）是一种多叉平衡查找树，与二叉树不同，B 树的每个节点可以有多个分支。例如，一个最大度数（max-degree）为 5 (5 阶) 的 B-Tree，其每个节点最多可以存储 4 个 key 和 5 个指针。

![[2.索引_附件/2.索引-20250729154650515.png]]

B-Tree 的特点包括：

* 对于 5 阶的 B 树，每个节点最多存储 4 个 key，对应 5 个指针。
* 当节点存储的 key 数量达到 5 时，会进行裂变，中间元素向上分裂。
* B 树中，非叶子节点和叶子节点都会存放数据。

### 2.2.4 B+Tree

B+Tree 是 B-Tree 的变种。以一个最大度数（max-degree）为 4 (4 阶) 的 B+Tree 为例，观察其结构。

![[2.索引_附件/2.索引-20250729155246544.png]]

B+Tree 的结构可以分为两部分：

*   **索引部分（绿色框）：** 仅用于索引数据，不存储实际数据。
*   **数据存储部分（红色框）：** 位于叶子节点，存储具体的数据。

B+Tree 与 B-Tree 的主要区别在于：

* 所有的数据都存储在叶子节点。
* 叶子节点形成一个单向链表，方便范围查询。
* 非叶子节点仅起到索引数据的作用，具体的数据都存储在叶子节点。

上述结构是标准的 B+Tree 数据结构。MySQL 对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的 B+Tree，从而提高了区间访问的性能，并有利于排序。

![[2.索引_附件/2.索引-20250729155429412.png]]

### 2.2.5 Hash

除了 B+Tree 索引，MySQL 还支持 Hash 索引。

哈希索引采用一定的 hash 算法，将键值转换成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。

![[2.索引_附件/2.索引-20250729155514435.png]]

当两个或多个键值映射到同一个槽位时，会产生 hash 冲突（也称为 hash 碰撞），可以通过链表来解决。

![[2.索引_附件/2.索引-20250729155526686.png]]

Hash 索引的特点包括：

* Hash 索引只能用于对等比较 (`=`, `in`)，不支持范围查询 (`between`, `>`, `<`, ...)。
* 无法利用索引完成排序操作。
* 查询效率高，通常（在没有 hash 冲突的情况下）只需要一次检索，效率通常高于 B+Tree 索引。

在 MySQL 中，支持 Hash 索引的是 Memory 存储引擎。InnoDB 存储引擎具有自适应 hash 功能，Hash 索引是由 InnoDB 根据 B+Tree 索引在特定条件下自动构建的。

## 2.3 索引分类

### 2.3.1 索引分类

在 MySQL 数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。

| 分类   | 含义                          | 特点           | 关键字      |
| ---- | --------------------------- | ------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复            | 可以有多个        | UNIQUE   |
| 常规索引 | 快速定位特定数据                    | 可以有多个        |          |
| 全文索引 | 全文索引查找的是文本中的关键词, 而不是比较索引中的值 | 可以有多个        | FULLTEXT |

### 2.3.2 聚集索引 & 二级索引

在 InnoDB 存储引擎中，根据索引的存储形式，索引可以分为以下两种：

*   **聚集索引 (Clustered Index)**：数据存储与索引放在一起，索引结构的叶子节点保存了行数据。每个表必须有且只能有一个聚集索引。
*   **二级索引 (Secondary Index)**：数据与索引分开存储，索引结构的叶子节点关联的是对应的主键。一个表可以存在多个二级索引。

聚集索引的选取规则如下：

* 如果存在主键，主键索引就是聚集索引。
* 如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引。
* 如果表没有主键，也没有合适的唯一索引，InnoDB 会自动生成一个 `rowid` 作为隐藏的聚集索引。

![[2.索引_附件/2.索引-20250729161530720.png]]

在数据库查询优化中，一个常见的性能考量是回表查询（Covering Index Overhead）。以下以具体 SQL 语句 `SELECT * FROM user WHERE name = 'Arm';` 为例，分析其查询过程的细节，说明回表查询的实现机制。该查询的核心目的是通过 `name` 条件定位数据并返回所有列（`SELECT *`），这会导致额外的索引查找步骤。

查询过程划分为三个步骤，具体如下：

1. **在二级索引中匹配查找**：
   由于查询条件是 `name = 'Arm'`，系统首先访问 `name` 字段的二级索引。在该索引结构中，键值 `'Arm'` 仅存储了对应的主键值（例如 `10`），而不包含完整行数据。因此，索引查找仅返回主键信息，用于后续步骤。

2. **在聚集索引中获取完整数据**：
   查询要求返回所有列（通过 `SELECT *` 指定），因此系统需要获取整行数据。根据前一步骤获得的主键值 `10`，转入聚集索引进行查找。聚集索引基于主键组织数据，能直接定位主键 `10` 对应的完整行记录（行 `row`）。

3. **数据返回**：
   系统最终提取这一行的所有数据值，并返回给用户。整个过程结束。

这个过程被称为**回表查询**，因为它先在二级索引中找到主键值（一步查找），再“返回”到聚集索引中基于主键值获取完整行数据（另一步查找）。回表查询会增加额外的磁盘 I/O 和延迟，当查询涉及未覆盖的列时（如本例中的 `SELECT *`），它可能导致性能问题。

::: question 思考题

以下两条 SQL 语句，哪个执行效率高？为什么？

- **A.** `SELECT * FROM user WHERE id = 10;`
- **B.** `SELECT * FROM user WHERE name = 'Arm';`

备注：`id` 字段为主键，`name` 字段已创建索引（二级索引）。

**分析与解释:**

- **A 语句的效率更高**，理由是其直接利用聚集索引（主键索引）访问数据。
    - 当执行 A 语句时，InnoDB 引擎通过主键索引直接定位到对应的数据行（因为 `id` 是主键），查询过程仅需一次索引扫描即可返回完整数据，开销较低。
- **B 语句的效率较低**，因为需要经过回表查询过程。
    - `name` 字段的索引为二级索引（非聚集索引），查询需先扫描该索引以获取主键值（例如 `id`），再通过主键索引查询完整数据行。这种额外步骤增加了 I/O 操作和时延，尤其在大数据量场景下性能显著下降。
:::

::: question InnoDB 主键索引的 B+tree 高度如何估算？

**关键假设（参数值取自用户输入）:**

- **行大小**：1 KB（1024 bytes）
- **页大小**：16 KB = 16 × 1024 bytes = 16384 bytes
- **指针大小**（child pointer 或者页指针）：6 bytes
- **主键大小**（这里假设是 `BIGINT`）：8 bytes

**计算原理:**  
B+tree 高度取决于索引节点存储结构：
![[2.索引_附件/2.索引-20250729155429412.png]]
非叶节点的每个条目要存 **键值** + **指针**，总大小要放进 16 KB 页面：

- 每个键（key）占 8 bytes
- 每个指针（pointer）占 6 bytes
- 如果一个节点有 n 个键，就会有 n+1 个指针

所以容量限制是：

$$
n \times 8 + (n + 1) \times 6 \leq 16384

$$

可得每个非叶节点 **至多** 放 1170 个键，指针数是 1171 个。

**高度为 2 时的计算:**

- 根节点（层 1）直接指向叶子页：根能有最多 1171 个子指针
- 每个叶子页存 16 行
- 总行数 ≈ 1171 × 16 = 18 736 行
- **结论:** 若高度为 2，索引最多可存储约 18,000 条记录。

**高度为 3 时的计算:**

- 根 → 中间层 → 叶子层，总共两级索引节点
- 每个中间节点也能有 1171 个子指针
- 总行数 ≈ 1171 (root 指针) × 1171 (次级指针) × 16 (叶子行)
- 1171² × 16 ≈ 1 371 241 × 16 ≈ 21 939 856 行
- **结论:** 若高度为 3，索引可存储约 2200 万条记录。

:::

## 2.4 索引语法

1. 创建索引

	```sql
	CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... );
	```

2. 查看索引

	```sql
	SHOW INDEX FROM table_name;
	```

3. 删除索引

	```sql
	DROP INDEX index_name ON table_name;
	```

## 2.5 SQL 性能分析

### 2.5.1 SQL 执行频率

连接 MySQL 客户端成功后，可以使用 `show [session|global] status` 命令来查看服务器状态信息。`session` 关键字用于查看当前会话的状态，而 `global` 关键字用于查询全局数据。

通过以下 SQL 指令，可以查看当前数据库的 `INSERT`、`UPDATE`、`DELETE`、`SELECT` 的访问频次：

```sql
# session 是查看当前会话;
# global 是查询全局数据;
SHOW GLOBAL STATUS LIKE 'Com_______';
```

上述 `SHOW GLOBAL STATUS` 命令使用 `LIKE 'Com_______'` 模式来匹配以 "Com" 开头，后面跟着 7 个任意字符的状态变量。这允许我们快速检索与命令执行相关的状态信息。

*   `Com_delete`: 删除操作执行的次数。
*   `Com_insert`: 插入操作执行的次数。
*   `Com_select`: 查询操作执行的次数。
*   `Com_update`: 更新操作执行的次数。

通过分析上述指令的输出结果，我们可以了解到当前数据库是以查询为主，还是以增删改为主。这为数据库优化提供了重要的参考依据。

*   **增删改为主：** 如果数据库以增删改操作为主，那么可能不需要过度关注索引优化。
*   **查询为主：** 如果数据库以查询操作为主，那么应该考虑对数据库的索引进行优化，以提高查询性能。

好的，下面是对您提供的课件内容整理的详细笔记。

### 2.5.2 慢查询日志

慢查询日志用于记录执行时间超过指定参数 `long_query_time` (单位：秒，默认 10 秒) 的所有 SQL 语句。默认情况下，MySQL 的慢查询日志是关闭的。

首先，可以通过以下 SQL 语句查看 `slow_query_log` 系统变量的状态：

```sql
SHOW VARIABLES LIKE 'slow_query_log';
```

要开启慢查询日志，需要在 MySQL 配置文件中进行如下配置：

```sql
# 开启 MySQL 慢日志查询开关
slow_query_log=1

# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

配置完成后，需要重启 MySQL 服务器以使配置生效：

```sql
systemctl restart mysqld
```

然后，再次执行 `SHOW VARIABLES LIKE 'slow_query_log';` 确认慢查询日志已开启。

通过分析慢查询日志，可以定位执行效率低的 SQL 语句，并有针对性地进行优化。

### 2.5.3 Profile 详情

`show profiles` 能够帮助我们了解 SQL 优化时的时间消耗情况。通过 `have_profiling` 参数，可以查看当前 MySQL 是否支持 profile 操作：

```sql
SELECT @@have_profiling ;
```

如果 MySQL 支持 profile 操作，但开关是关闭的，可以通过 `SET` 语句在 `session` 或 `global` 级别开启 profiling：

```sql
SET profiling = 1;
```

开启 profiling 后，执行的 SQL 语句都会被 MySQL 记录，并记录执行时间消耗。例如，执行以下 SQL 语句：

```sql
select * from tb_user;
select * from tb_user where id = 1;
select * from tb_user where name = '白起';
select count(*) from tb_sku;
```

然后，通过以下指令查看 SQL 语句的执行耗时情况：

```sql
-- 查看每一条SQL的耗时基本情况
show profiles;

-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

`show profiles;` 可以查看每一条 SQL 语句的耗时基本情况。`show profile for query query_id;` 可以查看指定 SQL 语句在各个阶段的耗时情况，从而更详细地了解性能瓶颈所在。

### 2.5.4 Explain

`EXPLAIN` 或 `DESC` 命令可以获取 MySQL 如何执行 `SELECT` 语句的信息，包括表连接方式和连接顺序。

```sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

`Explain` 执行计划中各个字段的含义如下表所示：

| 字段             | 含义                                                                                                                                             |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`           | `SELECT` 查询的序列号，表示查询中执行 `SELECT` 子句或者是操作表的顺序 (`id` 相同，执行顺序从上到下；`id` 不同，值越大，越先执行)。                                                              |
| `select_type`  | 表示 `SELECT` 的类型，常见的取值有 `SIMPLE` (简单表，即不使用表连接或者子查询)、`PRIMARY` (主查询，即外层的查询)、`UNION` (UNION 中的第二个或者后面的查询语句)、`SUBQUERY` (SELECT/WHERE 之后包含了子查询) 等。 |
| `type`         | 表示连接类型，性能由好到差的连接类型为 `NULL`、`system`、`const`、`eq_ref`、ref、`range`、`index`、`all`。                                                                |
| `possible_key` | 显示可能应用在这张表上的索引，一个或多个。                                                                                                                          |
| `key`          | 实际使用的索引，如果为 `NULL`，则没有使用索引。                                                                                                                    |
| `key_len`      | 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。                                                                                         |
| `rows`         | MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，可能并不总是准确的。                                                                                            |
| `filtered`     | 表示返回结果的行数占需读取行数的百分比，`filtered` 的值越大越好。                                                                                                         |

通过 `EXPLAIN` 命令，可以分析 SQL 语句的执行计划，从而判断 SQL 语句的性能瓶颈，并进行优化。例如，查看是否使用了索引，连接类型是否高效等。

好的，根据您提供的课件内容，我将为您整理出一份详细的笔记。

## 2.6 索引使用

## 2.6.1 验证索引效率

本节通过实例验证索引在提升数据查询性能方面的作用。以包含 1000 万条记录的 `tb_sku` 表为例，分别在无索引和有索引的情况下，针对不同字段进行查询，对比查询效率。

首先，通过以下 SQL 语句查询 `tb_sku` 表中的记录总数：

```sql
mysql> SELECT COUNT(*) FROM tb_sku;
+----------+
| COUNT(*) |
+----------+
| 10000000 |
+----------+
1 row in set (7.05 sec)
```

查询结果显示 `tb_sku` 表包含 1000 万条记录，耗时 7.05 秒。

由于 `id` 字段为主键，已经自动创建了主键索引，因此查询 `id = 1` 的记录速度很快，查询语句如下：

```sql
mysql> SELECT * FROM tb_sku WHERE id = 1;
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
| id | sn              | name      | price | num  | alert_num | image                                                                                                                 | images                                                                                                                | weight | create_time         | update_time         | category_name | brand_name | spec  | sale_num | comment_num | status |
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
|  1 | 100000003145001 | 华为Meta1 | 87901 | 9961 |       100 | https://m.360buyimg.com/mobilecms/s720x720_jfs/t5590/64/5811657380/234462/5398e856/5965e173N34179777.jpg!q70.jpg.webp | https://m.360buyimg.com/mobilecms/s720x720_jfs/t5590/64/5811657380/234462/5398e856/5965e173N34179777.jpg!q70.jpg.webp |     10 | 2019-05-01 00:00:00 | 2019-05-01 00:00:00 | 真皮包        | viney      | 白色1 |       39 |           0 | 1      |
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
1 row in set (0.00 sec)
```

接下来，我们根据 `sn` 字段进行查询，`sn` 字段最初是没有索引的，查询语句如下：

```sql
mysql> SELECT * FROM tb_sku WHERE sn = '100000003145001';
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
| id | sn              | name      | price | num  | alert_num | image                                                                                                                 | images                                                                                                                | weight | create_time         | update_time         | category_name | brand_name | spec  | sale_num | comment_num | status |
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
|  1 | 100000003145001 | 华为Meta1 | 87901 | 9961 |       100 | https://m.360buyimg.com/mobilecms/s720x720_jfs/t5590/64/5811657380/234462/5398e856/5965e173N34179777.jpg!q70.jpg.webp | https://m.360buyimg.com/mobilecms/s720x720_jfs/t5590/64/5811657380/234462/5398e856/5965e173N34179777.jpg!q70.jpg.webp |     10 | 2019-05-01 00:00:00 | 2019-05-01 00:00:00 | 真皮包        | viney      | 白色1 |       39 |           0 | 1      |
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
1 row in set (39.96 sec)
```

查询耗时 39.96 秒，效率较低。

为了提升查询效率，我们为 `sn` 字段创建一个索引，SQL 语句如下：

```sql
mysql> CREATE INDEX idx_sku_sn ON tb_sku (sn);
Query OK, 0 rows affected (1 min 6.77 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

创建索引耗时 1 分 6.77 秒。

创建索引后，再次执行相同的 SQL 语句：

```sql
mysql> SELECT * FROM tb_sku WHERE sn = '100000003145001';
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
| id | sn              | name      | price | num  | alert_num | image                                                                                                                 | images                                                                                                                | weight | create_time         | update_time         | category_name | brand_name | spec  | sale_num | comment_num | status |
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
|  1 | 100000003145001 | 华为Meta1 | 87901 | 9961 |       100 | https://m.360buyimg.com/mobilecms/s720x720_jfs/t5590/64/5811657380/234462/5398e856/5965e173N34179777.jpg!q70.jpg.webp | https://m.360buyimg.com/mobilecms/s720x720_jfs/t5590/64/5811657380/234462/5398e856/5965e173N34179777.jpg!q70.jpg.webp |     10 | 2019-05-01 00:00:00 | 2019-05-01 00:00:00 | 真皮包        | viney      | 白色1 |       39 |           0 | 1      |
+----+-----------------+-----------+-------+------+-----------+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------+--------+---------------------+---------------------+---------------+------------+-------+----------+-------------+--------+
1 row in set (0.00 sec)
```

此时查询耗时仅 0.00 秒，性能得到了显著提升。

通过以上实验可以得出结论：为经常用于查询的字段建立索引，可以显著提升查询性能。在建立索引前后，查询耗时不在一个数量级，充分体现了索引的重要性。

### 2.6.2 最左前缀法则

如果索引了多个列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效（后面的字段索引失效）。

为了演示最左前缀法则，我们以 `tb_user` 表为例。首先，查看 `tb_user` 表已创建的索引。代码如下：

```sql
SHOW INDEX FROM tb_user;
```

查询结果展示了 `tb_user` 表的索引信息，包括索引名、索引类型、索引包含的列等。其中，`idx_user_pro_age_sta` 是一个联合索引，涉及三个字段，顺序分别为 `profession`、`age` 和 `status`。

最左前缀法则指的是，查询时必须存在联合索引最左边的列，也就是 `profession` 字段，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。

下面，我们通过几组案例来演示具体的执行计划。

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = '0';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 54，表示索引全部生效。`Extra` 列显示 `Using index condition`，表示使用了索引下推。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age = 31;
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 49，表示索引部分生效。`Extra` 列显示 `NULL`。

案例 3：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 47，表示索引部分生效。`Extra` 列显示 `NULL`。

通过以上三组测试，我们发现只要联合索引最左边的字段 `profession` 存在，索引就会生效，只不过索引的长度不同。而且由以上三组测试，我们也可以推测出 `profession` 字段索引长度为 47、`age` 字段索引长度为 2、`status` 字段索引长度为 5。

案例 4：

```sql
EXPLAIN SELECT * FROM tb_user WHERE age = 31 AND status = '0';
```

执行计划显示，该查询没有使用任何索引，`key` 为 `NULL`，`key_len` 为 `NULL`。`Extra` 列显示 `Using where`，表示通过 `WHERE` 条件进行过滤。

案例 5：

```sql
EXPLAIN SELECT * FROM tb_user WHERE status = '0';
```

执行计划显示，该查询没有使用任何索引，`key` 为 `NULL`，`key_len` 为 `NULL`。`Extra` 列显示 `Using where`，表示通过 `WHERE` 条件进行过滤。

通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列 `profession` 不存在。

案例 6：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND status = '0';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 47。`Extra` 列显示 `Using index condition`。

上述的 SQL 查询时，存在 `profession` 字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了 `age` 这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是 47。

思考题：

当执行 SQL 语句：`EXPLAIN SELECT * FROM tb_user WHERE age = 31 AND status = '0' AND profession = '软件工程';` 时，是否满足最左前缀法则，走不走上述的联合索引，索引长度？

```sql
EXPLAIN SELECT * FROM tb_user WHERE age = 31 AND status = '0' AND profession = '软件工程';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 54。`Extra` 列显示 `Using index condition`。

可以看到，是完全满足最左前缀法则的，索引长度 54，联合索引是生效的。

注意： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段（即是第一个字段）必须存在，与我们编写 SQL 时，条件编写的先后顺序无关。

### 2.6.3 范围查询

联合索引中，出现范围查询（`>`，`<`），范围查询右侧的列索引失效。

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age > 30 AND status = '0';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 49。`Extra` 列显示 `Using index condition`。

当范围查询使用 `>` 或 `<` 时，走联合索引了，但是索引的长度为 49，就说明范围查询右边的 `status` 字段是没有走索引的。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age >= 30 AND status = '0';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 54。`Extra` 列显示 `Using index condition`。

当范围查询使用 `>=` 或 `<=` 时，走联合索引了，但是索引的长度为 54，就说明所有的字段都是走索引的。

所以，在业务允许的情况下，尽可能的使用类似于 `>=` 或 `<=` 这类的范围查询，而避免使用 `>` 或 `<`。

### 2.6.4 索引失效情况

#### 2.6.4.1 索引列运算

不要在索引列上进行运算操作，索引将失效。

在 `tb_user` 表中，除了前面介绍的联合索引之外，还有一个索引，是 `phone` 字段的单列索引。

首先，我们查看 `tb_user` 表的索引信息。代码如下：

```sql
SHOW INDEX FROM tb_user;
```

查询结果展示了 `tb_user` 表的索引信息，包括索引名、索引类型、索引包含的列等。

案例 A：当根据 `phone` 字段进行等值匹配查询时，索引生效。

```sql
EXPLAIN SELECT * FROM tb_user WHERE phone = '17799990015';
```

执行计划显示，该查询使用了 `idx_user_phone` 索引，`key_len` 为 46。`Extra` 列显示 `NULL`。

案例 B：当根据 `phone` 字段进行函数运算操作之后，索引失效。

```sql
EXPLAIN SELECT * FROM tb_user WHERE SUBSTRING(phone, 10, 2) = '15';
```

执行计划显示，该查询没有使用任何索引，`key` 为 `NULL`。`Extra` 列显示 `Using where`。

#### 2.6.4.2 字符串不加引号

字符串类型字段使用时，不加引号，索引将失效。

接下来，我们通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别。

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = '0';
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = 0;
```

执行计划显示，第一条 SQL 语句使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 54。第二条 SQL 语句使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 49。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE phone = '17799990015';
EXPLAIN SELECT * FROM tb_user WHERE phone = 17799990015;
```

执行计划显示，第一条 SQL 语句使用了 `idx_user_phone` 索引，`key_len` 为 46。第二条 SQL 语句没有使用任何索引。

经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效。

#### 2.6.4.3 模糊查询

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

接下来，我们来看一下这三条 SQL 语句的执行效果，查看一下其执行计划：

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession LIKE '软件%';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引，`key_len` 为 47。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession LIKE '%工程';
```

执行计划显示，该查询没有使用任何索引。

案例 3：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession LIKE '%%';
```

执行计划显示，该查询没有使用任何索引。

经过上述的测试，我们发现，在 `LIKE` 模糊查询中，在关键字后面加 `%`，索引可以生效。而如果在关键字前面加了 `%`，索引将会失效。

#### 2.6.4.4 OR 连接条件

用 `OR` 分割开的条件，如果 `OR` 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE id = 10 OR age = 23;
```

执行计划显示，该查询没有使用任何索引。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE phone = '17799990017' OR age = 23;
```

执行计划显示，该查询没有使用任何索引。

由于 `age` 没有索引，所以即使 `id`、`phone` 有索引，索引也会失效。所以需要针对于 `age` 也要建立索引。

然后，我们可以对 `age` 字段建立索引。代码如下：

```sql
CREATE INDEX idx_user_age ON tb_user(age);
```

建立了索引之后，我们再次执行上述的 SQL 语句，看看前后执行计划的变化。

案例 1（建立 `age` 索引后）：

```sql
EXPLAIN SELECT * FROM tb_user WHERE id = 10 OR age = 23;
```

执行计划显示，该查询使用了 `PRIMARY` 索引和 `idx_user_age` 索引。

案例 2（建立 `age` 索引后）：

```sql
EXPLAIN SELECT * FROM tb_user WHERE phone = '17799990017' OR age = 23;
```

执行计划显示，该查询使用了 `idx_user_phone` 索引和 `idx_user_age` 索引。

最终，我们发现，当 `OR` 连接的条件，左右两侧字段都有索引时，索引才会生效。

#### 2.6.4.5 数据分布影响

如果 MySQL 评估使用索引比全表更慢，则不使用索引。

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE phone >= '17799990005';
```

执行计划显示，该查询没有使用任何索引。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE phone >= '17799990015';
```

执行计划显示，该查询使用了 `idx_user_phone` 索引。

经过测试我们发现，相同的 SQL 语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？

就是因为 MySQL 在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。

接下来，我们再来看看 `IS NULL` 与 `IS NOT NULL` 操作是否走索引。

执行如下两条语句：

案例 1：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession IS NULL;
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引。

案例 2：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession IS NOT NULL;
```

执行计划显示，该查询没有使用任何索引。

接下来，我们做一个操作将 `profession` 字段值全部更新为 `NULL`。代码如下：

```sql
UPDATE tb_user SET profession = NULL;
```

然后，再次执行上述的两条 SQL，查看 SQL 语句的执行计划。

案例 1（更新 `profession` 为 `NULL` 后）：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession IS NULL;
```

执行计划显示，该查询没有使用任何索引。

案例 2（更新 `profession` 为 `NULL` 后）：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession IS NOT NULL;
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引。

最终我们看到，一模一样的 SQL 语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时 MySQL 会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。因此，`IS NULL`、`IS NOT NULL` 是否走索引，得具体情况具体分析，并不是固定的。

### 2.6.5 SQL 提示

SQL 提示，是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。

我们先看一下目前 `tb_user` 表的数据情况和索引情况。

目前 `tb_user` 表的数据情况：

（这里展示了 `tb_user` 表的部分数据，包括 `id`、`name`、`phone`、`email`、`profession`、`age`、`gender`、`status` 和 `createtime` 等字段。）

索引情况如下：

```sql
SHOW INDEX FROM tb_user;
```

（这里展示了 `tb_user` 表的索引信息，包括索引名、索引类型、索引包含的列等。）

把上述的 `idx_user_age`、`idx_email` 这两个之前测试使用过的索引直接删除。代码如下：

```sql
DROP INDEX idx_user_age ON tb_user;
DROP INDEX idx_email ON tb_user;
```

案例 A：执行 SQL：

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程';
```

执行计划显示，查询走了联合索引 `idx_user_pro_age_sta`。

案例 B：执行 SQL，创建 `profession` 的单列索引：

```sql
CREATE INDEX idx_user_pro ON tb_user(profession);
```

案例 C：创建单列索引后，再次执行 A 中的 SQL 语句，查看执行计划，看看到底走哪个索引。

```sql
EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程';
```

测试结果，我们可以看到，`possible_keys` 中 `idx_user_pro_age_sta`、`idx_user_pro` 这两个索引都可能用到，最终 MySQL 选择了 `idx_user_pro_age_sta` 索引。这是 MySQL 自动选择的结果。

那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 MySQL 的 SQL 提示来完成。接下来，介绍一下 SQL 提示。

SQL 提示：

1.  `USE INDEX`： 建议 MySQL 使用哪一个索引完成此次查询（仅仅是建议，MySQL 内部还会再次进行评估）。

    ```sql
    EXPLAIN SELECT * FROM tb_user USE INDEX (idx_user_pro) WHERE profession = '软件工程';
    ```
2.  `IGNORE INDEX`： 忽略指定的索引。

    ```sql
    EXPLAIN SELECT * FROM tb_user IGNORE INDEX (idx_user_pro) WHERE profession = '软件工程';
    ```
3.  `FORCE INDEX`： 强制使用索引。

    ```sql
    EXPLAIN SELECT * FROM tb_user FORCE INDEX (idx_user_pro) WHERE profession = '软件工程';
    ```

示例演示：

A. `USE INDEX`

```sql
EXPLAIN SELECT * FROM tb_user USE INDEX(idx_user_pro) WHERE profession = '软件工程';
```

执行计划显示，该查询使用了 `idx_user_pro` 索引。

B. `IGNORE INDEX`

```sql
EXPLAIN SELECT * FROM tb_user IGNORE INDEX(idx_user_pro) WHERE profession = '软件工程';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引。

C. `FORCE INDEX`

```sql
EXPLAIN SELECT * FROM tb_user FORCE INDEX(idx_user_pro_age_sta) WHERE profession = '软件工程';
```

执行计划显示，该查询使用了 `idx_user_pro_age_sta` 索引。

### 2.6.6 覆盖索引

尽量使用覆盖索引，减少 `SELECT *`。 那么什么是覆盖索引呢？ 覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。

接下来，我们来看一组 SQL 的执行计划，看看执行计划的差别，然后再来具体做一个解析。

1.  `EXPLAIN SELECT id, profession FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = '0';`
2.  `EXPLAIN SELECT id, profession, age, status FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = '0';`
3.  `EXPLAIN SELECT id, profession, age, status, name FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = '0';`
4.  `EXPLAIN SELECT * FROM tb_user WHERE profession = '软件工程' AND age = 31 AND status = '0';`

上述这几条 SQL 的执行结果为：

（这里展示了上述四条 SQL 语句的执行计划，包括 `id`、`select_type`、`table`、`partitions`、`type`、`possible_keys`、`key`、`key_len`、`ref`、`rows`、`filtered` 和 `Extra` 等列。）

从上述的执行计划我们可以看到，这四条 SQL 语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的 `Extra`，前面两天 SQL 的结果为 `Using where; Using index`；而后面两条 SQL 的结果为：`Using index condition`。

| Extra                   | 含义                                                         |
| :---------------------- | :----------------------------------------------------------- |
| Using where; Using Index | 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 |
| Using index condition   | 查找使用了索引，但是需要回表查询数据                         |

因为，在 `tb_user` 表中有一个联合索引 `idx_user_pro_age_sta`，该索引关联了三个字段 `profession`、`age`、`status`，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键 `id`。所以当我们查询返回的数据在 `id`、`profession`、`age`、`status` 之中，则直接走二级索引直接返回数据了。如果超出这个范围，就需要拿到主键 `id`，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。而我们如果一直使用 `SELECT *` 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。

为了大家更清楚的理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组 SQL 的执行过程。

A. 表结构及索引示意图：

（这里展示了 `tb_user` 表的结构和索引示意图。`id` 是主键，是一个聚集索引。`name` 字段建立了普通索引，是一个二级索引（辅助索引）。）

B. 执行 SQL：`SELECT * FROM tb_user WHERE id = 2;`

根据 `id` 查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。

C. 执行 SQL：`SELECT id, name FROM tb_user WHERE name = 'Arm';`

虽然是根据 `name` 字段查询，查询二级索引，但是由于查询返回的字段为 `id`、`name`，在 `name` 的二级索引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。

D. 执行 SQL：`SELECT id, name, gender FROM tb_user WHERE name = 'Arm';`

由于在 `name` 的二级索引中，不包含 `gender`，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。

思考题：

一张表，有四个字段（`id`、`username`、`password`、`status`），由于数据量大，需要对以下 SQL 语句进行优化，该如何进行才是最优方案：

```sql
SELECT id, username, password FROM tb_user WHERE username = 'itcast';
```

答案：针对于 `username`、`password` 建立联合索引，SQL 为：`CREATE INDEX idx_user_name_pass ON tb_user(username, password);`

这样可以避免上述的 SQL 语句，在查询的过程中，出现回表查询。

### 2.6.7 前缀索引

当字段类型为字符串（`VARCHAR`、`TEXT`、`LONGTEXT` 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 I/O，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

1). 语法

```sql
CREATE INDEX idx_xxxx ON table_name(column(n));
```

示例：

为 `tb_user` 表的 `email` 字段，建立长度为 5 的前缀索引。

```sql
CREATE INDEX idx_email_5 ON tb_user(email(5));
```

此时查看索引信息：

```sql
SHOW INDEX FROM tb_user;
```

2). 前缀长度

可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。

```sql
SELECT COUNT(DISTINCT email) / COUNT(*) FROM tb_user;
SELECT COUNT(DISTINCT SUBSTRING(email, 1, 5)) / COUNT(*) FROM tb_user;
```

3). 前缀索引的查询流程

（这里展示了前缀索引的查询流程示意图。）

### 2.6.8 单列索引与联合索引

单列索引：即一个索引只包含单个列。

联合索引：即一个索引包含了多个列。

我们先来看看 `tb_user` 表中目前的索引情况：

```sql
SHOW INDEX FROM tb_user;
```

在查询出来的索引中，既有单列索引，又有联合索引。

接下来，我们来执行一条 SQL 语句，看看其执行计划：

```sql
EXPLAIN SELECT id, phone, name FROM tb_user WHERE phone = '17799990010' AND name = '韩信';
```

通过上述执行计划我们可以看出来，在 `AND` 连接的两个字段 `phone`、`name` 上都是有单列索引的，但是最终 MySQL 只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。

紧接着，我们再来创建一个 `phone` 和 `name` 字段的联合索引来查询一下执行计划。

```sql
CREATE UNIQUE INDEX idx_user_phone_name ON tb_user(phone, name);
```

```sql
EXPLAIN SELECT id, phone, name FROM tb_user USE INDEX (idx_user_phone_name) WHERE phone = '17799990010' AND name = '韩信';
```

此时，查询时，就走了联合索引，而在联合索引中包含 `phone`、`name` 的信息，在叶子节点下挂的是对应的主键 `id`，所以查询是无需回表查询的。

在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。

如果查询使用的是联合索引，具体的结构示意图如下：

（这里展示了联合索引的结构示意图。）

## 2.7 索引设计原则

1). 针对于数据量较大，且查询比较频繁的表建立索引。

2). 针对于常作为查询条件（`WHERE`）、排序（`ORDER BY`）、分组（`GROUP BY`）操作的字段建立索引。

3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。

5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。

6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。

7). 如果索引列不能存储 `NULL` 值，请在创建表时使用 `NOT NULL` 约束它。当优化器知道每列是否包含 `NULL` 值时，它可以更好地确定哪个索引最有效地用于查询。

希望这份笔记对您有所帮助！