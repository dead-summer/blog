---
title: 5.多表查询
createTime: 2025/07/28 16:55:33
permalink: /article/yq0fg2ft/
---
## 5.1 多表关系

在项目开发中，数据库表结构的设计会依据业务需求和业务模块之间的关系进行。由于业务之间存在关联，因此各个表结构之间也存在着各种联系，主要分为三种：

* 一对多 (多对一)
* 多对多
* 一对一

### 5.1.1 一对多

*   **案例**：部门与员工的关系。
*   **关系**：一个部门对应多个员工，一个员工对应一个部门。
*   **实现**：在“多”的一方建立外键，指向“一”的一方的主键。

![[5.多表查询_附件/5.多表查询-20250728165928064.png]]

### 5.1.2 多对多

*   **案例**：学生与课程的关系。
*   **关系**：一个学生可以选择多门课程，一门课程也可以被多个学生选择。
*   **实现**：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键。

![[5.多表查询_附件/5.多表查询-20250728165943125.png]]

下面是创建这三个表的 SQL 脚本，以及插入数据的语句：

```sql
create table student (
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    no varchar(10) comment '学号'
) comment '学生表';

insert into student values (null, '黛绮丝','2000100101'), (null, '谢逊',
'2000100102'), (null, '殷天正', '2000100103'), (null, '韦一笑', '2000100104');

create table course (
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '课程名称'
) comment '课程表';

insert into course values (null, 'Java'), (null, 'PHP'), (null, 'MySQL'),
(null, 'Hadoop');

create table student_course(
    id int auto_increment comment '主键' primary key,
    studentid int not null comment '学生ID',
    courseid int not null comment '课程ID',
    constraint fk_courseid foreign key (courseid) references course (id),
    constraint fk_studentid foreign key (studentid) references student (id)
) comment '学生课程中间表';

insert into student_course values (null,1,1), (null,1,2), (null,1,3), (null,2,2),
(null,2,3), (null,3,4);
```

### 5.1.3 一对一

*   **案例**：用户与用户详情的关系。
*   **关系**：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率。
*   **实现**：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的 (UNIQUE)。

![[5.多表查询_附件/5.多表查询-20250728170037957.png]]

下面是创建这两个表的 SQL 脚本，以及插入数据的语句：

```sql
create table tb_user(
    id int auto_increment primary key comment '主键ID',
    name varchar(10) comment '姓名',
    age int comment '年龄',
    gender char(1) comment '1:男,2:女',
    phone char (11) comment '手机号'
) comment '用户基本信息表';

create table tb_user_edu(
    id int auto_increment primary key comment '主键ID',
    degree varchar(20) comment '学历',
    major varchar(50) comment '专业',
    primaryschool varchar(50) comment '小学',
    middleschool varchar(50) comment '中学',
    university varchar(50) comment '大学',
    userid int unique comment '用户ID',
    constraint fk_userid foreign key (userid) references tb_user(id)
) comment '用户教育信息表';

insert into tb_user(id, name, age, gender, phone) values
(null,'黄渤',45,'1','18800001111'),
(null,'冰冰',35,'2','18800002222'),
(null, '码云', 55, '1', '18800008888'),
(null, '李彦宏',50,'1','18800009999');

insert into tb_user_edu(id, degree, major, primaryschool, middleschool,
university, userid) values
(null,'本科','舞蹈','静安区第一小学','静安区第一中学','北京舞蹈学院',1),
(null,'硕士','表演','朝阳区第一小学','朝阳区第一中学','北京电影学院',2),
(null,'本科','英语','杭州市第一小学','杭州市第一中学','杭州师范大学',3),
(null, '本科','应用数学','阳泉第一小学','阳泉区第一中学','清华大学',4);
```

## 5.2 多表查询概述

多表查询就是指从多张表中查询数据。

#### 5.2.1 数据准备

执行如下脚本，创建 `emp` 表与 `dept` 表并插入测试数据。

```sql
-- 创建dept表,并插入数据
create table dept(
    id int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '部门名称'
) comment '部门表';
INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3,'财务部'), (4,'销售部'), (5, '总经办'), (6, '人事部');

-- 创建emp表,并插入数据
create table emp (
    id int auto_increment comment 'ID' primary key,
    name varchar(50) not null comment '姓名',
    age int comment '年龄',
    job varchar(20) comment '职位',
    salary int comment '薪资',
    entrydate date comment '入职时间',
    managerid int comment '直属领导ID',
    dept_id int comment '部门ID'
) comment '员工表';

-- 添加外键
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references
dept(id);

INSERT INTO emp (id, name, age, job, salary, entrydate, managerid, dept_id)
VALUES
(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),
(2, '张无忌',20,'项目经理',12500,'2005-12-05', 1,1),
(3, '杨逍', 33, '开发', 8400, '2000-11-03', 2,1),
(4,'韦一笑', 48, '开发',11000, '2002-02-05', 2,1),
(5,'常遇春', 43, '开发',10500, '2004-09-07', 3,1),
(6, '小昭', 19,'程序员鼓励师',6600, '2004-10-12', 2,1),
(7,'灭绝', 60,'财务总监',8500, '2002-09-12', 1,3),
(8,'周芷若', 19, '会计',48000, '2006-06-02', 7,3),
(9,'丁敏君',23,'出纳',5250, '2009-05-13', 7,3),
(10,'赵敏',20,'市场部总监',12500, '2004-10-12', 1,2),
(11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),
(12,'鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),
(13,'方东白', 19, '职员',5500, '2009-02-12', 10,2),
(14,'张三丰',88,'销售总监',14000, '2004-10-12', 1,4),
(15,'俞莲舟',38,'销售',4600, '2004-10-12', 14,4),
(16,'宋远桥',40,'销售',4600, '2004-10-12', 14,4),
(17,'陈友谅', 42, null,2000, '2011-10-12', 1,null);
```

### 5.2.2 概述

如果要执行多表查询，只需要使用逗号分隔多张表即可，例如：`SELECT * FROM emp, dept;`。

然而，直接这样查询会产生笛卡尔积，即结果集中包含了大量的结果集，总记录数为两个表记录数的乘积。以上述 `emp` 表和 `dept` 表为例，查询结果会包含 102 条记录，即 `emp` 表所有记录 (17) 与 `dept` 表所有记录 (6) 的所有组合情况。

为了消除无效的笛卡尔积，只保留两张表关联部分的数据，我们需要给多表查询加上连接查询的条件。

例如，可以使用以下 SQL 语句来消除无效的笛卡尔积：

```sql
SELECT * FROM emp, dept WHERE emp.dept_id = dept.id;
```

由于 `emp` 表中 `id` 为 17 的员工，其 `dept_id` 字段值为 `NULL`，所以在多表查询时，根据连接查询的条件，这条记录不会被查询到。

### 5.2.3 分类

*   **连接查询**
    *   **内连接**：查询两张表交集部分数据。
    *   **外连接**：
        *   **左外连接**：查询左表所有数据，以及两张表交集部分数据。
        *   **右外连接**：查询右表所有数据，以及两张表交集部分数据。
    *   **自连接**：当前表与自身的连接查询，自连接必须使用表别名。
*   **子查询**

## 5.3 内连接

内连接查询的是两张表交集部分的数据（也就是绿色部分的数据）。

![[5.多表查询_附件/5.多表查询-20250728170853480.png]]

内连接的语法分为两种：隐式内连接、显式内连接。

1.  隐式内连接

    ```sql
    SELECT 字段列表 FROM 表1, 表2 WHERE 条件...;
    ```
2.  显式内连接

    ```sql
    SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件...;
    ```

**案例：**

::: example 查询每一个员工的姓名，及关联的部门的名称（隐式内连接实现）

```sql
select e.name, d.name from emp e, dept d where e.dept_id = d.id;
```

:::

::: example 查询每一个员工的姓名，及关联的部门的名称（显式内连接实现）

```sql
select e.name, d.name from emp e join dept d on e.dept_id = d.id;
```

:::

::: caution 

一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。

:::

## 5.4 外连接

外连接分为两种，分别是：左外连接和右外连接。具体的语法结构为：

![[5.多表查询_附件/5.多表查询-20250728171257165.png]]

1.  左外连接

    ```sql
    SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...;
    ```

    左外连接相当于查询左表的所有数据，当然也包含左表和右表交集部分的数据。

2.  右外连接

    ```sql
    SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...;
    ```

    右外连接相当于查询右表的所有数据，当然也包含左表和右表交集部分的数据。

**案例：**

::: example 查询 `emp` 表的所有数据，和对应的部门信息

由于需求中提到，要查询 `emp` 的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。

```sql
select e.*, d.name from emp e left join dept d on e.dept_id = d.id;
```

:::

::: example 查询 `dept` 表的所有数据，和对应的员工信息

由于需求中提到，要查询 `dept` 表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。

```sql
select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;
```

```sql
select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;
```

:::

::: note 

左外连接和右外连接可以相互替换，只需调整连接查询中表的顺序。而我们在日常开发使用时，更偏向于左外连接。

:::

## 5.5 自连接

#### 5.5.1 自连接查询

自连接查询指的是在同一个表上进行连接查询，即将一张表视为两张表进行关联操作。这在处理具有层级关系的数据时非常常见，比如员工与其领导的关系。

自连接查询的语法结构如下：

```sql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;
```

对于自连接查询，可以是内连接查询，也可以是外连接查询。

**案例：**

::: example 查询员工及其所属领导的名字

```sql
select a.name, b.name from emp a, emp b where a.managerid = b.id;
```

:::

::: example 查询所有员工 `emp` 及其领导的名字 `emp`，如果员工没有领导，也需要查询出来

```sql
select a.name '员工', b.name '领导' from emp a left join emp b on a.managerid = b.id;
```

:::

::: note 

在自连接查询中，为表起别名是至关重要的。因为如果不使用别名，数据库无法区分查询语句中出现的相同表名是指向同一张表的两个不同实例，从而导致查询出错。

:::

### 5.5.2 联合查询

`UNION` 查询用于合并多个查询的结果，形成一个新的结果集。

```sql
SELECT 字段列表 FROM 表A ...
UNION [ALL]
SELECT 字段列表 FROM 表B....;
```

- 进行联合查询的多个表的列数必须一致，字段类型也需要保持一致。
- `UNION ALL` 会将全部的数据直接合并在一起，不去重；`UNION` 会对合并之后的数据进行去重。

**案例：**

::: example 查询薪资低于 5000 或者年龄大于 50 岁的员工

这个需求可以直接使用多条件查询与逻辑运算符 `OR` 连接实现，但这里展示了如何使用 `UNION/UNION ALL` 来联合查询。

```sql
select * from emp where salary < 5000
union all
select * from emp where age > 50;
```

上述 `SQL` 语句使用 `UNION ALL` 将两个查询的结果简单合并，不会去除重复的行。

```sql
select * from emp where salary < 5000
union
select * from emp where age > 50;
```

上述 `SQL` 语句使用 `UNION` 将两个查询的结果合并，并去除重复的行。

:::

::: caution 

如果多条查询语句查询出来的结果，字段数量不一致，在进行 `UNION/UNION ALL` 联合查询时，将会报错。

:::

## 5.6 子查询

### 5.6.1 概述

子查询是指 SQL 语句中嵌套的 `SELECT` 语句，也称为嵌套查询。

```sql
SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);
```

子查询可以出现在 `INSERT`、`UPDATE`、`DELETE` 或 `SELECT` 语句中。

根据子查询结果不同，分为：

- **标量子查询**：返回单个值（如数字、字符串）。
- **列子查询**：返回一列数据（可含多行）。
- **行子查询**：返回一行数据（可含多列）。
- **表子查询**：返回多行多列的完整表结构。

根据子查询位置，分为：

- `WHERE` 之后：用于条件过滤。
- `FROM` 之后：作为临时表参与连接操作。
- `SELECT` 之后：直接在结果集中嵌套值。  

### 5.6.2 标量子查询

标量子查询是指返回结果为单个值的子查询（例如数字、字符串、日期等）。 它是子查询中最简单的形式。常用的操作符包括：`=`、`>`、`>=`、`<`、`<=`。

**案例：**

::: example 查询 " 销售部 " 的所有员工信息

通过两步实现业务逻辑解耦：

1. 获取部门 ID：

	```sql
	SELECT id FROM dept WHERE name = ' 销售部 ';
	```

2. 检索员工信息：
```sql
SELECT * FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = ' 销售部 ');
```

:::

::: example 查询在 " 方东白 " 入职之后的员工信息

1. 获取入职日期：
    
	```sql
	SELECT entrydate FROM emp WHERE name = ' 方东白 ';
	```

2. 检索后续入职员工：
	```sql
	SELECT * FROM emp WHERE entrydate > (SELECT entrydate FROM emp WHERE name = ' 方东白 ');
	```

:::

### 5.6.3 列子查询

列子查询是指子查询返回一列数据（包含多行结果），用于匹配一组值的查询场景。常用操作符包括：

| 操作符   | 描述                                 |
| :------- | :----------------------------------- |
| IN       | 在指定的集合范围之内，多选一         |
| NOT IN   | 不在指定的集合范围之内               |
| ANY      | 子查询返回列表中，有任意一个满足即可 |
| SOME     | 与 ANY 等同，使用 SOME 的地方都可以使用 ANY |
| ALL      | 子查询返回列表的所有值都必须满足     |

**案例：**

::: example 查询 " 销售部 " 和 " 市场部 " 的所有员工信息

利用 `IN` 操作符处理多部门 ID 集合。

1. 获取部门 ID 列表：
    
	```sql
	SELECT id FROM dept WHERE name = '销售部' OR name = '市场部';
	```

2. 检索员工信息：
	```sql
	SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE name = ' 销售部 ' OR name = ' 市场部 ');
	```

:::

::: example 查询工资高于财务部所有人的员工信息

嵌套查询与 `ALL` 操作符实现工资比较。

1. 检索财务部工资数据：
    
	```sql
	SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = ' 财务部 ');
	```

2. 比较工资并查询员工：
	```sql
	SELECT * FROM emp WHERE salary > ALL ( SELECT salary FROM emp 
	                                        WHERE dept_id = (SELECT id FROM dept WHERE name = '财务部'));
	```

:::

::: example 查询工资高于研发部任一员工的员工信息

`ANY` 操作符实现部分匹配检索。

1. 获取研发部工资数据：
    
	```sql
	SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部');
	```

2. 检索员工信息：
    
	```sql
	SELECT * FROM emp WHERE salary > ANY ( SELECT salary FROM emp 
	                                        WHERE dept_id = (SELECT id FROM dept WHERE name = '研发部'));
	```

:::

### 5.6.4 行子查询

行子查询是指子查询返回一行数据（包含多列），适合同时比较多个字段的场景。常用操作符包括等于 (`=`)、不等于 (`<>`)、`IN` 和 `NOT IN`，其中 `=` 需整行精确匹配。

**案例：**

::: example 查询与 " 张无忌 " 的薪资及直属领导相同的员工信息

  1. 获取基准员工数据：  
     ```sql
     SELECT salary, managerid FROM emp WHERE name = '张无忌';
     ```  

  2. 查询匹配员工：  
     ```sql
     SELECT * FROM emp WHERE (salary, managerid) = (SELECT salary, managerid FROM emp WHERE name = '张无忌');
     ```  

:::

### 5.6.5 表子查询

表子查询是指子查询返回完整临时表（多行多列）。常用于 `IN` 操作符或 `FROM` 从句的临时数据源，支持连接操作或复杂筛选。  

**案例：**

::: example 查询与 " 鹿杖客 "，" 宋远桥 " 的职位和薪资相同的员工信息

利用 `IN` 和值对筛选多变量条件：

  1. 获取职级数据：  
     ```sql
     SELECT job, salary FROM emp WHERE name = '鹿杖客' OR name = '宋远桥';
     ```  

  2. 检索匹配员工：  
     ```sql
     SELECT * FROM emp WHERE (job, salary) IN (SELECT job, salary FROM emp 
                                            WHERE name = '鹿杖客' OR name = '宋远桥');
     ```  

:::

::: example 查询入职日期是 "2006-01-01" 之后的员工信息，及其部门信息

在 `FROM` 从句中使用子查询创建临时表以支持连接操作。  

  1. 过滤员工记录：  
     ```sql
     SELECT * FROM emp WHERE entrydate > '2006-01-01';
     ```  
  2. 连接部门数据：  
     ```sql
     SELECT e.*, d.* FROM (SELECT * FROM emp WHERE entrydate > '2006-01-01') e
                    LEFT JOIN dept d ON e.dept_id = d.id;
     ```  

:::
