---
title: 反射
createTime: 2025/09/04 15:01:26
permalink: /notes/interview/7ci0telb/
---
反射 (Reflection) 机制允许程序在 **运行时** 动态地检查、修改或调用类、方法、属性、构造函数等代码结构的信息。它打破了传统“编译时绑定”的限制，使得程序能够适配未知或变化的类型，从而增加了程序的灵活性和通用性。

## 核心概念

反射的核心在于能够在程序运行时获取并操作类型信息。这意味着，对于一个编译时无法确定的对象，程序仍然可以通过反射来：

* **获取类信息：** 获取类的名称、父类、实现的接口等。
* **获取构造函数：** 动态创建对象实例。
* **获取方法：** 动态调用对象或类的特定方法。
* **获取字段：** 动态读取或修改对象的字段值，包括私有字段。
* **获取注解：** 读取类、方法、字段上的注解信息。

## 使用场景

反射机制常见于以下场景：

* **框架开发：**
    * **依赖注入 (Dependency Injection, DI)：** Spring 等框架利用反射动态地创建对象实例，并将其依赖注入到相应的字段或构造函数中。
    * **面向切面编程 (Aspect-Oriented Programming, AOP)：** AOP 框架（如 Spring AOP）通过动态代理（通常基于反射）在不修改原有代码的情况下，为方法添加额外的行为（如日志、事务管理）。
* **动态加载类：** 在插件化架构或热部署场景中，程序可以通过反射动态加载外部的类文件，并在运行时使用这些类。
* **序列化/反序列化：** JSON 库（如 Jackson、Gson）或 ORM 框架（如 Hibernate）利用反射将对象转换为字符串（序列化）或将字符串转换为对象（反序列化），而无需预先知道对象的具体类型。
* **测试工具：** JUnit 等测试框架利用反射动态地发现并调用测试类中的测试方法。

## 优缺点

- **优点**
	* **灵活性和通用性：** 允许编写与特定类型解耦的代码，提高了程序的通用性和可扩展性。
	* **动态性：** 能够在运行时获取和操作类型信息，适应复杂和变化的需求。

- **缺点**
	* **性能开销：** 反射操作通常比直接调用代码慢，因为它涉及到运行时解析、类型检查和方法查找等额外步骤。在性能敏感的场景中应谨慎使用。
	* **安全风险：** 反射可以访问和修改类的私有成员，可能破坏对象的封装性，暴露内部实现细节，从而增加潜在的安全风险。
	* **维护困难：** 反射代码通常可读性较差，调试复杂，因为编译器无法在编译时进行类型检查。这可能导致运行时错误，增加了维护成本。
	* **编译器优化受限：** 由于反射的动态性，编译器难以进行有效的优化，可能会影响 JIT (Just-In-Time) 编译器的性能。

