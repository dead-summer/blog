---
title: JVM
createTime: 2025/07/24 22:42:17
permalink: /notes/interview/w6spa56i/
---
## 内存管理与故障排查

### JVM 在哪些情况下会将对象移入老年代？如果发现堆内存增长过快且 GC 无法回收，你会如何排查？

#### 对象进入老年代的几种情况

JVM 的堆内存通常分为年轻代 (Young Generation) 和老年代 (Old Generation)。对象优先在年轻代的 Eden 区分配，在经历多次 Minor GC 后依然存活的对象，会被逐步晋升到老年代。主要有以下几种情况：

1. **长期存活的对象 (年龄判定)**：
    
    - JVM 为每个对象定义了一个年龄计数器。对象在 Eden 区出生，每经过一次 Minor GC 仍然存活，并且能被 Survivor 区容纳，年龄就增加 1。
        
    - 当对象的年龄达到一个阈值（默认为 15，可以通过 `-XX:MaxTenuringThreshold` 参数设置）时，它就会被晋升到老年代。
        
2. **动态对象年龄判定**：
    
    - 如果在 Survivor 空间中，相同年龄的所有对象大小的总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 `MaxTenuringThreshold`。
        
3. **大对象直接进入老年代**：
    
    - 如果一个对象所需内存过大，超过了 Eden 区或单个 Survivor 区的容量，或者超过了 JVM 参数 `-XX:PretenureSizeThreshold` 所设定的阈值，这个大对象会直接在老年代进行分配。
        
    - 这样做是为了避免大对象在年轻代中反复复制，从而降低 GC 的开销。常见的例子是长字符串或大数组。
        
4. **空间分配担保 (Handle Promotion)**：
    
    - 在进行 Minor GC 之前，JVM 会检查老年代连续空间的可用大小是否大于年轻代所有对象的总大小。
        
    - 如果这个条件成立，Minor GC 是安全的。
        
    - 如果不成立，JVM 会查看 `-XX:HandlePromotionFailure` 参数是否允许担保失败。如果允许，JVM 会继续检查老年代连续空间的可用大小是否大于历次晋升到老年代对象的平均大小。
        
    - 如果上述检查都不通过，或者担保失败，JVM 会触发一次 Full GC 来回收老年代和年轻代的空间，然后可能将年轻代的对象移入老年代。

#### 堆内存异常增长排查思路

当发现堆内存增长过快，频繁 GC 但回收效果不佳时，通常意味着存在内存泄漏或内存溢出风险。我会按照以下步骤进行排查：

1. **初步分析与信息收集**：
    
    - **查看 GC 日志**：首先检查应用的 GC 日志。重点关注 Full GC 的频率、耗时以及每次 GC 前后堆内存的回收情况。如果 Full GC 频繁发生，且回收后老年代空间没有明显下降，则基本可以断定存在内存泄漏。
        
    - **使用 `jstat` 命令**：通过 `jstat -gcutil <pid> <interval>` 实时监控堆内存各区域的使用率和 GC 情况。观察 Eden、Survivor、Old Gen 的变化趋势，确定是哪个区域的内存增长异常。
        
2. 生成堆转储快照 (Heap Dump)：

    这是定位问题的关键步骤。当发现问题后，需要获取一份 JVM 在某个时刻的内存快照。可以通过以下几种方式获取：

    - **`jmap` 命令**：使用 `jmap -dump:format=b,file=heapdump.hprof <pid>` 命令手动生成。这是最常用的方式。
        
    - **JVM 参数自动生成**：通过配置 `-XX:+HeapDumpOnOutOfMemoryError` 和 `-XX:HeapDumpPath=/path/to/dump`，可以在发生 OOM 时自动生成堆转储文件。
        
3. 分析 Heap Dump 文件：

    使用内存分析工具（如 MAT - Memory Analyzer Tool 或 JVisualVM）来分析 hprof 文件。

    - **支配树分析 (Dominator Tree)**：查看占用内存最大的对象是谁，以及是谁持有了它们的引用。这能快速定位到最可疑的对象。
        
    - **查找内存泄漏点**：在 MAT 中，可以直接运行 "Leak Suspects" 报告，它会自动分析并给出可能的内存泄漏点。
        
    - **分析对象引用链**：找到占用内存异常的对象，分析其到 GC Roots 的引用链。检查这些引用是否是业务逻辑中不必要的强引用，例如：
        
        - 集合类容器（如 `HashMap`, `ArrayList`）使用后未清空，其生命周期与应用一样长。
            
        - 资源对象（如数据库连接、文件流）未在 `finally` 块中正确关闭。
            
        - 监听器或回调函数未被正确注销。
            
4. **代码定位与修复**：
    
    - 根据分析工具定位到的问题对象和引用链，回到源代码中查找对应的业务逻辑。
        
    - 审查代码，修复导致内存无法被回收的逻辑错误。例如，在适当的时机将不再需要的对象引用设置为 `null`，或从集合中 `remove` 掉。

通过以上**“监控 -> 快照 -> 分析 -> 定位”**的流程，可以系统性地排查和解决绝大多数堆内存相关的问题。