---
title: Redis的Java客户端
createTime: 2025/06/25 15:15:16
permalink: /notes/HMRedis/2c3djeie/
---
Redis 官方网站提供了各种编程语言的客户端，网址为：[Connect with Redis client API libraries](https://redis.io/docs/clients/)。

在众多 Java 客户端中，有几个被特别推荐使用：

*   Jedis 和 Lettuce：它们主要提供与 Redis 命令相对应的 API，方便开发者操作 Redis。Spring Data Redis 对这二者进行了抽象和封装，因此通常会直接使用 Spring Data Redis 进行学习。
*   Redisson：它在 Redis 的基础上实现了分布式、可伸缩的 Java 数据结构，例如 Map、Queue 等，并且支持跨进程的同步机制，如 Lock、Semaphore 等，适合用于实现特殊的功能需求。

## 3.1 Jedis 客户端

Jedis 的官方网站地址为：[Jedis](https://github.com/redis/jedis)。

### 3.1.1 快速入门

下面是一个使用 Jedis 客户端的快速入门示例。

1.  **引入依赖：**

    在 `pom.xml` 文件中添加 Jedis 的依赖：

    ```xml
    <dependency>
        <groupId>redis.clients</groupId>
        <artifactId>jedis</artifactId>
        <version>3.7.0</version>
    </dependency>
    ```

2.  **建立连接：**

    创建一个单元测试类，并在 `setUp` 方法中建立与 Redis 的连接：

    ```java
    private Jedis jedis;

    @BeforeEach
    void setUp() {
        // 1.建立连接
        jedis = new Jedis("192.168.150.101", 6379);
        // 2.设置密码
        jedis.auth("123321");
        // 3.选择库
        jedis.select(0);
    }
    ```

3.  **测试：**

    编写测试方法来操作 Redis 中的 String 和 Hash 数据类型：

    ```java
    @Test
    void testString() {
        // 存入数据
        String result = jedis.set("name", "虎哥");
        System.out.println("result = " + result);
        // 获取数据
        String name = jedis.get("name");
        System.out.println("name = " + name);
    }

    @Test
    void testHash() {
        // 插入 hash 数据
        jedis.hset("user:1", "name", "Jack");
        jedis.hset("user:1", "age", "21");

        // 获取
        Map<String, String> map = jedis.hgetAll("user:1");
        System.out.println(map);
    }
    ```

4.  **释放资源：**

    在 `tearDown` 方法中关闭 Jedis 连接，释放资源：

    ```java
    @AfterEach
    void tearDown() {
        if (jedis != null) {
            jedis.close();
        }
    }
    ```

### 3.1.2 连接池

由于 Jedis 本身不是线程安全的，并且频繁创建和销毁连接会带来性能损耗，因此推荐使用 Jedis 连接池来代替直接连接的方式。

```java
package com.itheima.jedis.util;

import redis.clients.jedis.*;

public class JedisConnectionFactory {

    private static JedisPool jedisPool;

    static {
        // 配置连接池
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(8);
        poolConfig.setMaxIdle(8);
        poolConfig.setMinIdle(0);
        poolConfig.setMaxWaitMillis(1000);
        // 创建连接池对象，参数：连接池配置、服务端 ip、服务端端口、超时时间、密码
        jedisPool = new JedisPool(poolConfig, "192.168.150.101", 6379, 1000, "123321");
    }

    public static Jedis getJedis(){
        return jedisPool.getResource();
    }
}
```

这段代码展示了如何使用 `JedisPool` 来管理 Jedis 连接。`JedisPoolConfig` 用于配置连接池的参数，例如最大连接数、最大空闲连接数、最小空闲连接数和最大等待时间。通过连接池，可以避免频繁创建和销毁 Jedis 连接，提高性能和资源利用率。

## 3.2 Spring Data Redis 客户端

Spring Data 是 Spring 中用于数据操作的模块，包含了对各种数据库的集成。其中，对 Redis 的集成模块被称为 Spring Data Redis，官方网站地址为：[Spring Data Redis](https://spring.io/projects/spring-data-redis)。

Spring Data Redis 提供了以下功能：

* 整合不同的 Redis 客户端（Lettuce 和 Jedis）。
* 提供 `RedisTemplate` 统一 API 来操作 Redis。
* 支持 Redis 的发布订阅模型。
* 支持 Redis 哨兵和 Redis 集群。
* 支持基于 Lettuce 的响应式编程。
* 支持基于 JDK、JSON、字符串、Spring 对象的数据序列化及反序列化。
* 支持基于 Redis 的 JDK Collection 实现。

Spring Data Redis 提供了 `RedisTemplate` 工具类，其中封装了各种对 Redis 的操作，并且将不同数据类型的操作 API 封装到了不同的类型中。`RedisTemplate` 的 API 按照数据类型被分为了不同的接口，例如 `opsForValue()` 用于操作 String 类型，`opsForList()` 用于操作 List 类型等。

### 3.2.1 快速入门

Spring Boot 已经提供了对 Spring Data Redis 的支持，使用起来非常简单。

下面是一个使用 Spring Data Redis 的快速入门示例。

1.  **引入依赖：**

    创建一个 SpringBoot 项目，并勾选 Spring Data Redis 依赖。此时，只需在创建完成后，添加连接池依赖即可：

    ```xml
	<!-- common-pool -->
	<dependency>
		<groupId>org.apache.commons</groupId>
		<artifactId>commons-pool2</artifactId>
	</dependency>     
    ```

2.  **配置 Redis：**

    在 `application.yml` 或 `application.properties` 文件中配置 Redis 连接信息：

    ```yaml
    spring:
      redis:
        host: 192.168.150.101
        port: 6379
        password: 123321
        lettuce:
          pool:
            max-active: 8
            max-idle: 8
            min-idle: 0
            max-wait: 100ms
    ```

3.  **注入 `RedisTemplate`：**

    由于 Spring Boot 的自动装配机制，可以直接在 Spring Bean 中注入 `RedisTemplate`：

    ```java
    @SpringBootTest
    class RedisStringTests {

        @Autowired
        private RedisTemplate redisTemplate;
    }
    ```

4.  **编写测试：**

    编写测试方法来操作 Redis 中的 String 数据类型：

    ```java
    @SpringBootTest
    class RedisStringTests {

        @Autowired
        private RedisTemplate redisTemplate;

        @Test
        void testString() {
            // 写入一条 String 数据
            redisTemplate.opsForValue().set("name", "虎哥");
            // 获取 string 数据
            Object name = redisTemplate.opsForValue().get("name");
            System.out.println("name = " + name);
        }
    }
    ```

### 3.2.2 自定义序列化

`RedisTemplate` 可以接收任意 `Object` 作为值写入 Redis。在写入之前，它会将 `Object` 序列化为字节形式。默认情况下，`RedisTemplate` 采用 JDK 序列化，但这会导致可读性差、内存占用较大的问题。

为了解决这些问题，可以自定义 `RedisTemplate` 的序列化方式，代码如下：

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){
        // 创建 RedisTemplate 对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建 JSON 序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer =
            							new GenericJackson2JsonRedisSerializer();
        // 设置 Key 的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置 Value 的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}
```

这段代码使用 `GenericJackson2JsonRedisSerializer` 来进行 JSON 序列化，代替默认的 JDK 序列化方式。这样可以提高可读性，并且能够将 Java 对象自动序列化为 JSON 字符串，以及在查询时自动将 JSON 反序列化为 Java 对象。但是，JSON 序列化会记录序列化时对应的 class 名称，这会带来额外的内存开销。

### 3.2.3 StringRedisTemplate

为了节省内存空间，可以不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化。

由于存入和读取时的序列化及反序列化都是手动实现的，Spring Data Redis 就不会将 class 信息写入 Redis 了。

Spring Data Redis 提供了 `RedisTemplate` 的子类 `StringRedisTemplate`，它的 key 和 value 的序列化方式默认就是 String 方式。

使用 `StringRedisTemplate` 可以省去自定义 `RedisTemplate` 的序列化方式的步骤，而是直接使用：

```java
@Autowired
private StringRedisTemplate stringRedisTemplate;
// JSON 序列化工具
private static final ObjectMapper mapper = new ObjectMapper();

@Test
void testSaveUser() throws JsonProcessingException {
    // 创建对象
    User user = new User("虎哥", 21);
    // 手动序列化
    String json = mapper.writeValueAsString(user);
    // 写入数据
    stringRedisTemplate.opsForValue().set("user:200", json);

    // 获取数据
    String jsonUser = stringRedisTemplate.opsForValue().get("user:200");
    // 手动反序列化
    User user1 = mapper.readValue(jsonUser, User.class);
    System.out.println("user1 = " + user1);
}
```

这段代码演示了如何使用 `StringRedisTemplate` 存储 Java 对象。首先，使用 `ObjectMapper` 将 Java 对象序列化为 JSON 字符串，然后将 JSON 字符串存储到 Redis 中。在读取数据时，从 Redis 中获取 JSON 字符串，然后使用 `ObjectMapper` 将 JSON 字符串反序列化为 Java 对象。由于序列化和反序列化过程是手动完成的，因此 Spring Data Redis 不会将 class 信息写入 Redis，从而节省了内存空间。
