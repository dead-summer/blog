---
title: 调用构造方法
createTime: 2025/07/15 15:53:01
permalink: /notes/LXFJava/k1rionlg/
---
通常我们使用 `new` 操作符来创建新的实例，例如：

```java
Person p = new Person();
```

如果希望通过反射来创建新的实例，可以调用 `Class` 提供的 `newInstance()` 方法：

```java
Person p = Person.class.newInstance();
```

`Class.newInstance()` 的局限性在于，它只能调用类的 `public` 无参数构造方法。如果构造方法带有参数，或者不是 `public` 的，就无法直接通过 `Class.newInstance()` 来调用。

为了调用任意的构造方法，Java 的反射 API 提供了 `Constructor` 对象。`Constructor` 对象包含了构造方法的所有信息，可以创建一个实例。`Constructor` 对象和 `Method` 非常类似，区别在于它是一个构造方法，并且调用结果总是返回实例。

以下是一个使用 `Constructor` 的例子：

```java
import java.lang.reflect.Constructor;

public class Main {
    public static void main(String[] args) throws Exception {
        // 获取构造方法 Integer(int):
        Constructor cons1 = Integer.class.getConstructor(int.class);
        // 调用构造方法:
        Integer n1 = (Integer) cons1.newInstance(123);
        System.out.println(n1);

        // 获取构造方法 Integer(String)
        Constructor cons2 = Integer.class.getConstructor(String.class);
        Integer n2 = (Integer) cons2.newInstance("456");
        System.out.println(n2);
    }
}
```

上述代码展示了如何使用 `Constructor` 对象来调用 `Integer` 类的不同构造方法。

- 首先，通过 `Integer.class.getConstructor(int.class)` 获取接受 `int` 类型参数的构造方法。
- 然后使用 `cons1.newInstance(123)` 创建一个新的 `Integer` 实例。
- 接着，通过 `Integer.class.getConstructor(String.class)` 获取接受 `String` 类型参数的构造方法，并使用 `cons2.newInstance("456")` 创建另一个 `Integer` 实例。

通过 `Class` 实例获取 `Constructor` 的方法如下：

| 方法名                               | 描述                                                                      |
| ------------------------------------- | ------------------------------------------------------------------------ |
| `getConstructor(Class...)`            | 获取某个 `public` 的 `Constructor`。                                      |
| `getDeclaredConstructor(Class...)`     | 获取某个 `Constructor`，不考虑访问修饰符，只考虑当前类中声明的构造方法。 |
| `getConstructors()`                   | 获取所有 `public` 的 `Constructor`。                                     |
| `getDeclaredConstructors()`           | 获取所有 `Constructor`，不考虑访问修饰符，只考虑当前类中声明的构造方法。 |

需要注意的是，`Constructor` 总是当前类定义的构造方法，与父类无关，因此不存在多态的问题。

调用非 `public` 的 `Constructor` 时，必须首先通过 `setAccessible(true)` 设置允许访问。
