---
title: 获取继承关系
createTime: 2025/07/15 15:56:00
permalink: /notes/LXFJava/8l0ahv53/
---
当获取到某个 `Class` 对象时，实际上就获取到了一个类的类型。Java 提供了以下三种方式来获取 `Class` 实例：

1.  直接通过 `Class` 属性获取，例如 `String.class` 获取 `String` 类的 `Class` 实例。
2.  通过实例的 `getClass()` 方法获取，例如 `String s = ""; Class cls = s.getClass();`。
3.  通过 `Class.forName("")` 方法获取，传入 `Class` 的完整类名，例如 `Class s = Class.forName("java.lang.String");`。

这三种方式获取的 `Class` 实例都是同一个实例，因为 JVM 对每个加载的 `Class` 只创建一个 `Class` 实例来表示它的类型。

## 5.1 获取父类的 Class

有了 `Class` 实例，可以通过 `getSuperclass()` 方法获取其父类的 `Class`。例如：

```java
Class i = Integer.class;
Class n = i.getSuperclass();
System.out.println(n); // 输出 Number
Class o = n.getSuperclass();
System.out.println(o); // 输出 Object
System.out.println(o.getSuperclass()); // 输出 null
```

除 `Object` 外，任何非 `interface` 的 `Class` 都必定存在一个父类类型。`Object` 类的父类为 `null`。

## 5.2 获取 interface

可以通过 `getInterfaces()` 方法查询一个类实现的接口类型。例如，查询 `Integer` 实现的接口：

```java
Class s = Integer.class;
Class[] is = s.getInterfaces();
for (Class i : is) {
    System.out.println(i);
}
```

上述代码会输出 `Integer` 类实现的接口：

```
interface java.lang.Comparable
interface java.lang.constant.Constable
interface java.lang.constant.ConstantDesc
```

需要注意的是，`getInterfaces()` 只返回当前类直接实现的接口类型，不包括其父类实现的接口类型。 例如，`Integer` 的父类是 `Number`，`Number` 实现了 `java.io.Serializable` 接口，但是通过 `Integer.class.getSuperclass().getInterfaces()` 才能获取到 `java.io.Serializable` 接口。

对所有 `interface` 的 `Class` 调用 `getSuperclass()` 返回的是 `null`，获取接口的父接口要用 `getInterfaces()`。

```java
System.out.println(java.io.DataInputStream.class.getSuperclass()); // java.io.FilterInputStream，因为 DataInputStream 继承自 FilterInputStream
System.out.println(java.io.Closeable.class.getSuperclass()); // null，对接口调用 getSuperclass() 总是返回 null，获取接口的父接口要用 getInterfaces()
```

如果一个类没有实现任何 `interface`，那么 `getInterfaces()` 返回空数组。

## 5.3 继承关系判断

判断一个实例是否是某个类型，通常使用 `instanceof` 操作符：

```java
Object n = Integer.valueOf(123);
boolean isDouble = n instanceof Double; // false
boolean isInteger = n instanceof Integer; // true
boolean isNumber = n instanceof Number; // true
boolean isSerializable = n instanceof java.io.Serializable; // true
```

如果是两个 `Class` 实例，要判断一个向上转型是否成立，可以调用 `isAssignableFrom()` 方法：

```java
Integer.class.isAssignableFrom(Integer.class); // true，因为 Integer 可以赋值给 Integer
Number.class.isAssignableFrom(Integer.class); // true，因为 Integer 可以赋值给 Number
Object.class.isAssignableFrom(Integer.class); // true，因为 Integer 可以赋值给 Object
Integer.class.isAssignableFrom(Number.class); // false，因为 Number 不能赋值给 Integer
```

`isAssignableFrom()` 方法用于判断调用该方法的 `Class` 对象是否与参数中的 `Class` 对象相同，或者是参数 `Class` 对象的父类或父接口。 换句话说，就是判断是否可以将参数类型的对象赋值给当前类型的对象。
