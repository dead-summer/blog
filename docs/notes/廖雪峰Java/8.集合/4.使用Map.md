---
title: 使用Map
createTime: 2025/07/18 18:29:03
permalink: /notes/LXFJava/tfyp31be/
---
`List` 是一种顺序列表，当需要根据 `name` 查找 `List` 中某个指定 `Student` 的分数时，通常需要遍历整个 `List`，效率较低。`Map` 是一种键值（key-value）映射表的数据结构，可以高效地通过 `key` 快速查找 `value`（元素）。

## 4.1 Map 的基本用法

`Map<K, V>` 是一种键 - 值映射表。调用 `put(K key, V value)` 方法时，将 `key` 和 `value` 做了映射并放入 `Map`。调用 `V get(K key)` 时，可以通过 `key` 获取到对应的 `value`。如果 `key` 不存在，则返回 `null`。`Map` 也是一个接口，最常用的实现类是 `HashMap`。

以下代码展示了如何使用 `Map` 根据 `name` 查询某个 `Student`：

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Student s = new Student("Xiao Ming", 99);
        Map<String, Student> map = new HashMap<>();
        map.put("Xiao Ming", s); // 将"Xiao Ming"和Student实例映射并关联
        Student target = map.get("Xiao Ming"); // 通过key查找并返回映射的Student实例
        System.out.println(target == s); // true，同一个实例
        System.out.println(target.score); // 99
        Student another = map.get("Bob"); // 通过另一个key查找
        System.out.println(another); // 未找到返回null
    }
}

class Student {
    public String name;
    public int score;
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
}
```

如果只是想查询某个 `key` 是否存在，可以调用 `boolean containsKey(K key)` 方法。

## 4.2 Key 的唯一性

在 `Map` 中，`key` 必须是唯一的。如果对同一个 `key` 调用两次 `put()` 方法，分别放入不同的 `value`，那么后一次放入的 `value` 会覆盖前一次的 `value`。

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 123);
        map.put("pear", 456);
        System.out.println(map.get("apple")); // 123
        map.put("apple", 789); // 再次放入apple作为key，但value变为789
        System.out.println(map.get("apple")); // 789
    }
}
```

`put()` 方法的签名是 `V put(K key, V value)`，如果放入的 `key` 已经存在，`put()` 方法会返回被删除的旧的 `value`，否则，返回 `null`。

需要始终牢记：`Map` 中不存在重复的 `key`，因为放入相同的 `key`，只会把原有的 `key-value` 对应的 `value` 给替换掉。

## 4.3 Value 的重复性

在一个 `Map` 中，`key` 不能重复，但 `value` 是可以重复的：

```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 123);
map.put("pear", 123); // ok
```

## 4.4 遍历 Map

### 4.4.1 遍历 Key

可以使用 `for each` 循环遍历 `Map` 实例的 `keySet()` 方法返回的 `Set` 集合，它包含不重复的 `key` 的集合：

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 123);
        map.put("pear", 456);
        map.put("banana", 789);
        for (String key : map.keySet()) {
            Integer value = map.get(key);
            System.out.println(key + " = " + value);
        }
    }
}
```

### 4.4.2 同时遍历 Key 和 Value

可以使用 `for each` 循环遍历 `Map` 对象的 `entrySet()` 集合，它包含每一个 `key-value` 映射：

```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("apple", 123);
        map.put("pear", 456);
        map.put("banana", 789);
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println(key + " = " + value);
        }
    }
}
```

### 4.4.3 顺序

`Map` 和 `List` 不同的是，`Map` 存储的是 `key-value` 的映射关系，并且，它*不保证顺序*。在遍历的时候，遍历的顺序既不一定是 `put()` 时放入的 `key` 的顺序，也不一定是 `key` 的排序顺序。使用 `Map` 时，任何依赖顺序的逻辑都是不可靠的。 以 `HashMap` 为例，假设我们放入 `"A"`，`"B"`，`"C"` 这 3 个 `key`，遍历的时候，每个 `key` 会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的 JDK 版本，相同的代码遍历的输出顺序都是不同的！

::: note 

遍历 `Map` 时，不可假设输出的 `key` 是有序的！

:::
