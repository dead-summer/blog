---
title: 编写泛型
createTime: 2025/07/17 20:04:35
permalink: /notes/LXFJava/prs69y3t/
---
编写泛型类相较于编写普通类更为复杂，通常泛型类多用于集合类中，例如 `ArrayList<T>`。一般情况下，我们很少需要编写泛型类，但如果确有需要，可以按照以下步骤进行：

1.  首先，使用具体的类型（例如 `String`）编写类。
2.  然后，找出所有特定的类型，将其替换为 `T`，并声明 `<T>`。
3.  熟练之后，可以直接从 `T` 开始编写。

以下是一个从具体类型到泛型的示例：

::: code-tabs

@tab 原始代码 (使用 `String` 类型)

```java
public class Pair {
    private String first;
    private String last;
    public Pair(String first, String last) {
        this.first = first;
        this.last = last;
    }
    public String getFirst() {
        return first;
    }
    public String getLast() {
        return last;
    }
}
```

@tab 修改后的泛型代码 (使用泛型 `T`)

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```

:::

## 3.1 静态方法

编写泛型类时，需要特别注意泛型类型 `<T>` 不能用于静态方法。

例如，以下代码是错误的：

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public T getLast() { ... }

    // 对静态方法使用<T>:
    public static Pair<T> create(T first, T last) {
        return new Pair<T>(first, last);
    }
}
```

上述代码会导致编译错误，因为无法在静态方法 `create()` 的方法参数和返回类型上使用泛型类型 `T`。

虽然可以通过在 `static` 修饰符后面添加一个 `<T>` 来避免编译错误，但这实际上会使静态方法中的 `<T>` 与 `Pair<T>` 中的 `<T>` 没有任何关系。

对于静态方法，应该将其改写为“泛型”方法，使用另一个类型即可。对于上面的 `create()` 静态方法，应该将其改为另一种泛型类型，例如 `<K>`：

```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public T getLast() { ... }

    // 静态泛型方法应该使用其他类型区分:
    public static <K> Pair<K> create(K first, K last) {
        return new Pair<K>(first, last);
    }
}
```

这段代码展示了如何在静态方法中使用泛型。关键在于，静态方法中的泛型类型 `<K>` 与类定义的泛型类型 `<T>` 是相互独立的。这意味着静态方法可以处理不同于类泛型类型的类型。在本例中，`create` 方法接收两个类型为 `K` 的参数，并返回一个 `Pair<K>` 实例。这种方式避免了静态方法错误地使用了类泛型类型，保证了类型安全。

## 3.2 多个泛型类型

泛型还可以定义多种类型。例如，如果希望 `Pair` 不总是存储两个类型一样的对象，可以使用类型 `<T, K>`：

```java
public class Pair<T, K> {
    private T first;
    private K last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public K getLast() { ... }
}
```

使用时，需要指出两种类型：

```java
Pair<String, Integer> p = new Pair<>("test", 123);
```

Java 标准库的 `Map<K, V>` 就是使用两种泛型类型的例子，它对 Key 使用一种类型，对 Value 使用另一种类型。
