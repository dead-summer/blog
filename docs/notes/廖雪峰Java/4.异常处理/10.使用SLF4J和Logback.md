---
title: 使用SLF4J和Logback
createTime: 2025/07/15 14:53:39
permalink: /notes/LXFJava/sg0oyz5m/
---
在 Java 的开源生态系统中，对于同一个功能，往往存在多种互相竞争的开源库。SLF4J 和 Logback 的出现，便是由于开发者对 Commons Logging 和 Log4j 在接口设计和性能上的不满意。SLF4J 类似于 Commons Logging，是一个日志接口，而 Logback 则类似于 Log4j，是日志的一种具体实现。

## 10.1 SLF4J 对 Commons Logging 的改进

SLF4J 的一个主要改进在于日志接口的参数处理方式。在 Commons Logging 中，拼接字符串构建日志信息的方式比较繁琐。例如：

```java
int score = 99;
p.setScore(score);
log.info("Set score " + score + " for Person " + p.getName() + " ok.");
```

而 SLF4J 使用带占位符的字符串，允许将变量作为参数传入，从而自动替换占位符，使代码更简洁易读：

```java
int score = 99;
p.setScore(score);
logger.info("Set score {} for Person {} ok.", score, p.getName());
```

## 10.2 SLF4J 的基本使用

SLF4J 的接口实际上与 Commons Logging 非常相似。以下是一个简单的 SLF4J 使用示例：

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class Main {
    final Logger logger = LoggerFactory.getLogger(getClass());
}
```

对比 Commons Logging 和 SLF4J 的接口：

| Commons Logging                       | SLF4J                   |
| ------------------------------------- | ----------------------- |
| org.apache.commons.logging.Log        | org.slf4j.Logger        |
| org.apache.commons.logging.LogFactory | org.slf4j.LoggerFactory |

可以看出，主要的区别在于类名的变更：`Log` 变为 `Logger`，`LogFactory` 变为 `LoggerFactory`。

## 10.3 集成 SLF4J 和 Logback

使用 SLF4J 和 Logback 的步骤与使用 Commons Logging 和 Log4j 类似：

1.  下载 SLF4J 和 Logback 的相关 jar 包。
2.  将以下 jar 包添加到 classpath 中：
    *   `slf4j-api-1.7.x.jar`
    *   `logback-classic-1.2.x.jar`
    *   `logback-core-1.2.x.jar`
3.  使用 SLF4J 的 `Logger` 和 `LoggerFactory` 进行日志记录。
4.  配置 Logback，将 `logback.xml` 文件放置在 classpath 下。

以下是一个 `logback.xml` 的示例配置：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
		<encoder>
			<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
		</encoder>
	</appender>

	<appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
		<encoder>
			<pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
			<charset>utf-8</charset>
		</encoder>
		<file>log/output.log</file>
		<rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
			<fileNamePattern>log/output.log.%i</fileNamePattern>
		</rollingPolicy>
		<triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
			<MaxFileSize>1MB</MaxFileSize>
		</triggeringPolicy>
	</appender>

	<root level="INFO">
		<appender-ref ref="CONSOLE" />
		<appender-ref ref="FILE" />
	</root>
</configuration>
```

**代码解释：**

*   `<appender>` 元素定义了日志的输出目的地。在这个例子中，定义了两个 appender，一个名为 `CONSOLE`，用于将日志输出到控制台，另一个名为 `FILE`，用于将日志输出到文件。
* 对于 `CONSOLE` appender，`<encoder>` 元素定义了日志的格式。`<pattern>` 子元素指定了日志的输出模式，例如，`%d{HH:mm:ss.SSS}` 表示日期和时间，`%thread` 表示线程名，`%-5level` 表示日志级别，`%logger{36}` 表示 logger 的名字，`%msg` 表示日志消息。
* 对于 `FILE` appender，`<file>` 元素指定了日志文件的名称，`<rollingPolicy>` 元素定义了日志文件的滚动策略。在这个例子中，使用了 `FixedWindowRollingPolicy`，表示当日志文件达到一定大小后，会创建一个新的日志文件，并将旧的日志文件重命名。`<triggeringPolicy>` 元素定义了触发日志滚动的策略。在这个例子中，使用了 `SizeBasedTriggeringPolicy`，表示当日志文件的大小超过 `<MaxFileSize>` 指定的值时，就会触发日志滚动。
*   `<root>` 元素定义了 root logger 的行为。`<level>` 属性指定了 root logger 的日志级别，`<appender-ref>` 元素指定了 root logger 使用的 appender。

配置完成后，运行程序将生成类似以下的输出：

```
13:15:25.328 [main] INFO  com.itranswarp.learnjava.Main - Start process...
```

