---
title: 方法在计算机中的执行原理
createTime: 2025/07/01 19:38:38
permalink: /notes/HMJava/4ylxc1oz/
---
## 5.1 方法执行的内存区域

Java 程序的运行在内存中进行，内存区域主要分为栈、堆和方法区。Java 方法在**栈内存**中执行。

每次调用方法，该方法都会进栈执行；执行完毕后，又会弹栈出去。这个过程类似于手枪子弹夹的上子弹和击发子弹的过程，即“先进后出，后进先出”。

假设在 `main` 方法中依次调用 A 方法、B 方法、C 方法，其在内存中的执行流程如下：

1.  每次调用方法，方法都会从栈顶压栈执行。
2.  每个方法执行完后，会从栈顶弹栈出去。

![[5.方法在计算机中的执行原理_附件/5.方法在计算机中的执行原理-20250701194030019.png]]

## 5.2 有返回值的方法的内存分析

以下代码展示了计算两个整数和的方法在内存中的执行原理。

```java
public class MethodDemo {
    public static void main(String[] args) {
        int rs = sum(10, 20);
        System.out.println(rs);
    }
    public static int sum(int a, int b ){
        int c = a + b; 
        return c;
    }
}
```

 **代码解释：**
*   `main` 方法首先调用 `sum` 方法，并将 `10` 和 `20` 作为参数传递给 `a` 和 `b`。
*   `sum` 方法计算 `a` 和 `b` 的和，将结果赋值给变量 `c`。
*   `sum` 方法通过 `return c;` 将计算结果返回给 `main` 方法。
*   `main` 方法接收到返回值后，将其赋值给变量 `rs`，然后打印 `rs` 的值。

**内存执行过程：**
::: steps
**1. 类加载（方法区）：**

- 首先，`MethodDemo.class` 字节码文件被加载到 JVM 的方法区（Method Area）。方法区是所有线程共享的内存区域，用于存储类信息、静态变量、常量等。
- 在类加载的过程中，`main` 方法和 `sum` 方法的代码也被加载到方法区。

**2. `main` 方法开始执行（栈内存）：**

- JVM 创建一个栈帧（Stack Frame）来执行 `main` 方法。 栈帧 是用于支持虚拟机进行方法调用和方法执行的数据结构，包含局部变量表、操作数栈、动态链接、方法出口等信息。
- `main` 方法的栈帧被压入 Java 虚拟机栈（JVM Stack）。 JVM 栈是线程私有的，每个线程都有一个栈，用于存储当前正在执行的方法的栈帧。

**3. 调用 `sum` 方法（栈内存）：**

- 在 `main` 方法中，执行 `int rs = sum(10, 20);` 语句，调用 `sum` 方法。

**4. `sum` 方法进栈（栈内存）：**

- JVM 为 `sum` 方法创建一个新的栈帧。
- `sum` 方法的栈帧被压入 JVM 栈， 成为当前栈顶帧。

**5. `sum` 方法栈帧中的内存分配（栈内存）：**

- 在 `sum` 方法的栈帧中，为局部变量 `a` 和 `b` 分配内存空间。

**6. 传递参数（栈内存）：**

- 将 `main` 方法传递的参数 10 和 20 分别赋值给 `sum` 方法栈帧中的局部变量 `a` 和 `b`。`a` 的值为 10，`b` 的值为 20。

**7. 执行 `sum` 方法的计算（栈内存）：**

- 在 `sum` 方法中，执行 `int c = a + b;` 语句，计算 `a + b` 的结果，并将结果赋值给局部变量 `c`。
- `c` 的值为 30。

**8. `sum` 方法返回（栈内存）：**

- 执行 `return c;` 语句，`sum` 方法将 `c` 的值（即 30）返回给调用者 `main` 方法。在这一步，`sum` 方法的栈帧从 Java 虚拟机栈中弹出。

**9. `main` 方法接收返回值（栈内存）：**

- `main` 方法接收 `sum` 方法返回的值 30，并将其赋值给局部变量 `rs`。

**10. 输出结果（栈内存）：**

- `main` 方法在堆中构造 `System.out`, 在方法区找到 `println` 方法，通过传递参数 `rs`, 在控制台打印出 30。

![[5.方法在计算机中的执行原理_附件/5.方法在计算机中的执行原理-20250701194236585.png]]

:::

## 5.3 无返回值的方法的内存分析

接下来分析一个无返回值、无参数的方法的内存原理。

```java
public class Demo2Method {
    public static void main(String[] args) {
        study();
    }

    public static void study(){
		eat();
		System.out.println("学习");
		sleep();
	}
    public static void eat(){
        System.out.println("吃饭");
    }
  
    public static void sleep(){
        System.out.println("睡觉");
    }
}
```

**代码解释：**
*   `main` 方法调用 `study` 方法。
*   `study` 方法依次调用 `eat` 方法、打印 " 学习 "、调用 `sleep` 方法。
*   `eat` 方法打印 " 吃饭 "。
*   `sleep` 方法打印 " 睡觉 "。

**内存执行过程：**

::: steps

**1. 类加载（方法区）：**

- `Demo2Method.class` 字节码文件被加载到方法区。
- `main`、`study`、`eat`、`sleep` 方法的相关信息（代码、常量等）也被加载到方法区。

**2. `main` 方法进栈 (栈内存):**

- JVM 创建 `main` 方法的栈帧，并将其压入 JVM 栈。
- `main` 方法的栈帧成为当前的栈顶帧。

**3. 调用 `study` 方法 (栈内存):**

- `main` 方法执行 `study()` 语句，调用 `study` 方法。

**4. `study` 方法进栈 (栈内存):**

- JVM 创建 `study` 方法的栈帧，并将其压入 JVM 栈。
- `study` 方法的栈帧成为当前的栈顶帧。

**5. 调用 `eat` 方法（栈内存）：**

- `study` 方法执行 `eat()` 语句，调用 `eat` 方法。

**6. `eat` 方法进栈，执行并出栈（栈内存）：**

- JVM 创建 `eat` 方法的栈帧，并将其压入 JVM 栈。
- `eat` 方法的栈帧成为当前的栈顶帧。
- `eat` 方法执行 `System.out.println("吃饭");` 语句，在控制台打印 " 吃饭 "。
- `eat` 方法执行完毕，其栈帧从 JVM 栈中弹出（出栈）。控制权返回到 `study` 方法。

**7. 执行 `study` 方法剩下的代码，打印 " 学习 " (栈内存):**

- `study` 方法执行 `System.out.println("学习");` 语句，在控制台打印 " 学习 "。

**8. 调用 `sleep` 方法 (栈内存):**

- `study` 方法执行 `sleep()` 语句，调用 `sleep` 方法。

**9. `sleep` 方法进栈，执行并出栈（栈内存）：**

- JVM 创建 `sleep` 方法的栈帧，并将其压入 JVM 栈。
- `sleep` 方法的栈帧成为当前栈顶帧.
- `sleep` 方法执行 `System.out.println("睡觉");` 语句，在控制台打印 " 睡觉 "。
- `sleep` 方法执行完毕，其栈帧从 JVM 栈中弹出（出栈）。控制权返回到 `study` 方法。

**10. `study` 方法执行完成并出栈 (栈内存):**

- `study` 方法执行完毕，其栈帧从 JVM 栈中弹出（出栈）。控制权返回到 `main` 方法。

**11. `main` 方法执行完成并出栈 (栈内存):**

- `main` 方法执行完毕，其栈帧从 JVM 栈中弹出（出栈）。
- JVM 结束运行。

![[5.方法在计算机中的执行原理_附件/5.方法在计算机中的执行原理-20250701194833360.png]]

:::
