import{a as l,c as d,b as s,d as a,r as t,o as n}from"./app-CAzY0Upz.js";const r="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807155633054-xP53aRYI.png",o="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807160543998-BbtLRTz-.png",c="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807161051852-DFnBegWz.png",h="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182124284-DrV7V-TM.png",p="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182135804-C903XLu2.png",g="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182213979-VT_sR3_f.png",k="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182355001-BmLVsMHl.png",v="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182727200-BjyxxhhK.png",u="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807182907041-BUK5Xj2T.png",b="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807183442389-CRxc5C9l.png",m="/blog/assets/1.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-20250807233100691-DbT23ZZH.png",f={};function y(A,e){const i=t("Mermaid");return n(),d("div",null,[e[0]||(e[0]=s(`<p>单机 Redis 存在以下四大问题：</p><ul><li><strong>单点故障</strong>：一旦 Redis 实例发生故障，整个缓存系统将无法使用。</li><li><strong>容量瓶颈</strong>：单个 Redis 实例的内存容量有限，无法存储海量数据。</li><li><strong>并发瓶颈</strong>：单个 Redis 实例的并发处理能力有限，无法支持高并发访问。</li><li><strong>流量瓶颈</strong>：单个 Redis 实例的网络带宽有限，无法支持高流量访问。</li></ul><h2 id="_1-1-redis-持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-redis-持久化"><span>1.1 Redis 持久化</span></a></h2><p>为了解决单点故障导致的数据丢失问题，Redis 提供了两种持久化方案：</p><ul><li>RDB 持久化</li><li>AOF 持久化</li></ul><p>接下来，我们将分别介绍这两种持久化方案。</p><h3 id="_1-1-1-rdb-持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-1-rdb-持久化"><span>1.1.1 RDB 持久化</span></a></h3><p>RDB (Redis Database Backup file) 全称 Redis 数据库备份文件，也被称为 Redis 数据快照。简单来说，就是将内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，可以从磁盘读取快照文件，恢复数据。快照文件称为 RDB 文件，默认保存在当前运行目录。</p><h4 id="_1-1-1-1-执行时机" tabindex="-1"><a class="header-anchor" href="#_1-1-1-1-执行时机"><span>1.1.1.1 执行时机</span></a></h4><p>RDB 持久化在四种情况下会执行：</p><ol><li><p><strong><code>save</code> 命令</strong> 执行 <code>save</code> 命令可以立即执行一次 RDB：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">save</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>save</code> 命令会导致主进程执行 RDB，这个过程中其它所有命令都会被阻塞。通常只在数据迁移时使用。</p></li><li><p><strong><code>bgsave</code> 命令</strong> 下面的命令可以异步执行 RDB：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">bgsave</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个命令执行后会开启独立进程完成 RDB，主进程可以持续处理用户请求，不受影响。</p></li><li><p><strong>Redis 停机时</strong> Redis 停机时会执行一次 <code>save</code> 命令，实现 RDB 持久化。</p></li><li><p><strong>触发 RDB 条件</strong> Redis 内部有触发 RDB 的机制，可以在 <code>redis.conf</code> 文件中找到，格式如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>save 900 1</span></span>
<span class="line"><span>save 300 10</span></span>
<span class="line"><span>save 60 10000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上配置的含义是：</p><ul><li>900 秒内，如果至少有 1 个 key 被修改，则执行 <code>bgsave</code>。</li><li>300 秒内，如果至少有 10 个 key 被修改，则执行 <code>bgsave</code>。</li><li>60 秒内，如果至少有 10000 个 key 被修改，则执行 <code>bgsave</code>。</li></ul><p>如果设置 <code>save &quot;&quot;</code>，则表示禁用 RDB 持久化。</p></li></ol><h4 id="_1-1-1-2-rdb-原理" tabindex="-1"><a class="header-anchor" href="#_1-1-1-2-rdb-原理"><span>1.1.1.2 RDB 原理</span></a></h4><p><code>bgsave</code> 开始时会 <code>fork</code> 主进程得到子进程，子进程共享主进程的内存数据。完成 <code>fork</code> 后，子进程读取内存数据并写入 RDB 文件。</p><img src="`+r+`" alt="1.分布式缓存-20250807155633054" width="750" style="display:block;margin:auto;"><p><code>fork</code> 采用的是 copy-on-write 技术：</p><ul><li>当主进程执行读操作时，访问共享内存。</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><h3 id="_1-1-2-aof-持久化" tabindex="-1"><a class="header-anchor" href="#_1-1-2-aof-持久化"><span>1.1.2 AOF 持久化</span></a></h3><h4 id="_1-1-2-1-aof-原理" tabindex="-1"><a class="header-anchor" href="#_1-1-2-1-aof-原理"><span>1.1.2.1 AOF 原理</span></a></h4><p>AOF (Append Only File) 全称为追加文件。Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。</p><h4 id="_1-1-2-2-aof-配置" tabindex="-1"><a class="header-anchor" href="#_1-1-2-2-aof-配置"><span>1.1.2.2 AOF 配置</span></a></h4><p>AOF 默认是关闭的，需要修改 <code>redis.conf</code> 配置文件来开启 AOF：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 是否开启 AOF 功能，默认是 no</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendonly yes</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># AOF 文件的名称</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfilename </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">appendonly.aof</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF 的命令记录的频率也可以通过 <code>redis.conf</code> 文件来配置：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 表示每执行一次写命令，立即记录到 AOF 文件</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfsync always </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 写命令执行完先放入 AOF 缓冲区，然后表示每隔 1 秒将缓冲区数据写到 AOF 文件，是默认方案</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfsync everysec </span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 写命令执行完先放入 AOF 缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">appendfsync no</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三种策略的对比如下：</p><ul><li><code>always</code>：每次写命令都立即写入磁盘，性能最差，但数据安全性最高。</li><li><code>everysec</code>：每隔 1 秒将缓冲区数据写入磁盘，性能和数据安全性较好，是默认方案。</li><li><code>no</code>：由操作系统决定何时将缓冲区数据写入磁盘，性能最好，但数据安全性最低。</li></ul><h4 id="_1-1-2-3-aof-文件重写" tabindex="-1"><a class="header-anchor" href="#_1-1-2-3-aof-文件重写"><span>1.1.2.3 AOF 文件重写</span></a></h4><p>由于 AOF (Append Only File) 文件记录的是 Redis 的操作命令，因此 AOF 文件通常比 RDB (Redis DataBase) 文件大。AOF 会记录对同一个 Key 的多次写操作，但只有最后一次写操作的结果才是有效的。</p><p>为了优化 AOF 文件的大小，可以使用 <code>bgrewriteaof</code> 命令手动触发 AOF 文件重写。AOF 重写会创建一个新的 AOF 文件，其中只包含重建当前数据集所需的最少命令集合，从而减小 AOF 文件的大小。</p><p>例如，假设 AOF 文件中原本有以下三个命令，执行 <code>bgrewriteaof</code> 命令后，AOF 文件会被重写为：<code>mset name jack num 666</code>。</p><img src="`+o+`" alt="1.分布式缓存-20250807160543998" width="750" style="display:block;margin:auto;"><p>Redis 也会在触发阈值时自动去重写 AOF 文件。阈值也可以在 <code>redis.conf</code> 中配置：</p><div class="language-properties line-numbers-mode" data-highlighter="shiki" data-ext="properties" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-properties"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># AOF 文件比上次文件增长超过多少百分比则触发重写</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># AOF 文件体积最小多大以上才触发重写 </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">auto-aof-rewrite-min-size 64mb</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-3-rdb-与-aof-对比" tabindex="-1"><a class="header-anchor" href="#_1-1-3-rdb-与-aof-对比"><span>1.1.3 RDB 与 AOF 对比</span></a></h3><p>RDB 和 AOF 各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th>特性</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如 AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量 CPU 和内存消耗</td><td>低，主要是磁盘 I/O 资源，但 AOF 重写时会占用大量 CPU 和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table><h2 id="_1-2-redis-主从" tabindex="-1"><a class="header-anchor" href="#_1-2-redis-主从"><span>1.2 Redis 主从</span></a></h2><h3 id="_1-2-1-搭建主从架构" tabindex="-1"><a class="header-anchor" href="#_1-2-1-搭建主从架构"><span>1.2.1 搭建主从架构</span></a></h3><p>单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。</p><img src="`+c+'" alt="1.分布式缓存-20250807161051852" width="750" style="display:block;margin:auto;"><h3 id="_1-2-2-主从数据同步原理" tabindex="-1"><a class="header-anchor" href="#_1-2-2-主从数据同步原理"><span>1.2.2 主从数据同步原理</span></a></h3><h4 id="_1-2-2-1-全量同步" tabindex="-1"><a class="header-anchor" href="#_1-2-2-1-全量同步"><span>1.2.2.1 全量同步</span></a></h4><p>当主 (master) 从 (slave) 节点第一次建立连接时，会执行<strong>全量同步 (full synchronization)</strong>，即将 master 节点的所有数据都拷贝给 slave 节点。</p><p>全量同步过程可以概括为三个阶段，具体流程如下：</p><ol><li><strong>第一阶段：建立连接与版本信息交换</strong><ul><li>Slave 向 Master 请求数据同步。</li><li>Master 判断是否是第一次同步。判断依据是 Slave 发送的 <code>replid</code> 是否与 Master 的 <code>replid</code> 一致。</li><li>如果是第一次同步（<code>replid</code> 不一致），Master 返回其数据版本信息给 Slave。</li><li>Slave 保存 Master 的版本信息。</li></ul></li><li><strong>第二阶段：RDB 文件生成与传输</strong><ul><li>Master 执行 <code>bgsave</code> 命令，生成 RDB 文件。</li><li>在生成 RDB 文件的同时，Master 会记录期间的所有写命令到 <code>repl_baklog</code>（复制积压缓冲区）。</li><li>Master 将 RDB 文件发送给 Slave。</li><li>Slave 清空本地数据，并加载接收到的 RDB 文件。</li></ul></li><li><strong>第三阶段：增量命令同步</strong><ul><li>Master 将 <code>repl_baklog</code> 中的命令发送给 Slave。</li><li>Slave 执行接收到的命令，以保持与 Master 数据的一致性。</li></ul></li></ol>',45)),a(i,{code:"eJx1kU9OwkAYxfeeYg6gTQBXLlgYtnVBD2AKmRAi/2wrazAaW1MVEkCiVSQBjUkLNVEkYMNlOtOy8grOTBErhC5m0feb73vvjQyPT2AhDRNZMSOJ+S1AvpIoKdl0tiQWFCAAUQZCTizDNYmnEi/KCpTWtCTVJFjKHabEo1wxwwB2HBQVCIplKAFhG/B7wDNNd1yZt0d48MEAYSceJ/8jXIQD/vATv53ipo2vBqimY6vPEP4XiXIAqT3csnB7iGrP5AzGYbO7ggsUj3EgjHx/6f6sge4f8yyEd3cWbPI0FRumO+vi6nBpiQ3Y5YA7e0BWew3ZmG2ih7ItjEdpNqy9+F09lZFJt8SJ1+hgtZZM7C/BZADSGgY2cppEw0ZnfvtOjWoVbGio7rjTXjhjlFVyU59XqhRvXbjTUThClHUwPvdeJ8Q/MuwgMdmPLp98x/l/afODaSuhyOgYdRqsDj28O7aI3ZDRhZEYNRpUgK/7uDFCqv0H/gD0XiSX"}),e[1]||(e[1]=s('<p>Master 节点通过以下关键标识确认 Slave 是否为初次连接</p><ul><li><strong>Replication Id (<code>replid</code>)</strong>：数据集的标记，用于标识数据集的唯一性。如果 <code>replid</code> 一致，则说明是同一数据集。每个 Master 节点都有唯一的 <code>replid</code>，而 Slave 节点会继承 Master 节点的 <code>replid</code>。</li><li><strong>Offset</strong>：偏移量，表示 Master 已经复制的数据量。随着 <code>repl_baklog</code> 中数据增多而增大。Slave 在完成同步时会记录当前同步的 <code>offset</code>。如果 Slave 的 <code>offset</code> 小于 Master 的 <code>offset</code>，表示 Slave 数据落后于 Master，需要更新。</li></ul><p>Slave 在进行数据同步时，需要向 Master 声明自己的 <code>replid</code> 和 <code>offset</code>，Master 才能判断 Slave 需要同步哪些数据。</p><p>由于 Slave 原本也可能是一个 Master，拥有自己的 <code>replid</code> 和 <code>offset</code>。当 Slave 第一次与 Master 建立连接时，会发送自己的 <code>replid</code> 和 <code>offset</code>。</p><p>Master 通过比较 Slave 发送来的 <code>replid</code> 与自己的 <code>replid</code>，判断是否一致。如果不一致，则表示这是一个全新的 Slave，需要进行全量同步。随后，Master 会将自己的 <code>replid</code> 和 <code>offset</code> 发送给 Slave，Slave 保存这些信息，后续 Slave 的 <code>replid</code> 将与 Master 一致。</p><p><strong>因此，Master 判断节点是否是第一次同步的依据是看 <code>replid</code> 是否一致。</strong></p><h4 id="_1-2-2-2-增量同步" tabindex="-1"><a class="header-anchor" href="#_1-2-2-2-增量同步"><span>1.2.2.2 增量同步</span></a></h4><p>全量同步需要先执行 RDB 操作，然后通过网络传输 RDB 文件给 slave 节点，成本较高。因此，除了第一次同步采用全量同步外，后续 slave 节点与 master 节点通常采用<strong>增量同步</strong>。</p><p>增量同步指的是仅更新 slave 节点与 master 节点之间存在差异的数据部分。其流程如下：</p><ol><li><strong>第一阶段：同步请求</strong><ul><li>Slave 节点重启。</li><li>Slave 节点向 Master 节点发送 <code>psync replid offset</code> 命令。</li><li>Master 节点判断请求的 <code>replid</code> 是否一致。如果不是第一次同步，Master 节点回复 <code>continue</code>。</li></ul></li><li><strong>第二阶段：数据同步</strong><ul><li>Master 节点从 <code>repl_baklog</code> 中获取 <code>offset</code> 之后的数据。</li><li>Master 节点将 <code>offset</code> 后的命令发送给 Slave 节点。</li><li>Slave 节点执行接收到的命令，从而与 Master 节点保持同步。</li></ul></li></ol>',10)),a(i,{code:"eJwrTi0sTc1LTnXJTEwvSszlUgCCgsSikszkzILEvBIFX4XEYgXfxOKS1CIMuWCQXHBOYlkqhlQQSKootSAnPikxOyc/HawATPjll6Qq5JelFin46gRbKTxfs+bJjoaXM7Y9W7cVoShY184OKGmoZ6Dwsr336YT1cFFfkKihQkFxZV4y2ILMFIX8tLTi1BKEbl+YOiOFpx1Lnk1b+2L99mcbmyCqn81Y/3TCMqCdL9q3oGoBW2is8GRHL1ANxF3P1ix8v6fn6ex5T5f0KiTn55Vk5pVCPIvLL7t60P0CMjrISsEI6OqnfbuRwsQmqUjf7smOtS/6tj/tnwbxxNMJfc9ntTybuuFZ7zoM1xmBPNQ/8WVDI7LipxP3Ptm9BCPsjIBeeda5/MXCHqgCAG3mvOk="}),e[2]||(e[2]=s('<h4 id="_1-2-2-3-repl-backlog-原理" tabindex="-1"><a class="header-anchor" href="#_1-2-2-3-repl-backlog-原理"><span>1.2.2.3 <code>repl_backlog</code> 原理</span></a></h4><p><code>repl_backlog</code> 是实现增量同步的核心组件，通过记录命令日志的偏移量（<code>offset</code>）定位主从节点数据差异。</p><p><code>repl_baklog</code> 文件是一个固定大小的环形数组。当角标到达数组末尾后，读写操作会从 0 开始，覆盖头部的数据。<code>repl_baklog</code> 中会记录 Redis 处理过的命令日志以及对应的 <code>offset</code>，包括 Master 节点当前的 <code>offset</code> 和 Slave 节点已经拷贝到的 <code>offset</code>。Slave 节点与 Master 节点的 <code>offset</code> 之间的差异，就是 Slave 节点需要通过增量拷贝同步的数据。</p><img src="'+h+'" alt="1.分布式缓存-20250807182124284" width="750" style="display:block;margin:auto;"><p>随着数据不断写入，Master 节点的 <code>offset</code> 逐渐增大，Slave 节点也不断拷贝数据，追赶 Master 节点的 <code>offset</code>。直到数组被填满。此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，已经被同步到 Slave 节点的数据即使被覆盖也不会有影响。</p><img src="'+p+'" alt="1.分布式缓存-20250807182135804" width="750" style="display:block;margin:auto;"><p>然而，如果 Slave 节点出现网络阻塞，导致 Mater 节点的 <code>offset</code> 远远超过了 Slave 节点的 <code>offset</code>。Master 节点继续写入新数据，其 <code>offset</code> 就会覆盖旧的数据，直到将 Slave 节点当前的 <code>offset</code> 也覆盖。</p><img src="'+g+'" alt="1.分布式缓存-20250807182213979" width="750" style="display:block;margin:auto;"><p>此时，如果 Slave 节点恢复，需要同步数据，但发现自己的 <code>offset</code> 已经被覆盖，就无法完成增量同步，只能进行全量同步。</p><h3 id="_1-2-3-主从同步优化" tabindex="-1"><a class="header-anchor" href="#_1-2-3-主从同步优化"><span>1.2.3 主从同步优化</span></a></h3><p>主从同步用于保证主节点和从节点的数据一致性，这在 Redis 集群中至关重要。为了优化 Redis 主从集群，可以从以下几个方面入手：</p><ul><li><strong>配置无磁盘复制：</strong> 在 <code>master</code> 节点中配置 <code>repl-diskless-sync yes</code>，启用无磁盘复制，以避免全量同步时产生过多的磁盘 I/O 操作。</li><li><strong>控制内存占用：</strong> 避免 <code>Redis</code> 单节点上的内存占用过大，以减少 <code>RDB</code>（Redis Database）导致的磁盘 I/O。</li><li><strong>调整 backlog 大小：</strong> 适当调整 <code>repl_backlog</code> 的大小，以便 <code>slave</code> 节点在宕机后能够尽快恢复，并尽可能避免全量同步。<code>repl_backlog</code> 是一个环形缓冲区，用于存储 <code>master</code> 节点最近执行的命令，<code>slave</code> 节点可以通过这个缓冲区进行增量同步，从而避免全量同步。</li><li><strong>限制 slave 节点数量：</strong> 限制单个 <code>master</code> 节点上的 <code>slave</code> 节点数量。如果 <code>slave</code> 节点过多，可以采用 “主 - 从 - 从” 链式结构，以减轻 <code>master</code> 节点的压力。</li></ul><img src="'+k+'" alt="1.分布式缓存-20250807182355001" width="750" style="display:block;margin:auto;"><p>在 “主 - 从 - 从” 链式结构中，<code>master</code> 节点只需要将数据同步给 <code>slave1</code> 节点，然后 <code>slave1</code> 节点再将数据同步给 <code>slave2</code> 和 <code>slave3</code> 节点，以此来降低 <code>master</code> 节点的压力。这种方式通过分担主节点的同步压力，提高了整个集群的性能和可用性。</p><h2 id="_1-3-redis-哨兵" tabindex="-1"><a class="header-anchor" href="#_1-3-redis-哨兵"><span>1.3 Redis 哨兵</span></a></h2><p>Redis 提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><h4 id="_1-3-1-集群结构和作用" tabindex="-1"><a class="header-anchor" href="#_1-3-1-集群结构和作用"><span>1.3.1 集群结构和作用</span></a></h4><p>哨兵的结构如图：</p><img src="'+v+'" alt="1.分布式缓存-20250807182727200" width="750" style="display:block;margin:auto;"><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查 master 和 slave 是否按预期工作。</li><li><strong>自动故障恢复</strong>：如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主。</li><li><strong>通知</strong>：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端。</li></ul><h4 id="_1-3-2-集群监控原理" tabindex="-1"><a class="header-anchor" href="#_1-3-2-集群监控原理"><span>1.3.2 集群监控原理</span></a></h4><p>Sentinel 基于心跳机制监测服务状态，每隔 1 秒向集群的每个实例发送 ping 命令：</p><ul><li><strong>主观下线</strong>：如果某 sentinel 节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li><strong>客观下线</strong>：若超过指定数量（<code>quorum</code>）的 sentinel 都认为该实例主观下线，则该实例<strong>客观下线</strong>。<code>quorum</code> 值最好超过 Sentinel 实例数量的一半。 <img src="'+u+'" alt="1.分布式缓存-20250807182907041" width="750" style="display:block;margin:auto;"></li></ul><h4 id="_1-3-3-集群故障恢复原理" tabindex="-1"><a class="header-anchor" href="#_1-3-3-集群故障恢复原理"><span>1.3.3 集群故障恢复原理</span></a></h4><p>当 Sentinel 监测到 Master 节点发生故障时，它会启动故障转移过程，从 Slave 节点中选举出一个新的 Master 节点。选举过程依据以下优先级顺序：</p><ol><li><strong>断开连接时长：</strong> 优先排除与原 Master 节点断开时间过长的 Slave 节点。断开时长的阈值为 <code>down-after-milliseconds * 10</code>。</li><li><strong>Slave 优先级：</strong> 检查 Slave 节点的 <code>slave-priority</code> 配置值。<code>slave-priority</code> 值越小，优先级越高。如果设置为 0，则该 Slave 节点永远不会参与选举。</li><li><strong>Offset 值：</strong> 如果 <code>slave-priority</code> 值相同，则比较 Slave 节点的 Offset 值。Offset 值越大，表示数据越新，优先级越高。</li><li><strong>运行 ID：</strong> 如果 Offset 值也相同，则比较 Slave 节点的运行 ID 大小。运行 ID 越小，优先级越高。</li></ol><p>确定新的 Master 节点后，Sentinel 将执行以下步骤完成切换：</p><p>假设 <code>slave1</code> 被选举为新的 Master 节点，其端口为 7002，切换流程如下：</p><ol><li><strong>提升为 Master：</strong> Sentinel 向备选的 <code>slave1</code> 节点发送 <code>slaveof no one</code> 命令，使其从 Slave 节点提升为 Master 节点，不再从任何 Master 节点同步数据。</li><li><strong>更新 Slave 节点：</strong> Sentinel 向所有其他的 Slave 节点发送 <code>slaveof &lt;ip&gt; 7002</code> 命令，使它们成为新 Master (<code>slave1</code>) 的 Slave 节点，开始从新的 Master 节点同步数据。</li><li><strong>故障节点处理：</strong> Sentinel 将发生故障的原 Master 节点标记为 Slave 节点。当该节点恢复后，会自动成为新的 Master 节点的 Slave 节点。 <img src="'+b+'" alt="1.分布式缓存-20250807183442389" width="750" style="display:block;margin:auto;"></li></ol><h2 id="_1-4-redis-分片集群" tabindex="-1"><a class="header-anchor" href="#_1-4-redis-分片集群"><span>1.4 Redis 分片集群</span></a></h2><h3 id="_1-4-1-分片集群" tabindex="-1"><a class="header-anchor" href="#_1-4-1-分片集群"><span>1.4.1 分片集群</span></a></h3><p>主从复制和哨兵机制虽然解决了 Redis 的高可用性和高并发读问题，但仍存在海量数据存储和高并发写能力的局限性。为应对这两个挑战，可以采用 <strong>分片集群（Sharded Cluster）</strong> 方案。</p><img src="'+m+`" alt="1.分布式缓存-20250807233100691" width="750" style="display:block;margin:auto;"><p>分片集群具有以下特点：</p><ul><li><strong>多 Master 节点</strong>：集群中包含多个 <code>master</code> 节点，每个 <code>master</code> 节点负责存储不同的数据子集。</li><li><strong>高可用性</strong>：每个 <code>master</code> 节点都可以配置一个或多个 <code>slave</code> 节点，以实现数据的冗余备份和故障切换，提升整体可用性。</li><li><strong>节点通信</strong>：<code>master</code> 节点之间通过 <code>PING</code> 命令相互监测彼此的健康状态，确保集群的正常运行。</li><li><strong>请求转发</strong>：客户端可以向集群中的任意节点发送请求，即使该节点不存储请求数据，请求也会被自动转发到负责存储该数据的正确节点。</li></ul><h3 id="_1-4-2-散列插槽-hash-slot" tabindex="-1"><a class="header-anchor" href="#_1-4-2-散列插槽-hash-slot"><span>1.4.2 散列插槽（Hash Slot）</span></a></h3><p>在 Redis 分片集群中，数据不是直接与节点绑定的，而是通过 <strong>散列插槽（Hash Slot）</strong> 机制进行管理。Redis 将整个键空间划分为 16384 个插槽，编号从 0 到 16383。每个 <code>master</code> 节点都会被 Redis 分配其中一部分插槽的所有权。</p><p>当数据 <code>key</code> 写入集群时，Redis 会根据 <code>key</code> 的有效部分计算其对应的插槽值。计算规则如下：</p><ul><li><strong>包含 <code>{}</code> 的 <code>key</code></strong>：如果 <code>key</code> 中包含 <code>&quot;{}&quot;</code> 且花括号内至少有一个字符，则花括号内的部分被视为有效部分，例如 <code>&quot;{itcast}num&quot;</code>，有效部分为 <code>&quot;itcast&quot;</code>。</li><li><strong>不包含 <code>{}</code> 的 <code>key</code></strong>：如果 <code>key</code> 中不包含 <code>&quot;{}&quot;</code>，则整个 <code>key</code> 都是有效部分，例如 <code>&quot;num&quot;</code>，有效部分为 <code>&quot;num&quot;</code>。</li></ul><p>插槽值的计算方法是：对 <code>key</code> 的有效部分执行 CRC16 算法得到一个哈希值，然后将该哈希值对 16384 取模，得到的结果即为该 <code>key</code> 对应的插槽值。通过这种方式，Redis 能够将不同的 <code>key</code> 分散到不同的插槽中，进而均匀分布到各个 <code>master</code> 节点上，实现了数据的水平扩展。</p><h3 id="_1-4-3-集群伸缩" tabindex="-1"><a class="header-anchor" href="#_1-4-3-集群伸缩"><span>1.4.3 集群伸缩</span></a></h3><p><code>redis-cli --cluster</code> 提供了丰富的功能来操作 Redis 集群，通过执行 <code>redis-cli --cluster help</code> 命令可以查看所有可用的集群命令。</p><h4 id="_1-4-3-1-需求分析" tabindex="-1"><a class="header-anchor" href="#_1-4-3-1-需求分析"><span>1.4.3.1 需求分析</span></a></h4><p>假设当前 Redis 集群配置如下，包含三个主节点和三个从节点：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>127.0.0.1</td><td>7001</td><td>master</td></tr><tr><td>127.0.0.1</td><td>7002</td><td>master</td></tr><tr><td>127.0.0.1</td><td>7003</td><td>master</td></tr><tr><td>127.0.0.1</td><td>8001</td><td>slave</td></tr><tr><td>127.0.0.1</td><td>8002</td><td>slave</td></tr><tr><td>127.0.0.1</td><td>8003</td><td>slave</td></tr></tbody></table><p>我们的目标是向集群中添加一个新的主节点，并确保某个特定的键（例如 <code>num</code>）能够存储到这个新节点上。具体步骤包括：</p><ol><li>启动一个新的 Redis 实例，端口为 7004。</li><li>将 7004 节点添加到现有集群中，并将其角色设置为 master 节点。</li><li>为 7004 节点分配插槽 (slots)，以便可以存储诸如 <code>num</code> 这样的键。</li></ol><p>这项任务涉及到两项核心功能：向集群添加新节点和将部分插槽重新分配给新节点。</p><h4 id="_1-4-3-2-创建新的-redis-实例" tabindex="-1"><a class="header-anchor" href="#_1-4-3-2-创建新的-redis-实例"><span>1.4.3.2 创建新的 Redis 实例</span></a></h4><p>首先，为新的 Redis 实例创建一个独立的文件夹：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">mkdir</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7004</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后，在该文件夹内编写 <code>redis.conf</code> 配置文件，以配置 7004 端口的 Redis 实例：</p><div class="language-ini line-numbers-mode" data-highlighter="shiki" data-ext="ini" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-ini"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">port 7004</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 开启集群功能</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cluster-enabled yes</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 节点心跳失败的超时时间，单位为毫秒</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cluster-node-timeout 5000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 绑定地址</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">bind 127.0.0.1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 集群的配置文件，用于记录集群状态、节点信息等</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">cluster-config-file nodes.conf</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 持久化文件存放目录</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">dir .\\</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 注册的实例 IP，用于在集群中广播本节点的 IP 地址</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">replica-announce-ip 127.0.0.1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 保护模式，yes 模式下，只有本地连接和配置文件中绑定的 IP 才能访问</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">protected-mode no</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 数据库数量</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">databases 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完成后，使用以下命令启动新的 Redis 实例：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-server</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 7004/redis.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_1-4-3-3-添加新节点到-redis-集群" tabindex="-1"><a class="header-anchor" href="#_1-4-3-3-添加新节点到-redis-集群"><span>1.4.3.3 添加新节点到 Redis 集群</span></a></h4><p>新的 Redis 实例启动后，需要使用 <code>redis-cli --cluster add-node</code> 命令将其添加到现有集群中。该命令的第一个参数是新节点的地址，第二个参数是集群中任意一个已存在节点的地址：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> add-node</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:7004</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:7001</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行此命令后，7004 节点将被添加到集群中。可以通过连接到集群中的任意一个节点（例如 7001）并执行 <code>cluster nodes</code> 命令来查看集群的当前状态：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7001</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> nodes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>输出信息中会包含 7004 节点，其角色默认为 <code>master</code>。然而，此时 7004 节点分配到的插槽数量为 0，这意味着它不能存储任何数据。例如，输出可能显示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>284f83b33d7b1794cb7893a7f335b6e935de6a07 127.0.0.1:7004@17004 master - 0 1754643918119 0 connected</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此行表示 7004 节点已连接，但没有分配任何插槽。</p><h4 id="_1-4-3-4-转移插槽" tabindex="-1"><a class="header-anchor" href="#_1-4-3-4-转移插槽"><span>1.4.3.4 转移插槽</span></a></h4><p>为了使新添加的 7004 节点能够存储数据，需要将一部分插槽从现有主节点迁移到 7004 节点。首先，我们需要确定目标键 <code>num</code> 对应的插槽。通过客户端尝试获取 <code>num</code> 键，Redis 集群会重定向到负责该插槽的节点，从而获取其插槽 ID：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">127.0.0.1:7002</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">get</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> num</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">-</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">&gt; </span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Redirected</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> to</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> slot</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> [2765] located at 127.0.0.1:7001</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">&quot;124&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述结果可知，<code>num</code> 键位于插槽 2765，当前由 127.0.0.1:7001 节点负责。为了让 <code>num</code> 存储到 7004 节点，需要将包含插槽 2765 的一部分插槽从 7001 节点转移到 7004 节点。</p><p>使用 <code>redis-cli --cluster reshard</code> 命令启动插槽迁移流程。连接到集群中的任意主节点（例如 7001）来执行此命令：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7001</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> reshard</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> 127.0.0.1:7001</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>该命令会进入交互式模式，引导用户完成插槽迁移。</p><ol><li><strong>确定要移动的插槽数量</strong>：系统会提示“How many slots do you want to move (from 1 to 16384)?”。我们计划移动 3000 个插槽，因此输入 <code>3000</code>。<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>How many slots do you want to move (from 1 to 16384)? 3000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>指定接收插槽的节点 ID</strong>：系统会提示“What is the receiving node ID?”。这里需要提供 7004 节点的 ID。可以通过 <code>redis-cli -p 7001 cluster nodes</code> 命令查看 7004 节点的 ID，然后粘贴到控制台。<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>What is the receiving node ID? 284f83b33d7b1794cb7893a7f335b6e935de6a07</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>指定插槽的源节点 ID</strong>：系统会询问插槽来自哪些源节点。 <ul><li>输入 <code>all</code> 表示从所有主节点均匀地迁移插槽。</li><li>输入具体的节点 ID 表示只从该节点迁移插槽。</li><li>输入 <code>done</code> 表示已输入所有源节点 ID。 由于我们希望从 7001 节点迁移插槽，因此输入 7001 节点的 ID，然后输入 <code>done</code>。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Please enter all the source node IDs.</span></span>
<span class="line"><span>  Type &#39;all&#39; to use all the nodes as source nodes for the hash slots.</span></span>
<span class="line"><span>  Type &#39;done&#39; once you entered all the source nodes IDs.</span></span>
<span class="line"><span>Source node #1: b04e83dbc31ac2200b5f6adc7e83e01d0cd6bb35</span></span>
<span class="line"><span>Source node #2: done</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>确认重分片计划</strong>：在显示了提议的重分片计划后，系统会询问是否继续执行：“Do you want to proceed with the proposed reshard plan (yes/no)?”。输入 <code>yes</code> 确认。<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Do you want to proceed with the proposed reshard plan (yes/no)? yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><p>完成上述步骤后，插槽迁移将开始执行。迁移完成后，再次使用 <code>redis-cli -p 7001 cluster nodes</code> 命令查看集群状态，可以看到 7004 节点的插槽数量已经变为约 3000 个（0-2999），这表示插槽已成功转移，目标达成：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>284f83b33d7b1794cb7893a7f335b6e935de6a07 127.0.0.1:7004@17004 master - 0 1754644622000 7 connected 0-2999</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_1-4-4-故障转移" tabindex="-1"><a class="header-anchor" href="#_1-4-4-故障转移"><span>1.4.4 故障转移</span></a></h3><p>本章节主要介绍 Redis 集群的故障转移机制，包括自动故障转移和手动故障转移。</p><h4 id="_1-4-4-1-自动故障转移" tabindex="-1"><a class="header-anchor" href="#_1-4-4-1-自动故障转移"><span>1.4.4.1 自动故障转移</span></a></h4><p>当集群中的一个主节点（master）发生宕机时，Redis 集群会自动进行故障转移。假设集群的初始状态如下：</p><table><thead><tr><th style="text-align:left;">IP</th><th style="text-align:left;">PORT</th><th style="text-align:left;">角色</th></tr></thead><tbody><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">7001</td><td style="text-align:left;">master</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">7002</td><td style="text-align:left;">master</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">7003</td><td style="text-align:left;">master</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">8001</td><td style="text-align:left;">slave</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">8002</td><td style="text-align:left;">slave</td></tr><tr><td style="text-align:left;">127.0.0.1</td><td style="text-align:left;">8003</td><td style="text-align:left;">slave</td></tr></tbody></table><p>如果主节点 7002 宕机，其自动故障转移流程如下：</p><ol><li><strong>连接丢失</strong>：宕机实例（7002）首先会与集群中的其他实例失去连接。</li><li><strong>疑似宕机（PFAIL）</strong>：集群中的其他节点会检测到 7002 节点不可达，并将其标记为“可能宕机”（PFAIL）。</li><li><strong>确定下线（FAIL）</strong>：当集群中半数以上的主节点都认为 7002 节点不可用时，它就会被标记为“确定下线”（FAIL）。</li><li><strong>自动提升</strong>：集群会自动从 7002 的从节点（slave）中选举一个，将其提升为新的主节点。</li><li><strong>角色转变</strong>：当原宕机的 7002 节点重新启动后，它会自动作为新主节点的从节点加入集群。</li></ol><p>通过执行以下命令可以模拟 7002 主节点宕机：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7002</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> shutdown</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_1-4-4-2-手动故障转移" tabindex="-1"><a class="header-anchor" href="#_1-4-4-2-手动故障转移"><span>1.4.4.2 手动故障转移</span></a></h4><p>除了自动故障转移，Redis 也支持通过 <code>CLUSTER FAILOVER</code> 命令进行手动故障转移。此命令允许将集群中某个主节点的角色“转移”给其对应的从节点，从而实现无感知的客户端连接切换和数据迁移。</p><p>手动故障转移的流程图解如下：</p>`,86)),a(i,{code:"eJylkM1OwkAUhfc+xbwATfxdsGDllrDgCSakGBJBpNU1QbAUxCjQhYjEGBMSlbYkhhaHysv0zowrX8HpT2IT4spZzj3nu+ceRT49kysF+bCEj2q4vIXEq+KaWiqUqriiojzCClKO8bm8McoGozJWVLm2McuFQ2gtwLyIJaEmn8pksmm0LUVM3mmwxhJuO9zSI1n0Q7t9Rh58QnzPAPOJth32anHLofNGiMmmBCefRjtSHICvh3A/AW8Aeo+NmtSwac88KRYVWWXk7jd/sF/4diXEZjp8tpJC372OYL5b59p7Ur8nIVjVYdqlRutrNObeG5uSOEl40N+CgJATin0J0UeNmzbXXsCZ++5HtOx7dQXLNe3Pkk5xAiMDOhknS/sHIexLIA4EYriAth0ZAmeYGp6b7OYy0TSJy/4BVOcOcA=="}),e[3]||(e[3]=s('<p>流程详情：</p><ol><li><strong>发起请求</strong>：从节点（slave）向其主节点（master）发送请求，告知主节点停止接受客户端写入请求。</li><li><strong>主节点响应</strong>：主节点返回当前的复制偏移量（replication offset）给从节点。</li><li><strong>数据同步</strong>：从节点等待，直到其复制偏移量与主节点的偏移量完全一致，确保数据完全同步。</li><li><strong>开始转移</strong>：从节点和主节点同时开始执行故障转移逻辑。</li><li><strong>角色切换</strong>：从节点将自己标记为新的主节点，并向集群中的其他主节点广播故障转移的结果。它也会向原主节点发送广播，告知其现在应作为从节点。</li><li><strong>处理读请求</strong>：其他收到广播的主节点会更新集群配置，并将对原主节点的读请求重定向到新的主节点。原主节点收到通知后，也会开始作为从节点处理读请求（不再接受写请求）。</li></ol><p><code>CLUSTER FAILOVER</code> 命令支持三种模式：</p><ul><li><strong>缺省（Default）</strong>：按照上述完整流程执行，包括数据一致性校验。</li><li><strong><code>FORCE</code></strong>：强制模式，省略了对数据偏移量（offset）一致性的校验，即使数据未完全同步也进行故障转移。这可能导致少量数据丢失，但在紧急情况下可以更快地完成转移。</li><li><strong><code>TAKEOVER</code></strong>：接管模式，直接执行第 5 步（将自己标记为 master 并广播），忽略数据一致性、忽略原主节点的状态以及其他主节点的意见。这种模式风险最高，通常用于特定运维场景，可能导致数据不一致和集群混乱。</li></ul><p>假设在之前的自动故障转移后，7002 已经变为了从节点。我们希望 7002 重新成为主节点。</p><p>执行步骤如下：</p><ol><li>通过 <code>redis-cli</code> 连接到 7002 节点。</li><li>执行 <code>CLUSTER FAILOVER</code> 命令。</li></ol><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-shell"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">redis-cli</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -p</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 7002</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> cluster</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> failover</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行效果展示了 7002 节点已经成功成为主节点，并显示其新的集群信息：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>c57872aef079f96eecde34aaf5e16c6bcdd2f360 127.0.0.1:7002@17002 master - 0 1754646722000 10 connected 5461-10922</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这表明 7002 节点成功重新变为 master 节点，并且负责管理哈希槽范围 5461-10922。</p>',11))])}const B=l(f,[["render",y]]),E=JSON.parse('{"path":"/notes/HMRedis/wynrwt9h/","title":"分布式缓存","lang":"zh-CN","frontmatter":{"title":"分布式缓存","createTime":"2025/08/07 15:28:46","permalink":"/notes/HMRedis/wynrwt9h/"},"readingTime":{"minutes":24.18,"words":7255},"git":{"createdTime":1754648613000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/黑马程序员Redis/3.高级篇/1.分布式缓存.md","headers":[]}');export{B as comp,E as data};
