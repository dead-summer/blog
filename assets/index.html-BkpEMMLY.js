import{a as n,c as e,b as s,d as l,r as t,o as h}from"./app-CAzY0Upz.js";const d={};function r(p,i){const a=t("Mermaid");return h(),e("div",null,[i[0]||(i[0]=s('<h2 id="mesi-协议" tabindex="-1"><a class="header-anchor" href="#mesi-协议"><span>MESI 协议</span></a></h2><p>MESI 协议（Modified、Exclusive、Shared、Invalid）是一种缓存一致性协议，用于确保多处理器系统中各 CPU 缓存中共享变量副本的一致性。</p><ul><li><strong>Modified (M)</strong>：缓存行已被当前 CPU 修改，与主内存不一致</li><li><strong>Exclusive (E)</strong>：缓存行仅被当前 CPU 持有，与主内存一致</li><li><strong>Shared (S)</strong>：缓存行被多个 CPU 共享，与主内存一致</li><li><strong>Invalid (I)</strong>：缓存行数据无效</li></ul><p>其核心思想是：</p><ul><li>当 CPU 执行写操作时，如果操作对象是共享变量（即其他 CPU 缓存中存在该变量的副本），会发出信号通知其他 CPU 将该变量的缓存行置为无效状态。</li><li>当其他 CPU 读取该变量时，发现其缓存行无效，则直接从主内存重新加载数据，从而保证数据一致性。</li></ul><h2 id="jmm-核心定义" tabindex="-1"><a class="header-anchor" href="#jmm-核心定义"><span>JMM 核心定义</span></a></h2><h3 id="目标与问题域" tabindex="-1"><a class="header-anchor" href="#目标与问题域"><span>目标与问题域</span></a></h3><p>在 JMM 中，内存分为两类区域：</p><table><thead><tr><th>区域</th><th>特性</th><th>作用</th></tr></thead><tbody><tr><td><strong>主内存</strong></td><td>线程共享</td><td>存储所有共享变量</td></tr><tr><td><strong>工作内存</strong></td><td>线程私有</td><td>存储主内存变量的副本</td></tr></tbody></table><p>工作模式遵循以下流程：</p><ol><li>线程操作共享变量时，先将变量从主内存拷贝到工作内存。</li><li>在线程工作内存中对副本执行操作。</li><li>操作完成后，将最新值刷新回主内存。</li></ol>',11)),l(a,{code:"eJxLL0osyFDwCeJSAALH6Cc7dj9ta326dkasgq6uXc2L9buf9k+rUXCKfrp96ZO9c6ByYMVOEBXrFj5fN/3J/nXPpuwEqkOSedo28+nseTUKjlwABJ8tUQ=="}),i[1]||(i[1]=s(`<h2 id="三大特性与解决方案" tabindex="-1"><a class="header-anchor" href="#三大特性与解决方案"><span>三大特性与解决方案</span></a></h2><p>JMM 通过封装底层内存操作细节（如 MESI 协议、内存屏障），为开发者提供 <code>synchronized</code>、<code>volatile</code> 等抽象工具，解决多线程并发中的原子性、可见性、有序性问题。</p><h3 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性"><span>原子性</span></a></h3><h4 id="问题描述" tabindex="-1"><a class="header-anchor" href="#问题描述"><span>问题描述</span></a></h4><p>原子性问题指在多线程并发场景下，非原子操作可能因线程切换或竞争导致最终结果与预期不一致。典型案例如下：</p><ul><li><strong><code>i++</code> 非原子操作</strong>：该操作包含读取变量值、执行加法运算、写回新值三个子步骤。若多个线程同时执行，可能因线程交替执行导致最终结果错误。</li></ul><h4 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h4><p>使用 <code>synchronized</code> 关键字实现同步控制：</p><ul><li><code>synchronized</code> 通过内置锁（Monitor）机制，将代码块或方法封装为临界区（Critical Section），保证同一时刻仅有一个线程可以执行该区域内的代码。</li><li>从而确保操作的原子性，避免多线程并发导致的数据不一致。</li></ul><h3 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性"><span>可见性</span></a></h3><h4 id="问题描述-1" tabindex="-1"><a class="header-anchor" href="#问题描述-1"><span>问题描述</span></a></h4><p>可见性问题指某一线程对共享变量的修改，未能及时被其他线程感知，导致线程间数据状态不一致。其主要成因包括：</p><ol><li>线程修改变量后，仅更新其工作内存（线程私有缓存），未立即刷回主内存。</li><li>其他线程仍从自身的工作内存中读取旧值，而非从主内存获取最新值。</li></ol><h4 id="解决方案-1" tabindex="-1"><a class="header-anchor" href="#解决方案-1"><span>解决方案</span></a></h4><p>使用 <code>volatile</code> 关键字强制保证变量的可见性。</p><ul><li>写入 <code>volatile</code> 变量时，JVM 会向处理器发送 <code>lock</code> 前缀指令，强制将当前处理器缓存行的数据立即写回主内存，并触发缓存一致性协议（如 MESI）。</li><li>其他处理器通过嗅探机制（Snooping）监测到该写操作，会使本地缓存中对应缓存行失效，迫使后续读取必须从主内存重新加载最新数据。</li></ul><h3 id="有序性" tabindex="-1"><a class="header-anchor" href="#有序性"><span>有序性</span></a></h3><h4 id="问题描述-2" tabindex="-1"><a class="header-anchor" href="#问题描述-2"><span>问题描述</span></a></h4><p>有序性问题指编译器或处理器为提高性能，可能对指令进行重排序（Reordering）。虽然在单线程环境下能保证最终结果一致，但在多线程并发中可能导致逻辑错误。典型案例如下：</p><ul><li><strong>双重检查锁定（DCL）单例模式</strong>：若实例变量未声明为 <code>volatile</code>，可能因指令重排序导致其他线程获取到未完全初始化的对象。</li></ul><h4 id="解决方案-2" tabindex="-1"><a class="header-anchor" href="#解决方案-2"><span>解决方案</span></a></h4><p>使用 <code>volatile</code> 关键字禁止指令重排序。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Singleton</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> volatile</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Singleton</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> instance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Singleton </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getInstance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">		if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">instance </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                    // 第一次检查</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">			synchronized</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Singleton</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">class</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">				if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">instance </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">            // 第二次检查</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">					instance </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Singleton</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // volatile 禁止重排序</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">				}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">			}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">		}</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">		return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> instance</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>volatile</code> 通过在指令序列中插入内存屏障（Memory Barrier）来限制重排序行为。内存屏障是一种 CPU 指令，用于阻止屏障前后的指令进行重排序。</li><li>JVM 会在编译期和运行期自动插入以下类型的内存屏障： <ul><li>写操作前插入 <code>StoreStore</code> 屏障</li><li>写操作后插入 <code>StoreLoad</code> 屏障</li><li>读操作后插入 <code>LoadLoad</code> 和 <code>LoadStore</code> 屏障 通过这些屏障，确保对 <code>volatile</code> 变量的读写操作按程序顺序执行，从而维护多线程环境下的有序性。</li></ul></li></ul>`,24))])}const o=n(d,[["render",r]]),c=JSON.parse('{"path":"/notes/interview/6mr50ol4/","title":"Java内存模型","lang":"zh-CN","frontmatter":{"title":"Java内存模型","createTime":"2025/08/26 17:27:21","permalink":"/notes/interview/6mr50ol4/"},"readingTime":{"minutes":4.02,"words":1207},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/Java内存模型.md","headers":[]}');export{o as comp,c as data};
