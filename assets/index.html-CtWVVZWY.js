import{a as o,c as t,b as l,o as d}from"./app-CAzY0Upz.js";const s={};function i(a,e){return d(),t("div",null,e[0]||(e[0]=[l('<p>Redis 的内存淘汰策略（Eviction Policies）用于在内存达到 <code>maxmemory</code> 配置的上限时，决定如何释放内存以存储新的数据。</p><h4 id="策略分类" tabindex="-1"><a class="header-anchor" href="#策略分类"><span>策略分类</span></a></h4><p>内存淘汰策略主要分为两类：针对设置了过期时间（TTL）的 Key 进行淘汰，以及针对所有 Key 进行淘汰。</p><ol><li><p><strong>只针对设置了过期时间（TTL）的 Key 进行淘汰：</strong></p><ul><li><strong><code>volatile-lru</code> (Least Recently Used)</strong>：从所有设置了过期时间的 Key 中，淘汰最近最少使用的 Key。</li><li><strong><code>volatile-fgu</code> (Least Frequently Used)</strong>：从所有设置了过期时间的 Key 中，淘汰访问频率最低的 Key。</li><li><strong><code>volatile-random</code></strong>：从所有设置了过期时间的 Key 中，随机选择一个 Key 进行删除。</li><li><strong><code>volatile-ttl</code></strong>：从所有设置了过期时间的 Key 中，选择剩余生存时间（Time To Live）最短的 Key 进行删除。</li></ul></li><li><p><strong>针对所有 Key 进行淘汰：</strong></p><ul><li><strong><code>allkeys-lru</code> (Least Recently Used)</strong>：从所有 Key 中，淘汰最近最少使用的 Key。判断依据是 Key 的最后一次访问时间。</li><li><strong><code>allkeys-lfu</code> (Least Frequently Used)</strong>：从所有 Key 中，淘汰访问频率最低的 Key。判断依据是 Key 的访问次数统计。</li><li><strong><code>allkeys-random</code></strong>： 从所有 Key 中，随机选择一个 Key 进行删除。</li></ul></li></ol><p><strong>3. 不淘汰策略：</strong></p><ul><li><strong><code>noeviction</code></strong>：当内存使用达到 <code>maxmemory</code> 上限时，不淘汰任何 Key。对于写操作（如 <code>SET</code>、<code>LPUSH</code> 等），Redis 会直接返回错误信息。读操作（如 <code>GET</code>）仍然可用。</li></ul><h2 id="策略选择建议" tabindex="-1"><a class="header-anchor" href="#策略选择建议"><span>策略选择建议</span></a></h2><p>选择合适的内存淘汰策略取决于具体的应用场景和数据特性。</p><ul><li><strong>纯缓存场景</strong>：如果 Redis 主要用作缓存，且所有数据都可以被淘汰，建议使用 <code>allkeys-lru</code> 或 <code>allkeys-lfu</code>。这可以最大化缓存命中率，并避免因内存写满导致的服务不可用。<code>allkeys-lru</code> 更侧重于新数据的接收，而 <code>allkeys-fgu</code> 更侧重于热点数据的保留。</li><li><strong>混合数据场景</strong>（部分数据需要长期保存）：如果 Redis 中存在一部分数据是永久性的（未设置过期时间），而另一部分数据是可淘汰的（设置了过期时间），则应使用 <code>volatile-lru</code> 或 <code>volatile-lfu</code>。这样可以确保关键的、未设置过期时间的数据不会被误删。</li><li><strong>严格数据保护场景</strong>：如果对数据丢失有非常严格的要求，即使内存写满也绝不允许自动淘汰任何数据，则应使用 <code>noeviction</code> 策略。但在此策略下，务必配合完善的内存监控和扩容机制，以避免因内存不足导致写入失败。</li></ul><h2 id="内存淘汰流程" tabindex="-1"><a class="header-anchor" href="#内存淘汰流程"><span>内存淘汰流程</span></a></h2><p>当客户端执行写入命令时，Redis 会触发内存检查和淘汰流程：</p><ol><li><strong>触发内存检查</strong>：客户端执行写入命令（如 <code>SET</code>、<code>LPUSH</code>）时，Redis 检查当前内存使用量是否超出 <code>maxmemory</code>（配置文件定义的值）。</li><li><strong>根据策略选择待淘汰键</strong>：如果内存超出限制，Redis 会根据配置的内存淘汰策略，从数据集中选择一个或多个 Key 进行淘汰。</li><li><strong>删除键并触发事件</strong>：被选中的 Key 将从数据集中删除。同时，Redis 会触发相关的事件通知，例如通过 <code>Keyspace Notifications</code> 发布 <code>evicted</code> 事件，通知客户端该 Key 已被淘汰。</li></ol>',12)]))}const c=o(s,[["render",i]]),n=JSON.parse('{"path":"/notes/interview/g7wi5f13/","title":"内存淘汰策略","lang":"zh-CN","frontmatter":{"title":"内存淘汰策略","createTime":"2025/09/01 16:39:01","permalink":"/notes/interview/g7wi5f13/"},"readingTime":{"minutes":2.84,"words":852},"git":{"createdTime":1756721248000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Redis/内存淘汰策略.md","headers":[]}');export{c as comp,n as data};
