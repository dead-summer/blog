import{a,c as e,b as n,o as i}from"./app-CAzY0Upz.js";const t={};function p(l,s){return i(),e("div",null,s[0]||(s[0]=[n(`<h2 id="string-底层数据类型" tabindex="-1"><a class="header-anchor" href="#string-底层数据类型"><span>String 底层数据类型</span></a></h2><p>在不同的 JDK 版本中，<code>String</code> 底层数据类型的实现有所不同：</p><ul><li><p><strong>JDK 8 及以前版本</strong>：<code>String</code> 底层使用 <code>char</code> 类型的数组存储字符序列。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> char</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种实现方式在处理非 ASCII 字符时，每个字符占用两个字节，即使是 ASCII 字符也占用两个字节，可能导致内存空间的浪费。</p></li><li><p><strong>JDK 9 及以后版本</strong>：<code>String</code> 底层改用 <code>byte</code> 类型的数组存储字符序列，并增加了一个 <code>coder</code> 字段来标识编码格式（<code>LATIN1</code> 或 <code>UTF16</code>）。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> byte</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> byte</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> coder</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 0 for LATIN1, 1 for UTF16</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种优化被称为 Compact Strings。对于只包含 Latin-1 字符（即 ASCII 字符和扩展 ASCII 字符，占用一个字节）的字符串，<code>String</code> 会使用 <code>LATIN1</code> 编码，每个字符占用一个字节，从而节省内存。对于包含非 Latin-1 字符的字符串，则使用 <code>UTF16</code> 编码，每个字符占用两个字节。</p></li></ul><h2 id="string-的不可变性实现原理" tabindex="-1"><a class="header-anchor" href="#string-的不可变性实现原理"><span>String 的不可变性实现原理</span></a></h2><p><code>String</code> 对象的不可变性（Immutable）是指 <code>String</code> 对象一旦创建，其内部的字符序列就不能被改变。其实现原理如下：</p><ol><li><p><strong>底层存储数组被 <code>final</code> 和 <code>private</code> 修饰</strong>： 存储字符序列的数组都 <code>final</code> 和 <code>private</code> 关键字修饰。</p><ul><li><code>private</code> 确保了 <code>value</code> 数组不能被外部直接访问。</li><li><code>final</code> 确保了 <code>value</code> 引用一旦初始化后就不能指向其他数组对象。虽然 <code>final</code> 数组本身的内容是可变的，但 <code>String</code> 类并没有提供改变 <code>value</code> 数组内容的方法。</li></ul></li><li><p><strong>没有提供修改字符串内容的方法</strong>： <code>String</code> 类本身没有提供任何公共方法来修改 <code>value</code> 数组中的字符或字节。所有看似修改 <code>String</code> 对象的操作（如 <code>concat()</code>、<code>substring()</code>、<code>replace()</code> 等）实际上都是创建并返回一个新的 <code>String</code> 对象，而原 <code>String</code> 对象保持不变。</p></li><li><p><strong><code>String</code> 类不能被继承</strong>： <code>String</code> 类被 <code>final</code> 修饰，这意味着它不能被继承。这进一步保证了其不可变性，因为如果 <code>String</code> 可以被继承，子类可能会重写方法或引入新的行为来修改字符串内容，从而破坏 <code>String</code> 的不可变性。</p></li></ol><h2 id="string-存储的长度限制" tabindex="-1"><a class="header-anchor" href="#string-存储的长度限制"><span>String 存储的长度限制</span></a></h2><p><code>String</code> 存储的长度存在限制，但这个限制在编译期和运行期有所不同：</p><ol><li><p><strong>编译期限制</strong>： 在 Java 编译时，字符串常量被存储在字节码文件的常量池中。<code>CONSTANT_Utf8_info</code> 结构用于表示字符串常量的值。这个结构使用 <code>u2 length</code> 字段来表示字符串的 UTF-8 编码字节长度，其最大值为 65535（即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{16}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）。 因此，在编译期，一个单独的字符串字面量（例如 <code>String s = &quot;...&quot;</code>）的长度不能超过 65535 个字节（注意是字节长度，不是字符长度）。</p></li><li><p><strong>运行期限制</strong>： 在运行期，<code>String</code> 对象的实际长度由其内部 <code>value</code> 数组的长度决定。<code>String</code> 类的 <code>length()</code> 方法返回的是 <code>value</code> 数组的长度，而这个长度是用 <code>int</code> 类型表示的。 <code>int</code> 类型的最大值为 <code>Integer.MAX_VALUE</code>，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。因此，理论上 <code>String</code> 对象在运行期可以存储的最大字符数是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。 然而，实际能够创建的 <code>String</code> 对象长度还会受到 Java 虚拟机（JVM）可用内存的限制。</p></li></ol>`,9)]))}const o=a(t,[["render",p]]),d=JSON.parse('{"path":"/notes/interview/8sblk5d2/","title":"String","lang":"zh-CN","frontmatter":{"title":"String","createTime":"2025/09/04 16:24:33","permalink":"/notes/interview/8sblk5d2/"},"readingTime":{"minutes":2.9,"words":869},"git":{"createdTime":1757065260000,"updatedTime":1757065260000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/Java基础/String.md","headers":[]}');export{o as comp,d as data};
