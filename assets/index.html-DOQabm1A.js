import{a,c as i,b as s,o as t}from"./app-CAzY0Upz.js";const d={};function l(o,e){return t(),i("div",null,e[0]||(e[0]=[s('<h2 id="_1-1-什么是集合-collection" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是集合-collection"><span>1.1 什么是集合（Collection）？</span></a></h2><p>集合是由若干个确定的元素构成的整体。在计算机中引入集合是为了便于处理一组类似的数据。</p><p>Java 的数组可以看作是一种集合，但数组存在以下限制：</p><ul><li>数组初始化后大小不可变。</li><li>数组只能按索引顺序存取。</li></ul><p>因此，我们需要各种不同类型的集合类来处理不同的数据。</p><h2 id="_1-2-collection-接口" tabindex="-1"><a class="header-anchor" href="#_1-2-collection-接口"><span>1.2 <code>Collection</code> 接口</span></a></h2><p>Java 标准库 <code>java.util</code> 包提供了集合类 <code>Collection</code>，它是除 <code>Map</code> 外所有其他集合类的根接口。<code>java.util</code> 包主要提供了以下三种类型的集合：</p><ul><li><code>List</code>：一种有序列表的集合，例如，按索引排列的 <code>Student</code> 的 <code>List</code>。</li><li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的 <code>Student</code> 的 <code>Set</code>。</li><li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据 <code>Student</code> 的 <code>name</code> 查找对应 <code>Student</code> 的 <code>Map</code>。</li></ul><h2 id="_1-3-java-集合的设计特点" tabindex="-1"><a class="header-anchor" href="#_1-3-java-集合的设计特点"><span>1.3 Java 集合的设计特点</span></a></h2><ol><li><p>接口和实现类相分离：例如，有序表的接口是 <code>List</code>，具体的实现类有 <code>ArrayList</code>，<code>LinkedList</code> 等。</p></li><li><p>支持泛型：可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> list</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ArrayList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 只能放入 String 类型</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>统一的访问方式：Java 访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p></li></ol><h2 id="_1-4-遗留类和接口" tabindex="-1"><a class="header-anchor" href="#_1-4-遗留类和接口"><span>1.4 遗留类和接口</span></a></h2><p>由于 Java 的集合设计非常久远，中间经历过大规模改进，要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code>Hashtable</code>：一种线程安全的 <code>Map</code> 实现。</li><li><code>Vector</code>：一种线程安全的 <code>List</code> 实现。</li><li><code>Stack</code>：基于 <code>Vector</code> 实现的 <code>LIFO</code> 的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code>Enumeration&lt;E&gt;</code>：已被 <code>Iterator&lt;E&gt;</code> 取代。</li></ul>',15)]))}const n=a(d,[["render",l]]),r=JSON.parse('{"path":"/notes/LXFJava/ppjyqpwj/","title":"Java集合简介","lang":"zh-CN","frontmatter":{"title":"Java集合简介","createTime":"2025/07/18 17:55:13","permalink":"/notes/LXFJava/ppjyqpwj/"},"readingTime":{"minutes":1.7,"words":510},"git":{"createdTime":1752909749000,"updatedTime":1752909749000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/廖雪峰Java/8.集合/1.Java集合简介.md","headers":[]}');export{n as comp,r as data};
