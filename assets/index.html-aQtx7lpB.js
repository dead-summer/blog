import{a as i,c as n,b as r,o as t}from"./app-CAzY0Upz.js";const a={};function o(s,l){return t(),n("div",null,l[0]||(l[0]=[r('<h2 id="垃圾的定义" tabindex="-1"><a class="header-anchor" href="#垃圾的定义"><span>垃圾的定义</span></a></h2><p>在 Java 中，垃圾是指 <strong>不再被任何活跃的引用所指向的对象</strong>，即该对象无法再被程序访问或使用，可以被回收以释放内存空间。</p><h3 id="判断对象是否为垃圾的方法" tabindex="-1"><a class="header-anchor" href="#判断对象是否为垃圾的方法"><span>判断对象是否为垃圾的方法</span></a></h3><ol><li><p><strong>引用计数法（Reference Counting）</strong></p><ul><li><strong>原理</strong>：每个对象维护一个引用计数器，每当有引用指向该对象时计数加 1，引用失效时计数减 1。计数为 0 时判定为垃圾。</li><li><strong>缺点</strong>：无法解决 <strong>循环引用</strong> 的问题，即两个对象互相引用，但均未被外部引用，仍会占用内存不被回收。</li></ul></li><li><p><strong>根可达性分析（GC Roots Reachability Analysis）</strong></p><ul><li><strong>原理</strong>：以一系列称为“GC Roots”的对象为起点，从这些对象开始进行图遍历，所有能被访问到的对象都为存活对象，其余未被访问到的对象则为垃圾。</li><li>常见的 GC Roots 包括： <ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（Native 方法）引用的对象</li></ul></li></ul></li></ol><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h2><h3 id="标记-清除-mark-sweep" tabindex="-1"><a class="header-anchor" href="#标记-清除-mark-sweep"><span>标记 - 清除（Mark-Sweep）</span></a></h3><ul><li><strong>过程</strong>： <ul><li>标记阶段：标记所有存活对象。</li><li>清除阶段：清除未被标记的对象。</li></ul></li><li><strong>优点</strong>：实现简单，效率较高。</li><li><strong>缺点</strong>： <ul><li>产生 <strong>内存碎片</strong>，可能导致后续分配大对象时无法找到连续空间，引发 Full GC。</li><li>清除后空闲空间非连续，影响后续性能。</li></ul></li></ul><h3 id="标记-整理-mark-compact" tabindex="-1"><a class="header-anchor" href="#标记-整理-mark-compact"><span>标记 - 整理（Mark-Compact）</span></a></h3><ul><li><strong>过程</strong>： <ul><li>标记阶段：标记所有存活对象。</li><li>整理阶段：将存活对象向内存一端移动，然后清理边界以外的空间。</li></ul></li><li><strong>优点</strong>：避免内存碎片，空间更规整，有利于后续内存分配。</li><li><strong>缺点</strong>：整理阶段需要移动对象，效率低于标记清除算法。</li></ul><h3 id="复制-copying" tabindex="-1"><a class="header-anchor" href="#复制-copying"><span>复制（Copying）</span></a></h3><ul><li><strong>过程</strong>： <ul><li>将内存划分为大小相等的两块区域，每次只使用一块。</li><li>标记存活对象后，将它们复制到另一块区域，然后清空当前块。</li></ul></li><li><strong>优点</strong>： <ul><li>无内存碎片。</li><li>实现高效，适合高回收频率的区域。</li></ul></li><li><strong>缺点</strong>：内存利用率低，需要两倍的内存空间。</li></ul><h2 id="分代垃圾回收机制-generational-garbage-collection" tabindex="-1"><a class="header-anchor" href="#分代垃圾回收机制-generational-garbage-collection"><span>分代垃圾回收机制（Generational Garbage Collection）</span></a></h2><p>Java 堆内存按照对象的生命周期划分为 <strong>年轻代（Young Generation）</strong> 和 <strong>老年代（Old Generation）</strong>。</p><h3 id="年轻代-young-generation" tabindex="-1"><a class="header-anchor" href="#年轻代-young-generation"><span>年轻代（Young Generation）</span></a></h3><ul><li><strong>对象生命周期</strong>：大多数对象是“朝生夕死”。</li><li><strong>GC 类型</strong>：Minor GC。</li><li><strong>常用算法</strong>：复制算法（Copying），因为对象存活率低，复制成本小。</li><li><strong>结构</strong>： <ul><li>Eden 区</li><li>From Survivor 区</li><li>To Survivor 区</li></ul></li></ul><h3 id="老年代-old-generation" tabindex="-1"><a class="header-anchor" href="#老年代-old-generation"><span>老年代（Old Generation）</span></a></h3><ul><li><strong>对象生命周期</strong>：对象存活时间较长。</li><li><strong>GC 类型</strong>：Major GC 或 Full GC。</li><li><strong>常用算法</strong>：标记 - 整理（Mark-Compact）或标记 - 清除（Mark-Sweep）。 <ul><li>标记 - 整理用于避免内存碎片。</li><li>标记 - 清除用于提高效率，但需配合内存整理策略使用。</li></ul></li></ul><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器"><span>垃圾回收器</span></a></h2><p>垃圾回收器（Garbage Collector, GC）是 Java 虚拟机的核心组件，用于自动管理堆内存，回收无用对象以释放空间。下将重点介绍两种面向低延迟场景的垃圾回收器：CMS（Concurrent Mark Sweep）和 G1（Garbage-First）。</p><table><thead><tr><th>特性</th><th>CMS</th><th>G1</th></tr></thead><tbody><tr><td>算法类型</td><td>标记 - 清除</td><td>标记 - 整理（分区复制）</td></tr><tr><td>堆结构</td><td>分代式（老年代、新生代）</td><td>分区式（Region-based，可动态分配）</td></tr><tr><td>STW 时间控制</td><td>不可控，依赖堆大小和对象数量</td><td>可控，支持设定最大停顿时间目标</td></tr><tr><td>内存碎片问题</td><td>存在，需额外配置参数应对</td><td>不存在，回收时整理内存</td></tr><tr><td>浮动垃圾处理</td><td>存在并发模式失败风险</td><td>更优，回收策略可动态调整</td></tr><tr><td>适用场景</td><td>对延迟要求高、堆内存较小（如 4~6GB）</td><td>大堆内存、高吞吐、低延迟、可预测 GC 暂停</td></tr></tbody></table><h3 id="cms-concurrent-mark-sweep" tabindex="-1"><a class="header-anchor" href="#cms-concurrent-mark-sweep"><span>CMS（Concurrent Mark Sweep）</span></a></h3><p>CMS 垃圾回收器的设计目标是<strong>响应时间优先</strong>，旨在<strong>减少 Stop-The-World (STW)</strong> 的发生时间与频率，适用于对<strong>低延迟和低停顿敏感的应用系统</strong>，如 Web 服务、交易系统等。</p><h4 id="cms-垃圾回收过程" tabindex="-1"><a class="header-anchor" href="#cms-垃圾回收过程"><span>CMS 垃圾回收过程</span></a></h4><p>CMS 是一款基于<strong>标记 - 清除算法</strong>的老年代回收器，其垃圾回收过程分为以下四个阶段：</p><ol><li><p><strong>初始标记（Initial Mark）</strong></p><ul><li>需要 STW。</li><li>该阶段仅标记与 GC Roots 直接关联的存活对象，耗时较短。</li></ul></li><li><p><strong>并发标记（Concurrent Mark）</strong></p><ul><li>与用户线程并发执行。</li><li>从初始标记的对象出发，遍历整个对象图，标记所有可达对象。</li><li>此阶段可以与应用程序同时运行，减少整体停顿。</li></ul></li><li><p><strong>重新标记（Remark）</strong></p><ul><li>需要 STW。</li><li>修复在并发标记阶段由于用户线程运行而导致的引用关系变化，确保最终标记准确。</li><li>此阶段耗时较长，但通常优于标记 - 整理算法的停顿时间。</li></ul></li><li><p><strong>并发清理（Concurrent Sweep）</strong></p><ul><li>与用户线程并发执行。</li><li>清理未被标记的对象，即垃圾对象，释放内存。</li><li>此阶段不整理内存空间，仅进行清除。</li></ul></li></ol><div class="hint-container question"><p class="hint-container-title">CMS 如何实现响应时间优先，其 STW 时间为什么很短？</p><ul><li><strong>并发标记与并发清理阶段</strong>：CMS 在这两个阶段允许垃圾回收线程与用户线程同时运行，大幅减少 GC 停顿时间。</li><li><strong>采用标记 - 清除算法</strong>：该算法相较于标记 - 整理算法执行速度更快，避免了内存整理带来的额外开销。</li></ul></div><h4 id="cms-的主要弊端" tabindex="-1"><a class="header-anchor" href="#cms-的主要弊端"><span>CMS 的主要弊端</span></a></h4><ol><li><p><strong>内存碎片问题</strong></p><ul><li><strong>原因</strong>：CMS 使用标记 - 清除算法，不进行内存压缩整理，长期运行后老年代会产生大量内存碎片。</li><li><strong>影响</strong>：即使老年代总空间充足，由于碎片化，大对象无法分配，可能触发 Full GC。</li></ul></li><li><p><strong>浮动垃圾问题（Floating Garbage）</strong></p><ul><li><strong>定义</strong>：在并发清理阶段，用户线程仍可能生成新的垃圾对象。</li><li><strong>影响</strong>：若浮动垃圾过多，导致老年代空间不足，CMS 无法完成并发回收，将触发<strong>并发模式失败（Concurrent Mode Failure）</strong>，继而触发 Full GC。</li></ul></li><li><p><strong>Full GC 的退化机制</strong></p><ul><li>当 CMS 无法完成并发回收时，将退化为 <strong>Serial Old 垃圾回收器</strong>。</li><li><strong>Serial Old</strong> 是单线程、STW 的标记 - 整理算法回收器，会导致较长时间的停顿。</li></ul></li></ol><h3 id="g1-garbage-first" tabindex="-1"><a class="header-anchor" href="#g1-garbage-first"><span>G1（Garbage First）</span></a></h3><h4 id="堆内存划分方式" tabindex="-1"><a class="header-anchor" href="#堆内存划分方式"><span>堆内存划分方式</span></a></h4><p>G1 不再采用传统垃圾回收器中“分代”的堆结构（如新生代 + 老年代），而是：</p><ul><li>将整个堆划分为 <strong>多个大小相等的独立区域（Region）</strong>。</li><li>每个 Region 可以是 Eden、Survivor、Old 或 Humongous（用于存储大对象）。</li><li>Region 类型是<strong>动态分配</strong>的，可以根据需要变化，支持灵活的内存管理策略。</li></ul><p>这种“分区（Region-based）”结构，取代了传统的“分代（Generational）”结构，是算法驱动设计的体现。</p><h4 id="g1-垃圾回收的详细过程" tabindex="-1"><a class="header-anchor" href="#g1-垃圾回收的详细过程"><span>G1 垃圾回收的详细过程</span></a></h4><ol><li><p><strong>初始标记（Initial Mark）</strong></p><ul><li>需要 STW。</li><li>标记 GC Roots 直接可达的对象，同时触发一次 Young GC。</li></ul></li><li><p><strong>并发标记（Concurrent Mark）</strong></p><ul><li>与用户线程并发执行。</li><li>遍历对象图，标记所有可达对象。</li><li>还会记录对象的存活信息，用于后续回收效率预测。</li></ul></li><li><p><strong>最终标记（Final Remark）</strong></p><ul><li>需要 STW。</li><li>处理在并发标记期间发生变化的引用关系，完成标记任务。</li></ul></li><li><p><strong>混合回收（Mixed GC）</strong></p><ul><li><strong>需要 STW</strong>，但可以控制回收哪些 Region。</li><li>G1 根据 Region 中的垃圾比例、回收效率、预期停顿时间等因素，选择部分 Region 进行回收。</li><li>使用 <strong>复制 - 整理算法</strong>，将存活对象复制到新的 Region 中，清理旧 Region，避免内存碎片。</li></ul></li></ol><h4 id="实现机制" tabindex="-1"><a class="header-anchor" href="#实现机制"><span>实现机制</span></a></h4><ul><li><strong>分区管理</strong>：堆被划分为多个 Region，每个 Region 可独立回收。</li><li><strong>回收策略灵活</strong>：G1 会优先回收垃圾对象较多的 Region（Garbage First），提高效率。</li><li><strong>停顿时间可控</strong>：通过预测每个 Region 的回收时间，选择合适数量的 Region 进行回收，以满足用户设定的停顿时间目标。</li><li><strong>复制 - 整理算法</strong>：避免了内存碎片问题，使得 G1 更适合长期运行的大内存系统。</li></ul><h2 id="gc-调优" tabindex="-1"><a class="header-anchor" href="#gc-调优"><span>GC 调优</span></a></h2><p>GC 调优的目标是根据应用程序的特性选择合适的垃圾回收器，以满足性能或响应时间的要求。</p><h3 id="常见调优策略" tabindex="-1"><a class="header-anchor" href="#常见调优策略"><span>常见调优策略</span></a></h3><ul><li><p><strong>根据系统需求选择合适的回收器</strong>：</p><ul><li><strong>吞吐量优先</strong>：Parallel Scavenge + Parallel Old（默认于 JDK 8）。</li><li><strong>低延迟需求</strong>：CMS（适用于老年代），注意处理内存碎片和并发模式失败。</li><li><strong>大堆内存 + 可预测停顿</strong>：G1，支持高并发、低停顿的全代收集。</li></ul></li><li><p><strong>设置停顿时间目标</strong>：</p><ul><li>G1 中可使用 <code>-XX:MaxGCPauseMillis=200</code> 等参数设定期望的最长时间。</li></ul></li><li><p><strong>调整堆大小与分区大小</strong>：</p><ul><li>增加堆大小或调整 G1 的 <code>RegionSize</code>，以适配内存需求和对象分配模式。</li></ul></li></ul>',41)]))}const g=i(a,[["render",o]]),d=JSON.parse('{"path":"/notes/interview/j2abw8u0/","title":"垃圾回收","lang":"zh-CN","frontmatter":{"title":"垃圾回收","createTime":"2025/08/28 16:48:33","permalink":"/notes/interview/j2abw8u0/"},"readingTime":{"minutes":7.58,"words":2274},"git":{"createdTime":1756719716000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JVM/垃圾回收.md","headers":[]}');export{g as comp,d as data};
