import{a as n,c as o,b as r,o as i}from"./app-CAzY0Upz.js";const l={};function s(e,t){return i(),o("div",null,t[0]||(t[0]=[r('<h2 id="事务的四大特性与实现原理" tabindex="-1"><a class="header-anchor" href="#事务的四大特性与实现原理"><span>事务的四大特性与实现原理</span></a></h2><ol><li><p><strong>原子性 (Atomicity)</strong></p><ul><li><strong>定义</strong>：一个事务中的所有操作必须作为一个整体执行：要么全部成功并提交，要么全部失败并回滚。</li><li><strong>实现原理</strong>：通过 Undo Log (回滚日志) 保证。事务开始时记录操作前的数据状态；若事务失败，系统基于 Undo Log 回滚到初始状态。</li></ul></li><li><p><strong>持久性 (Durability)</strong></p><ul><li><strong>定义</strong>：事务一旦提交，对数据的变更是永久性的，即使在数据库故障恢复后，数据也不丢失。</li><li><strong>实现原理</strong>：通过 Redo Log (重做日志) 保证。事务提交时先将操作日志刷新到持久存储；故障后重放 Redo Log 恢复数据。</li></ul></li><li><p><strong>隔离性 (Isolation)</strong></p><ul><li><strong>定义</strong>：事务在提交前所做的修改对其他事务不可见，防止并发读/写冲突。</li><li><strong>实现原理</strong>：通过锁机制（如共享锁/排他锁）和 MVCC (多版本并发控制) 实现。锁机制控制并发访问的顺序，MVCC 为每个数据行维护多个版本，基于事务时间戳控制可见性。</li></ul></li><li><p><strong>一致性 (Consistency)</strong></p><ul><li><strong>定义</strong>：事务的执行必须使数据库从一个一致状态转换为另一个一致状态，遵守预定义约束（如唯一键或检查约束）。例如，转账操作中，事务前后的账户总额必须一致。</li><li><strong>实现原理</strong>：作为 ACID 的目标，一致性通过实现原子性、持久性和隔离性而间接达到。</li></ul></li></ol><div class="hint-container note"><p class="hint-container-title">注</p><p>原子性、持久性和隔离性是实现一致性的<strong>手段</strong>，一致性是<strong>最终目的</strong>。</p></div><h2 id="事务并发问题" tabindex="-1"><a class="header-anchor" href="#事务并发问题"><span>事务并发问题</span></a></h2><p>事务并发执行时可能导致数据不一致问题，常见问题如下：</p><ul><li><strong>脏读 (Dirty Read)</strong>：一个事务读取到另外一个事务未提交的数据修改。例如，事务 B 读取事务 A 修改后但未提交的数据，如果事务 A 回滚，则事务 B 使用了脏数据。</li><li><strong>不可重复读 (Non-repeatable Read)</strong>：一个事务在同一个事务中多次读取同一条数据值，期间其他事务修改了该数据，导致前后结果不一致。例如，事务 B 先读取某行，事务 A 更新该行并提交后，事务 B 再读取同一行发现值变化。</li><li><strong>幻读 (Phantom Read)</strong>：一个事务执行相同范围查询两次，但其他事务插入或删除了符合条件的数据，使得第二次查询返回的行数变化。例如，事务 B 查询 <code>salary &gt; 10000</code> 的员工数量，首次 10 条；事务 A 新增一条符合条件的记录并提交后，事务 B 再查询返回 11 条。</li></ul><h2 id="事务隔离级别与实现原理" tabindex="-1"><a class="header-anchor" href="#事务隔离级别与实现原理"><span>事务隔离级别与实现原理</span></a></h2><p>事务隔离级别定义了事务之间的可见性与冲突处理策略，较低的级别提高并发但增加问题风险，较高的级别降低并发但减少问题。具体级别如下：</p><ol><li><p><strong>读未提交 (Read Uncommitted)</strong></p><ul><li><strong>描述</strong>：事务未提交时，其变更操作对其他事务立即可见。</li><li><strong>可能出现问题</strong>：脏读、不可重复读、幻读。</li><li><strong>实现原理</strong>：无需特殊机制，直接读取最新数据版本。</li></ul></li><li><p><strong>读已提交 (Read Committed)</strong></p><ul><li><strong>描述</strong>：事务提交后，其变更操作才能被其他事务读取（如 Oracle 默认级别）。</li><li><strong>可能出现问题</strong>：不可重复读、幻读。</li><li><strong>实现原理</strong>：通过 MVCC 实现。系统维护数据行快照，事务只读取已提交的版本快照。</li></ul></li><li><p><strong>可重复读 (Repeatable Read)</strong></p><ul><li><strong>描述</strong>：事务中多次查询同一条数据时返回相同结果，即使已经被其他事务提交修改（MySQL InnoDB 默认级别）。</li><li><strong>可能出现问题</strong>：按 SQL 标准可能出现幻读，但 MySQL 通过间隙锁优化后基本解决。</li><li><strong>实现原理</strong>：通过 MVCC 和间隙锁 (Gap Locks) 实现。MVCC 保证查询基于事务开始点的快照；间隙锁阻止其他事务在查询范围内插入新数据，防止幻读。</li></ul></li><li><p><strong>串行化 (Serializable)</strong></p><ul><li><strong>描述</strong>：事务完全串行执行，读写加锁阻塞并行访问。</li><li><strong>可能出现问题</strong>：无。</li><li><strong>实现原理</strong>：通过锁机制（如行级或表级读写锁）实现。读写操作冲突时，后访问事务等待前事务完成，确保顺序执行。</li></ul></li></ol>',9)]))}const g=n(l,[["render",s]]),d=JSON.parse('{"path":"/notes/interview/p9au3uzb/","title":"事务","lang":"zh-CN","frontmatter":{"title":"事务","createTime":"2025/07/24 22:23:22","permalink":"/notes/interview/p9au3uzb/"},"readingTime":{"minutes":3.74,"words":1123},"git":{"createdTime":1753364440000,"updatedTime":1757065358000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":4,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/MySQL/事务.md","headers":[]}');export{g as comp,d as data};
