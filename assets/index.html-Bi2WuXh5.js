import{a as e,c as a,b as s,o as n}from"./app-CAzY0Upz.js";const t={};function d(l,i){return n(),a("div",null,i[0]||(i[0]=[s(`<h3 id="如何理解线程安全" tabindex="-1"><a class="header-anchor" href="#如何理解线程安全"><span>如何理解线程安全</span></a></h3><h4 id="线程安全的本质" tabindex="-1"><a class="header-anchor" href="#线程安全的本质"><span>线程安全的本质</span></a></h4><p>线程安全的核心在于：当多个线程并发访问共享资源（变量、对象、文件等）时，程序的执行结果始终符合预期，且不会出现数据错乱或逻辑错误。其根源在于以下三个层面的问题：</p><ol><li><strong>原子性</strong>：操作是否不可分割，即一个操作要么完整执行，要么完全不执行。</li><li><strong>可见性</strong>：一个线程对共享变量的修改能否立即对其他线程可见。</li><li><strong>有序性</strong>：程序代码的执行顺序是否可能被编译器和 CPU 重排序。</li></ol><h4 id="i-操作的非原子性分析" tabindex="-1"><a class="header-anchor" href="#i-操作的非原子性分析"><span>i++ 操作的非原子性分析</span></a></h4><p>以 <code>i++</code> 操作为例，虽然表面是单行代码，但实际是非原子操作。在 JVM 中，<code>i++</code> 被编译为四条字节码指令：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">getstatic i    </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 读取静态变量 i 的值到操作数栈</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">iconst_1       </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 将常量 1 压入操作数栈</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">iadd           </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 将栈顶两个值相加（i+1）</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">putstatic i    </span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 将计算结果写回静态变量 i</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多线程环境下，线程切换可能发生在任意指令之间，导致操作被“切割”。例如：当线程 A 和线程 B 同时执行 <code>i++</code>（初始值 <code>i=0</code>）：</p><ol><li>线程 A 读取 <code>i=0</code>，线程 B 也读取 <code>i=0</code></li><li>线程 A 计算 <code>i+1=1</code>，线程 B 计算 <code>i+1=1</code></li><li>线程 A 写回 <code>i=1</code>，线程 B 写回 <code>i=1</code></li></ol><p>最终结果：<code>i=1</code>（期望值为 2），出现数据错误。根本原因在于多线程的指令交叉执行破坏了原子性。</p><h4 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h4><p>针对线程安全问题，可通过以下机制保障原子性、可见性和有序性：</p><ol><li><p><strong>同步锁机制</strong></p><ul><li><code>synchronized</code>：通过监视器锁（Monitor）实现代码块或方法的互斥访问。</li><li><code>Lock</code> 接口（如 <code>ReentrantLock</code>）：提供更灵活的锁控制，支持超时和中断。</li></ul></li><li><p><strong>原子类</strong></p><ul><li>使用 <code>java.util.concurrent.atomic</code> 包下的原子类（如 <code>AtomicInteger</code>），通过 CAS（Compare-And-Swap）指令实现无锁原子操作。</li><li>例如：<code>AtomicInteger.incrementAndGet()</code> 可安全替代 <code>i++</code>。</li></ul></li></ol><div class="hint-container note"><p class="hint-container-title">注</p><p>根据场景选择方案。同步锁适用于复杂同步逻辑，原子类适用于简单计数器等高频场景。</p></div>`,14)]))}const c=e(t,[["render",d]]),r=JSON.parse('{"path":"/notes/interview/8wwn2glp/","title":"线程安全","lang":"zh-CN","frontmatter":{"title":"线程安全","createTime":"2025/08/25 20:30:28","permalink":"/notes/interview/8wwn2glp/"},"readingTime":{"minutes":1.93,"words":578},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/线程安全.md","headers":[]}');export{c as comp,r as data};
