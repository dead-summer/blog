import{a,c as n,b as e,d as i,r,o as t}from"./app-CAzY0Upz.js";const d={};function l(c,o){const s=r("Mermaid");return t(),n("div",null,[o[0]||(o[0]=e('<h2 id="集合体系结构" tabindex="-1"><a class="header-anchor" href="#集合体系结构"><span>集合体系结构</span></a></h2><p>Java 集合框架主要分为两大类：<code>Collection</code> 单列集合和 <code>Map</code> 双列集合。</p><h3 id="collection-单列集合" tabindex="-1"><a class="header-anchor" href="#collection-单列集合"><span>Collection 单列集合</span></a></h3><p><code>Collection</code> 接口是单列集合的根接口，它定义了所有单列集合通用的操作。常见的实现类有：</p><ul><li><code>List</code> 接口：元素有序、可重复。 <ul><li><code>ArrayList</code>：基于动态数组实现，查询快，增删慢。</li><li><code>LinkedList</code>：基于双向链表实现，增删快，查询慢。</li><li><code>Vector</code>：<code>ArrayList</code> 的线程安全版本，性能较低。</li></ul></li><li><code>Set</code> 接口：元素无序、不可重复。 <ul><li><code>HashSet</code>：基于 <code>HashMap</code> 实现，不保证元素顺序。</li><li><code>LinkedHashSet</code>：基于 <code>LinkedHashMap</code> 实现，保持元素插入顺序。</li><li><code>TreeSet</code>：基于红黑树实现，元素有序（自然排序或定制排序）。</li></ul></li></ul>',5)),i(s,{code:"eJyNkMEOwiAMhu88xV5gewKyxOjBw24a7wSrEhGSwsU4311WFynTxXEh+b42bX9tVQgbo86obqJKj0C19taCjsa76kF4eFIaFwFPSkPbEn0K1tOZEP9U5+IVorqzDu46465wnJGHtJbHj2BmB8vHb1W45Prv4fN+jwDc0Mfikn3TUBQ/ReokTsfJvq5zEBOeQ5iIdwAEhz2IjeuWsLikVOMRQrwAz7CPVQ=="}),o[1]||(o[1]=e('<h3 id="map-双列集合" tabindex="-1"><a class="header-anchor" href="#map-双列集合"><span>Map 双列集合</span></a></h3><p><code>Map</code> 接口是双列集合的根接口，它存储键值对 (Key-Value Pair)，键唯一，值可重复。常见的实现类有：</p><ul><li><code>HashMap</code>：基于哈希表实现，不保证键值对顺序。</li><li><code>LinkedHashMap</code>：基于哈希表和双向链表实现，保持键值对插入顺序。</li><li><code>TreeMap</code>：基于红黑树实现，键有序（自然排序或定制排序）。</li><li><code>Hashtable</code>：<code>HashMap</code> 的线程安全版本，性能较低。</li><li><code>ConcurrentHashMap</code>：线程安全的 <code>HashMap</code>，性能优于 <code>Hashtable</code>。</li></ul>',3)),i(s,{code:"eJxLzkksLnbJTEwvSszlUgACsICCb2KBQjWYDwI2Npl5JalFaYnJqXZ2YNFaLiTFHonFGQgNtUgyPpl52akpuOVDilJTscuA9JQkJuWkYpFzzs9LLi0qSs0rQTcZTIEEbGp0dWHuQhVEcRKqFNQ1mIaAHYIqjOEGLgAe4F4Z"}),o[2]||(o[2]=e('<h2 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h2><h3 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制"><span>扩容机制</span></a></h3><p>当添加元素时，若当前元素数量达到内部数组容量上限，将触发扩容：</p><ol><li><strong>计算新容量</strong>：新容量通常为原容量的 1.5 倍（通过 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code> 位运算实现），并检查是否超过 <code>Integer.MAX_VALUE - 8</code> 的最大容量限制。</li><li><strong>分配新数组</strong>：根据新容量创建新数组。</li><li><strong>数据迁移</strong>：使用 <code>Arrays.copyOf()</code> 将原数组元素复制到新数组。</li><li><strong>引用更新</strong>：将内部数组引用指向新数组。</li><li><strong>完成扩容</strong>：继续执行元素添加操作。</li></ol><h2 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist"><span>CopyOnWriteArrayList</span></a></h2><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h3><p><code>CopyOnWriteArrayList</code> 是一种“写时复制”的并发容器，其核心原理如下：</p><ol><li><strong>底层存储</strong>：<code>CopyOnWriteArrayList</code> 内部也是使用数组来存储元素。</li><li><strong>读写分离</strong>： <ul><li><strong>读操作</strong>：所有的读操作（如 <code>get()</code>、<code>iterator()</code>）都不加锁，直接访问当前数组。这意味着读操作可以并发进行，且不会被写操作阻塞。</li><li><strong>写操作</strong>：当进行写操作（如 <code>add()</code>、<code>set()</code>、<code>remove()</code> 等）时，<code>CopyOnWriteArrayList</code> 会： <ol><li><strong>加锁</strong>：对写操作加 <code>ReentrantLock</code> 锁，确保同一时间只有一个线程能进行写操作。</li><li><strong>复制新数组</strong>：将当前数组复制一份，得到一个新数组。</li><li><strong>在新数组上修改</strong>：在新数组上执行修改操作（添加、删除或修改元素）。</li><li><strong>替换旧数组</strong>：修改完成后，将内部的数组引用指向这个新数组。</li><li><strong>释放锁</strong>。</li></ol></li></ul></li></ol><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h3><ul><li><p><strong>优点</strong>：</p><ul><li><strong>读性能极高</strong>：由于读操作不加锁，可以完全并发执行，因此在读多写少的场景下，<code>CopyOnWriteArrayList</code> 具有非常高的读取性能。</li><li><strong>线程安全</strong>：通过写时复制和写操作加锁，保证了并发修改的线程安全性。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>内存开销大</strong>：每次写操作都会复制整个底层数组，如果数组较大，会产生较大的内存开销。</li><li><strong>数据不是实时最新</strong>：读操作读取的是旧数组，因此可能读到的是在写操作开始之前的数据，而不是最新的数据。对于实时性要求非常高的场景不适用。</li><li><strong>写性能相对较低</strong>：写操作涉及数组复制和加锁，性能相对较低。</li></ul></li><li><p><strong>适用场景</strong>：<code>CopyOnWriteArrayList</code> 最适合于读操作远远多于写操作的并发场景，例如事件监听器列表、配置信息列表等。</p></li></ul><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h2><h3 id="底层的数据结构" tabindex="-1"><a class="header-anchor" href="#底层的数据结构"><span>底层的数据结构</span></a></h3><p><code>HashMap</code> 的底层数据结构在不同 JDK 版本中有所演变：</p><ul><li><strong>JDK 1.7 及以前</strong>： <code>HashMap</code> 的底层是 <strong>数组 + 链表</strong>。 数组被称为“桶数组” (Bucket Array)，每个数组元素是一个链表的头节点。当发生哈希冲突时，新元素会以链表的形式添加到冲突位置。</li><li><strong>JDK 1.8 及以后</strong>： <code>HashMap</code> 的底层是 <strong>数组 + 链表 + 红黑树</strong>。 在 JDK 1.8 中，当同一个桶位上的链表长度达到一定阈值 (默认为 8)，并且数组长度达到一定阈值 (默认为 64) 时，链表会转换为红黑树。当红黑树的节点数量减少到一定阈值时 (默认为 6)，会重新退化为链表。引入红黑树是为了在极端哈希冲突情况下，将查找、插入、删除操作的时间复杂度从 <code>O(n)</code> 优化到 <code>O(log n)</code>。</li></ul><h3 id="添加元素流程-put-方法" tabindex="-1"><a class="header-anchor" href="#添加元素流程-put-方法"><span>添加元素流程 (<code>put</code> 方法)</span></a></h3><p>当调用 <code>map.put(key, value)</code> 方法时，<code>HashMap</code> 添加元素的流程如下：</p><ol><li><strong>计算哈希值和索引</strong>： <ul><li>首先，计算 <code>key</code> 的 <code>hashCode()</code>。</li><li>然后，将 <code>hashCode()</code> 值进行一次扰动处理（<code>hash()</code> 方法），以减少哈希冲突的概率。</li><li>最后，通过 <code>(数组长度 - 1) &amp; hash值</code> 的位运算，计算出元素在底层数组中应存入的下标位置（桶索引）。</li></ul></li><li><strong>检查桶位是否为空</strong>： <ul><li>如果计算出的桶位置为 <code>null</code>，表示该位置没有元素，直接将 <code>key-value</code> 对封装成 <code>Node</code> 对象（或 <code>Entry</code> 对象，JDK 1.7）并存入该位置。</li></ul></li><li><strong>处理哈希冲突</strong>： <ul><li>如果桶位置不为 <code>null</code>，说明发生了哈希冲突，该位置已经存在元素（链表或红黑树的头节点）。</li><li><strong>遍历链表/红黑树</strong>： <ul><li>会遍历该桶位置下的链表或红黑树，依次比较现有元素的 <code>key</code> 和待插入 <code>key</code>： <ul><li>首先比较 <code>key</code> 的哈希值是否相等。</li><li>如果哈希值相等，再调用 <code>key.equals()</code> 方法比较 <code>key</code> 是否完全一致。</li></ul></li><li><strong>键已存在</strong>：如果找到一个键与待插入键完全一致的元素，则会用新的 <code>value</code> 覆盖原有元素的 <code>value</code>，并返回旧的 <code>value</code>。</li><li><strong>键不存在</strong>：如果遍历完整个链表或红黑树，都没有找到一致的键，则将新元素添加到链表或红黑树中。 <ul><li><strong>JDK 1.7</strong>：采用<strong>头插法</strong>将新节点插入到链表头部。</li><li><strong>JDK 1.8</strong>：采用<strong>尾插法</strong>将新节点插入到链表尾部。</li></ul></li></ul></li></ul></li><li><strong>链表转红黑树（JDK 1.8 特有）</strong>： <ul><li>在 JDK 1.8 中，如果当前桶位下的链表长度（<code>TREEIFY_THRESHOLD</code>，默认为 8）且底层数组的长度（<code>MIN_TREEIFY_CAPACITY</code>，默认为 64）达到或超过阈值，链表会转换为红黑树，以优化查找性能。</li></ul></li><li><strong>判断是否需要扩容</strong>： <ul><li>每次成功插入元素后，<code>HashMap</code> 会检查当前元素数量是否超过了阈值 (<code>threshold = capacity * loadFactor</code>)。</li><li>如果超过阈值，<code>HashMap</code> 会触发扩容操作，将底层数组的容量翻倍，并重新计算所有元素的哈希值和位置，将它们重新分布到新的数组中。</li></ul></li></ol><h2 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h2><p><code>ConcurrentHashMap</code> 在不同 JDK 版本中的实现原理有所不同，但核心思想都是通过降低锁粒度来提高并发性能。</p><ul><li><p><strong>JDK 1.7 版本</strong></p><ul><li><strong>分段锁 (Segment)</strong>：JDK 1.7 的 <code>ConcurrentHashMap</code> 采用<strong>分段锁</strong>的机制。它将整个 <code>HashMap</code> 分割成多个小的 <code>Segment</code>（段），每个 <code>Segment</code> 都是一个独立的 <code>HashEntry</code> 数组，并且维护自己的锁。</li><li><strong>并发访问</strong>：默认情况下有 16 个 <code>Segment</code>，每个 <code>Segment</code> 独立加锁。这意味着最多可以有 16 个线程同时操作 <code>ConcurrentHashMap</code> 的不同 <code>Segment</code>，从而大大降低了锁竞争，提高了并发性能。</li><li><strong>底层结构</strong>：每个 <code>Segment</code> 内部仍然是 <strong>数组 + 链表</strong> 的结构。</li></ul></li><li><p><strong>JDK 1.8 版本</strong></p><ul><li><strong>去掉了分段锁</strong>：JDK 1.8 彻底放弃了分段锁的设计，转而采用 <strong>CAS (Compare-And-Swap) + <code>synchronized</code></strong> 的方式来实现更加细粒度的锁。</li><li><strong>底层结构</strong>：<code>ConcurrentHashMap</code> 在 JDK 1.8 的底层结构是 <strong>数组 + 链表 + 红黑树</strong>，与 <code>HashMap</code> 的 JDK 1.8 实现类似。</li><li><strong>并发处理流程</strong>： <ol><li><strong>初始化数组</strong>：如果底层数组为空，使用 <strong>CAS</strong> 操作来初始化数组。</li><li><strong>插入元素</strong>： <ul><li>首先计算 <code>key</code> 的哈希值，定位到对应的桶位。</li><li><strong>空桶位</strong>：如果桶位为空，则使用 <strong>CAS</strong> 设置桶上的头节点。</li><li><strong>非空桶位</strong>：如果桶位不为空，则使用 <strong><code>synchronized</code> 锁</strong>锁定该桶位上的头节点。 <ul><li>在 <code>synchronized</code> 块内，遍历桶中的数据（链表或红黑树），比较 <code>key</code>。</li><li>如果找到相同的 <code>key</code>，则替换 <code>value</code>。</li><li>如果没有找到相同的 <code>key</code>，则新增节点到链表或红黑树中。</li><li>之后，判断链表长度是否达到阈值（8），如果达到且数组长度也达到阈值（64），则将链表转换为红黑树。</li></ul></li></ul></li><li><strong>扩容</strong>：扩容操作也是通过 CAS 协作完成的，并且支持多线程协同扩容。</li></ol></li></ul></li></ul><div class="hint-container note"><p class="hint-container-title">JDK 1.8 的优点</p><ul><li><strong>锁粒度更细</strong>：锁的粒度从整个 <code>Segment</code> 缩小到单个桶位（链表/红黑树的头节点），进一步减少了锁竞争的概率，提高了并发度。</li><li><strong>优化了哈希冲突处理</strong>：引入红黑树，在链表过长时提升了查询性能。</li><li><strong>整体性能提升</strong>：在大多数场景下，JDK 1.8 版本的 <code>ConcurrentHashMap</code> 提供了比 JDK 1.7 更好的并发性能。</li></ul><p>这种设计体现了对<strong>无锁化编程</strong>和<strong>锁粒度细化</strong>的优化思想，是 Java 并发容器的经典实现。</p></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="为什么-new-arraylist-时建议指定初始化容量值" tabindex="-1"><a class="header-anchor" href="#为什么-new-arraylist-时建议指定初始化容量值"><span>为什么 <code>new ArrayList&lt;&gt;()</code> 时建议指定初始化容量值？</span></a></h3><p>在创建 <code>ArrayList</code> 时，建议指定初始化容量值是为了优化性能和内存使用。</p><ul><li><strong>避免扩容开销</strong>：<code>ArrayList</code> 的底层是动态数组。当元素数量超出当前容量时，<code>ArrayList</code> 会进行扩容。扩容操作涉及到内存分配和数据复制，是相对耗时的。</li><li><strong>提高性能</strong>：如果能够预估 <code>ArrayList</code> 将要存储的元素数量，并设置一个合适的初始容量，就可以在很大程度上避免或减少扩容的次数，从而减少性能损耗。</li><li><strong>避免内存浪费</strong>：虽然扩容会创建更大的数组，但如果初始容量设置过大，而实际存储的元素远少于此，则会造成内存的浪费。通过合理设置初始容量，可以在性能和内存之间取得平衡。</li></ul><p>因此，当知道 <code>ArrayList</code> 大致的元素数量时，指定初始化容量是一个良好的实践。</p><h3 id="为什么默认情况下-arraylist-的扩容机制是扩容为原数组的-1-5-倍" tabindex="-1"><a class="header-anchor" href="#为什么默认情况下-arraylist-的扩容机制是扩容为原数组的-1-5-倍"><span>为什么默认情况下 <code>ArrayList</code> 的扩容机制是扩容为原数组的 1.5 倍？</span></a></h3><p><code>ArrayList</code> 默认的扩容因子为 1.5 倍（即 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>），这是在内存使用和性能之间进行权衡的经验值，适用于大多数应用场景。</p><ul><li><strong>过大的扩容因子</strong>：如果扩容因子过大，虽然可以减少扩容次数，但可能导致一次性分配过多的内存，如果这些内存未被完全使用，就会造成内存浪费。</li><li><strong>过小的扩容因子</strong>：如果扩容因子过小，会增加扩容的频率。频繁的扩容操作（创建新数组和数据复制）会带来显著的性能开销。</li><li><strong>1.5 倍的平衡</strong>：1.5 倍的扩容因子被认为是相对平衡的选择。它既能有效减少扩容的频率，降低因频繁扩容带来的性能损耗，又能避免一次性分配过多未使用的内存，从而在性能和内存效率之间取得较好的折衷。</li></ul><h3 id="arraylist-是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#arraylist-是线程安全的吗"><span><code>ArrayList</code> 是线程安全的吗？</span></a></h3><p><code>ArrayList</code> <strong>不是线程安全的</strong>。</p><p>如果 <code>ArrayList</code> 作为多线程共享的数据（例如单例对象的成员变量、静态变量等），并且有多个线程对其进行并发修改操作（如 <code>add()</code>、<code>remove()</code> 等），就可能出现线程不安全的问题：</p><ul><li><strong>数据覆盖</strong>：多个线程同时 <code>add()</code> 元素时，可能导致元素覆盖或丢失。</li><li><strong>数据不一致</strong>：在扩容过程中，一个线程正在复制数据，另一个线程可能访问到不完整或不正确的数据。</li><li><strong><code>IndexOutOfBoundsException</code></strong>：在并发修改时可能抛出数组越界异常。</li></ul><p><strong>解决方案</strong>：</p><ol><li><p><strong>使用 <code>Collections.synchronizedList()</code></strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">List</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> synchronizedList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Collections</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">synchronizedList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> ArrayList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种方法通过在每个方法上加 <code>synchronized</code> 锁来保证线程安全，但锁粒度较大，性能开销也较大。</p></li><li><p><strong>使用 <code>CopyOnWriteArrayList</code></strong>： <code>CopyOnWriteArrayList</code> 是 <code>java.util.concurrent</code> 包下提供的线程安全的 <code>List</code> 实现。</p></li></ol><h3 id="hashmap-默认的加载因子为什么是-0-75" tabindex="-1"><a class="header-anchor" href="#hashmap-默认的加载因子为什么是-0-75"><span><code>HashMap</code> 默认的加载因子为什么是 <code>0.75</code> ？</span></a></h3><p>当 <code>HashMap</code> 中存储的元素数量达到当前容量的 75% 时，<code>HashMap</code> 就会进行扩容。</p><p>选择 <code>0.75</code> 作为加载因子是基于<strong>泊松分布</strong>的统计学规律和性能与内存之间的权衡：</p><ul><li><strong>减少哈希冲突</strong>：当加载因子为 0.75 时，哈希冲突的概率相对较低，能够有效保持 <code>HashMap</code> 的平均查找时间复杂度接近 <code>O(1)</code>。如果加载因子过大，哈希冲突的概率会增加，可能导致链表过长，降低查询效率。</li><li><strong>控制内存占用</strong>：如果加载因子过小，<code>HashMap</code> 会更频繁地扩容，导致底层数组的容量增长得更快，从而占用更多的内存空间。</li><li><strong>最佳平衡点</strong>：<code>0.75</code> 是经过大量实验和统计分析得出的一个经验值，它被认为是能在减少哈希冲突（保持 <code>O(1)</code> 的平均时间复杂度）和控制内存占用之间达到最佳平衡的折中值。</li></ul><h3 id="hashmap-在扩容时-为什么会将底层数组的容量扩容为原来的-2-倍" tabindex="-1"><a class="header-anchor" href="#hashmap-在扩容时-为什么会将底层数组的容量扩容为原来的-2-倍"><span><code>HashMap</code> 在扩容时，为什么会将底层数组的容量扩容为原来的 2 倍？</span></a></h3><p>HashMap 之所以选择将容量扩容为原来的 2 倍，主要是为了<strong>维持其内部数组长度始终为 2 的幂次方</strong>。这样做有两个核心好处：</p><ol><li><p><strong>提高性能</strong>：<code>HashMap</code> 定位桶位置的传统方法是 <code>key.hashCode() % 数组长度</code>，但 <code>%</code> 取模运算的性能是比较低的。当数组长度是 2 的幂次方时，可以用<strong>位运算 <code>&amp;</code></strong> 来代替<strong>取模运算 <code>%</code></strong> 计算元素下标，位运算的效率远高于取模，这是性能上的一个关键优化。</p></li><li><p><strong>降低哈希冲突</strong>：<code>(长度 - 1)</code> 的二进制会是一个全 1 的“掩码”（比如长度 16，掩码就是 1111）。用它和 key 的 <code>hashCode</code> 做 <code>&amp;</code> 运算，能充分利用 <code>hashCode</code> 的低位信息，让数据分布更均匀，从而减少冲突。</p></li></ol><p>所以，扩容为 2 倍，就是为了在容量增长时，能够简单地保持住‘2 的幂次方’这个关键特性，以确保性能和效率。</p><h3 id="hashmap-是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#hashmap-是线程安全的吗"><span><code>HashMap</code> 是线程安全的吗？</span></a></h3><p><code>HashMap</code> <strong>不是线程安全的</strong>。</p><p>如果 <code>HashMap</code> 作为多线程共享的数据（例如单例对象的成员变量、静态变量等），并且有多个线程对其进行并发修改操作（如 <code>put()</code>、<code>remove()</code> 等），就可能出现线程不安全的问题：</p><ul><li><strong>JDK 1.7 中的问题</strong>：在 JDK 1.7 中，<code>HashMap</code> 在多线程环境下扩容时，由于采用<strong>头插法</strong>，并发修改可能导致链表形成<strong>环形结构</strong>（死循环），进而导致 CPU 占用 100% 或在获取元素时陷入死循环。也可能导致数据丢失。</li><li><strong>JDK 1.8 中的问题</strong>：在 JDK 1.8 中，虽然采用了<strong>尾插法</strong>避免了环形链表，但在多线程并发 <code>put()</code> 操作时，仍可能出现数据覆盖（例如两个线程同时向空桶插入元素，后一个线程覆盖前一个线程的数据）或在扩容时丢失元素的问题。</li></ul><p><strong>解决方案</strong>：</p><ol><li><p><strong>使用 <code>Collections.synchronizedMap()</code></strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> synchronizedMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Collections</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">synchronizedMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> HashMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这种方法通过在每个方法上加 <code>synchronized</code> 锁来保证线程安全，但锁粒度较大（锁住整个 <code>Map</code> 对象），并发性能较差。</p></li><li><p><strong>使用 <code>ConcurrentHashMap</code></strong>： <code>ConcurrentHashMap</code> 是 <code>java.util.concurrent</code> 包下提供的线程安全的 <code>Map</code> 实现，它提供了比 <code>Collections.synchronizedMap()</code> 更好的并发性能。</p></li></ol><h3 id="为什么-concurrenthashmap-在-jdk-1-8-中要结合使用-cas-和-synchronized-来保证线程安全" tabindex="-1"><a class="header-anchor" href="#为什么-concurrenthashmap-在-jdk-1-8-中要结合使用-cas-和-synchronized-来保证线程安全"><span>为什么 <code>ConcurrentHashMap</code> 在 JDK 1.8 中要结合使用 CAS 和 <code>synchronized</code> 来保证线程安全？</span></a></h3><p><code>ConcurrentHashMap</code> 在 JDK 1.8 中采用 <strong>CAS 和 <code>synchronized</code> 结合</strong>的方式来保证线程安全，而不是全部使用其中一种，这是基于对不同操作的特性和开销的精准考量，体现了<strong>无锁优先，锁为补充</strong>的现代并发编程思想。</p><p>具体来说，我们可以分两种场景来看：</p><ul><li><p><strong>低竞争或无竞争场景，优先使用 CAS</strong></p><ul><li><strong>场景</strong>：初始化数组、以及向空的桶位插入第一个节点。</li><li><strong>为什么用 CAS</strong>：这是一个<strong>非常快、冲突概率极低</strong>的操作。使用 CAS 这种无锁技术，可以通过一次原子操作完成节点插入，它不会导致线程挂起和上下文切换，开销极小，性能最高。</li></ul></li><li><p><strong>高竞争或已存在冲突的场景，切换为 <code>synchronized</code></strong></p><ul><li><strong>场景</strong>：当桶位不为空时，需要遍历修改桶下的链表或红黑树。</li><li><strong>为什么这时用 <code>synchronized</code></strong>：因为后续的操作变得<strong>复杂且耗时</strong>（比如遍历链表、旋转红黑树），竞争的可能性大大增加。 <ul><li><strong>保证复杂操作的原子性</strong>：这些操作不是一步能完成的，必须用锁来保护。</li><li><strong>避免了 CAS 在高竞争下的性能缺陷</strong>：如果对一个已经冲突的桶继续使用 CAS，多个线程会疯狂自旋重试，大量空耗 CPU 资源。而 <code>synchronized</code> 会让失败的线程进入阻塞，让出 CPU，在高竞争下反而是一种更合理的策略。</li></ul></li></ul></li></ul>',53))])}const p=a(d,[["render",l]]),g=JSON.parse('{"path":"/notes/interview/9wm28lih/","title":"集合","lang":"zh-CN","frontmatter":{"title":"集合","createTime":"2025/09/03 14:44:09","permalink":"/notes/interview/9wm28lih/"},"readingTime":{"minutes":14.75,"words":4426},"git":{"createdTime":1757065260000,"updatedTime":1757065260000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/Java基础/集合.md","headers":[]}');export{p as comp,g as data};
