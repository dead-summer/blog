import{a as l,c as s,b as d,d as i,e as a,r,o as t}from"./app-CAzY0Upz.js";const n={};function c(p,e){const o=r("Mermaid");return t(),s("div",null,[e[0]||(e[0]=d('<h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器"><span>类加载器</span></a></h2><p>类加载器（ClassLoader）是 Java 虚拟机（JVM）的重要组成部分，其主要职责是将字节码文件（<code>.class</code> 文件）加载到 JVM 内存中，并生成对应的 <code>Class</code> 对象。</p><p>Java 中的类加载器主要分为以下四类：</p><ol><li><strong>Bootstrap ClassLoader（启动类加载器）</strong><ul><li>加载 <code>JAVA_HOME/jre/lib</code> 目录下的核心类库（如 <code>rt.jar</code>）。</li><li>由 C/C++ 实现，无法通过 Java 代码直接访问。</li></ul></li><li><strong>Extension ClassLoader（扩展类加载器）</strong><ul><li>加载 <code>JAVA_HOME/jre/lib/ext</code> 目录下的扩展类库。</li><li>父加载器为 <code>Bootstrap ClassLoader</code>。</li></ul></li><li><strong>Application ClassLoader（应用程序类加载器）</strong><ul><li>加载用户类路径（<code>classpath</code>）下的类（如项目代码、第三方依赖）。</li><li>父加载器为 <code>Extension ClassLoader</code>。</li></ul></li><li><strong>自定义类加载器</strong><ul><li>继承 <code>ClassLoader</code> 类并重写 <code>findClass()</code> 方法。</li><li>作用： <ul><li>实现类隔离（如不同版本库共存）。</li><li>破坏双亲委派（通过重写 <code>loadClass()</code> 逻辑）。</li></ul></li><li>父加载器默认为 <code>Application ClassLoader</code>。</li></ul></li></ol><h2 id="双亲委派模型" tabindex="-1"><a class="header-anchor" href="#双亲委派模型"><span>双亲委派模型</span></a></h2><h3 id="工作过程" tabindex="-1"><a class="header-anchor" href="#工作过程"><span>工作过程</span></a></h3><ol><li>类加载器收到类加载请求后，<strong>不立即加载</strong>，而是将请求委派给父加载器处理。</li><li>递归执行上述过程，直至请求传递至 <code>Bootstrap ClassLoader</code>。</li><li>若父加载器无法完成加载（搜索范围中未找到类），子加载器才尝试自行加载。</li></ol><div class="hint-container caution"><p class="hint-container-title">类加载器的父子关系通过组合（非继承）实现</p><p>在 Java 中，类加载器之间的父子关系是通过组合（Composition）实现的。具体来说，每个类加载器对象内部持有一个对父类加载器的引用（通常通过 <code>parent</code> 字段），而不是通过继承（<code>extends</code>）父类加载器来实现这种关系。</p></div><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势"><span>优势</span></a></h3><ul><li><strong>类的唯一性</strong>：避免核心类被重复加载（如 <code>java.lang.Object</code> 仅由启动类加载器加载一次）。</li><li><strong>安全性</strong>：防止用户自定义类覆盖核心类（如自定义 <code>java.lang.String</code> 会被父加载器拦截）。</li></ul><h2 id="破坏双亲委派模型" tabindex="-1"><a class="header-anchor" href="#破坏双亲委派模型"><span>破坏双亲委派模型</span></a></h2><h3 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h3><p>重写 <code>ClassLoader.loadClass()</code> 方法，绕过“优先委派父加载器”的默认逻辑。</p><h3 id="典型案例-tomcat" tabindex="-1"><a class="header-anchor" href="#典型案例-tomcat"><span>典型案例：Tomcat</span></a></h3><p>Tomcat 作为 Web 容器，需同时运行多个 Web 应用程序。但：</p><ul><li>多个 Web 应用需同时运行，可能依赖<strong>相同全限定名但不同版本</strong>的类库（如 Spring 5.x 与 6.x）。</li><li>双亲委派机制无法加载同名类的多个版本。</li></ul><p>Tomcat 的解决方案是引入 <code>WebappClassLoader</code> 和 <code>SharedClassLoader</code>：</p><ol><li><strong>WebAppClassLoader（自定义类加载器）</strong><ul><li>每个 Web 应用独立使用一个 <code>WebAppClassLoader</code>。</li><li>重写 <code>loadClass()</code>：优先加载应用私有目录（<code>/WEB-INF/classes</code> 和 <code>/WEB-INF/lib</code>）中的类，<strong>跳过双亲委派</strong>。</li><li>效果：相同全限定名的类由不同类加载器加载，JVM 视为不同类（因类加载器不同）。</li></ul></li><li><strong>SharedClassLoader（共享类加载器）</strong><ul><li>加载公共目录（如 <code>$CATALINA_HOME/shared</code>）中的类库（如通用 Spring 版本）。</li><li>被所有 <code>WebAppClassLoader</code> 共享，避免重复加载公共类库，节省内存。</li></ul></li></ol>',18)),i(o,{code:"eJxLL0osyFDwCeJSUHDKzy8pLgHyFXR17RRcK0pS84oz8/OAMnA2WMaxoCAnMzmxBCKHxAPLBmckFqWmOOckFhf75CempBYB1WCIgVWGpyYBNSOJGhKv1IgLAF+iPgw="}),e[1]||(e[1]=a("p",null,"通过分层隔离机制，实现：",-1)),e[2]||(e[2]=a("ul",null,[a("li",null,"应用间类隔离（私有类独立加载）。"),a("li",null,"公共类复用（共享类库统一加载）。")],-1))])}const m=l(n,[["render",c]]),g=JSON.parse('{"path":"/notes/interview/t7p1fd1b/","title":"双亲委派","lang":"zh-CN","frontmatter":{"title":"双亲委派","createTime":"2025/08/28 19:26:12","permalink":"/notes/interview/t7p1fd1b/"},"readingTime":{"minutes":2.6,"words":780},"git":{"createdTime":1756719716000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JVM/双亲委派.md","headers":[]}');export{m as comp,g as data};
