import{a as l,c as i,b as t,o as r}from"./app-CAzY0Upz.js";const n={};function e(s,a){return r(),i("div",null,a[0]||(a[0]=[t('<h2 id="背景与定义" tabindex="-1"><a class="header-anchor" href="#背景与定义"><span>背景与定义</span></a></h2><h3 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h3><p>三色标记法是垃圾回收中用于判断对象是否为存活对象的一种图遍历算法。其理论基础是 <strong>根可达性分析（GC Roots Reachability Analysis）</strong>，该方法定义了对象是否可被程序访问，从而决定是否存活。</p><p>传统的标记过程需要 <strong>Stop-The-World（STW）</strong>，即暂停所有用户线程，以保证对象引用关系在标记期间不发生变化，确保准确性。但由于堆内存可能非常大，整个标记过程带来的 STW 停顿时间可能过长，影响应用性能。</p><p>因此，为了在保证标记正确性的前提下减少 STW 时间，引入了 <strong>三色标记法</strong>，它允许在标记阶段与用户线程并发执行，从而提高垃圾回收效率。</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p><strong>三色标记法（Tri-color Marking）</strong> 是一种用于垃圾回收的并发标记算法，通过将对象分为三种颜色（白色、灰色、黑色），实现对象图的高效遍历与存活对象的识别。其主要目标是支持并发标记，减少垃圾回收过程中的停顿时间。</p><table><thead><tr><th>颜色</th><th>含义</th></tr></thead><tbody><tr><td>白色</td><td>对象尚未被访问，可能为垃圾对象</td></tr><tr><td>灰色</td><td>对象已被访问，但其引用的对象尚未完全处理</td></tr><tr><td>黑色</td><td>对象已被访问，且其所有引用对象也已被处理完毕</td></tr></tbody></table><h2 id="原因与好处" tabindex="-1"><a class="header-anchor" href="#原因与好处"><span>原因与好处</span></a></h2><h3 id="原因" tabindex="-1"><a class="header-anchor" href="#原因"><span>原因</span></a></h3><ul><li>在不并发的情况下，标记过程必须在 STW 状态下进行，以防止对象引用关系变化导致标记不准确。</li><li>但随着堆内存的增长，单线程标记的耗时显著增加，导致应用停顿时间过长。</li><li>三色标记法通过对对象图的并发遍历，允许用户线程与垃圾回收线程同时运行，从而降低 STW 的频率和持续时间。</li></ul><h3 id="好处" tabindex="-1"><a class="header-anchor" href="#好处"><span>好处</span></a></h3><ul><li>支持并发标记，显著减少垃圾回收的停顿时间。</li><li>适用于大规模堆内存的垃圾回收场景。</li><li>在保证正确性的前提下，提高了系统整体的响应性和吞吐量。</li></ul><h2 id="标记过程的几个阶段" tabindex="-1"><a class="header-anchor" href="#标记过程的几个阶段"><span>标记过程的几个阶段</span></a></h2><ol><li><p><strong>初始标记（Initial Mark）</strong>：</p><ul><li>遍历所有 GCRoot（如线程栈、静态变量等），仅扫描根对象及其直接引用。</li><li>根对象标记为灰色，其直接引用的对象也标记为灰色（避免扫描整个堆）。</li><li>此阶段耗时短，需 STW 以确保对象图稳定。</li></ul></li><li><p><strong>并发标记（Concurrent Mark）</strong>：</p><ul><li>用户线程与回收器并发执行。回收器从灰色对象开始遍历： <ul><li>将灰色对象引用的所有白色对象标记为灰色。</li><li>将当前灰色对象标记为黑色（表示完成扫描）。</li><li>重复过程，直到无灰色对象剩余。</li></ul></li><li>写屏障（Write Barrier）技术用于跟踪引用变更（例如用户线程修改对象引用）。</li></ul></li><li><p><strong>重新标记（Remark）</strong>：</p><ul><li>处理并发阶段变更的引用关系（例如新引用或删除引用）。</li><li>需短暂 STW，确保标记正确性。</li></ul></li><li><p><strong>并发清除（Concurrent Sweep）</strong>：</p><ul><li>清除所有白色对象，用户线程可继续并发执行。</li></ul></li></ol><h2 id="漏标问题与浮动垃圾" tabindex="-1"><a class="header-anchor" href="#漏标问题与浮动垃圾"><span>漏标问题与浮动垃圾</span></a></h2><h3 id="漏标问题-对象消失问题" tabindex="-1"><a class="header-anchor" href="#漏标问题-对象消失问题"><span>漏标问题（对象消失问题）</span></a></h3><p>当两个条件同时满足时，会导致对象漏标：</p><ol><li><strong>黑色对象新增对白色对象的引用</strong>（黑色对象已经处理完成，不会再次被扫描）。</li><li><strong>灰色对象到该白色对象的所有引用路径被断开</strong>（白色对象不再能被图遍历算法访问到）。</li></ol><p>结果：该白色对象未被标记为存活，却被错误地回收。</p><h4 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h4><ul><li><p><strong>CMS（Concurrent Mark Sweep）</strong>：</p><ul><li>使用 <strong>增量更新（Incremental Update）</strong> 策略。</li><li>当黑色对象新增指向白色对象的引用时，记录该引用变更。</li><li>在重新标记阶段重新处理这些新增引用，确保对象被正确标记。</li></ul></li><li><p><strong>G1（Garbage-First）</strong>：</p><ul><li>使用 <strong>原始快照（Snapshot-At-The-Beginning, SATB）</strong> 策略。</li><li>在并发标记开始时记录所有对象的引用快照。</li><li>当灰色对象删除对白色对象的引用时，记录该变更，并在最终标记阶段重新处理。</li></ul></li></ul><h4 id="浮动垃圾-多标问题" tabindex="-1"><a class="header-anchor" href="#浮动垃圾-多标问题"><span>浮动垃圾（多标问题）</span></a></h4><ul><li><strong>定义</strong>：对象在并发标记开始时被认为是存活的（被标记为黑色），但在标记结束后，该对象不再被任何根节点引用，理应被回收，但由于标记已经完成，仍被保留。</li><li><strong>原因</strong>：三色标记法无法实时感知引用删除。</li><li><strong>解决方式</strong>：不做处理，将浮动垃圾保留到下一次垃圾回收时再处理。</li></ul><h2 id="实际应用" tabindex="-1"><a class="header-anchor" href="#实际应用"><span>实际应用</span></a></h2><p>三色标记法广泛应用于现代垃圾回收器中，特别是在需要并发执行的场景：</p><ul><li><p><strong>CMS 垃圾回收器</strong>：</p><ul><li>使用三色标记 + 增量更新实现低延迟回收。</li><li>并发标记和重新标记阶段使用写屏障记录引用变更。</li></ul></li><li><p><strong>G1 垃圾回收器</strong>：</p><ul><li>使用三色标记 + SATB 实现更精确的并发标记。</li><li>通过原始快照处理引用删除，避免漏标。</li></ul></li></ul>',27)]))}const d=l(n,[["render",e]]),h=JSON.parse('{"path":"/notes/interview/iftpp53d/","title":"三色标记法","lang":"zh-CN","frontmatter":{"title":"三色标记法","createTime":"2025/08/28 17:37:27","permalink":"/notes/interview/iftpp53d/"},"readingTime":{"minutes":4.41,"words":1322},"git":{"createdTime":1756719716000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JVM/三色标记法.md","headers":[]}');export{d as comp,h as data};
