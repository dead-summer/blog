import{a as r,c as n,b as t,o}from"./app-CAzY0Upz.js";const a={};function e(i,l){return o(),n("div",null,l[0]||(l[0]=[t('<h2 id="垃圾回收器分类概述" tabindex="-1"><a class="header-anchor" href="#垃圾回收器分类概述"><span>垃圾回收器分类概述</span></a></h2><ul><li><strong>新生代收集器</strong>：Serial、ParNew、Parallel Scavenge</li><li><strong>老年代收集器</strong>：Serial Old、Parallel Old、CMS</li><li><strong>整堆收集器（或分代、不分代）</strong>：G1、ZGC、Shenandoah</li></ul><h2 id="各垃圾回收器特点" tabindex="-1"><a class="header-anchor" href="#各垃圾回收器特点"><span>各垃圾回收器特点</span></a></h2><ul><li><p><strong>串行垃圾回收器 (Serial GC / Serial Old)</strong></p><ul><li><strong>特点</strong>：单线程执行垃圾回收，在进行垃圾回收时会暂停所有应用线程（Stop-The-World, STW）。</li><li><strong>适用场景</strong>：适用于单核 CPU 环境或内存较小的应用（如客户端模式下的 JVM），因为其实现简单，开销较小。不适合多核环境和大内存应用，因为 STW 时间较长。</li></ul></li><li><p><strong>并行垃圾回收器 (Parallel Scavenge / Parallel Old / ParNew)</strong></p><ul><li><strong>特点</strong>：多线程执行垃圾回收，在进行垃圾回收时也会暂停所有应用线程。Parallel Scavenge 关注吞吐量，ParNew 是 Serial 的多线程版本，通常与 CMS 配合使用。</li><li><strong>适用场景</strong>：适用于多核 CPU 环境。更侧重于达到高吞吐量（Throughput），适合批处理、后台作业等对暂停时间不敏感的应用。</li></ul></li><li><p><strong>并发标记扫描垃圾回收器 (CMS Garbage Collector)</strong></p><ul><li><strong>特点</strong>：以最小化 STW 时间为目标，采用并发标记和并发清除阶段，使得大部分垃圾回收工作可以与应用线程一起执行。</li><li><strong>优点</strong>：低延迟，适合对响应时间有较高要求的应用。</li><li><strong>缺点</strong>：容易产生内存碎片，当碎片过多时可能触发 Full GC 进行碎片整理，此时会导致较长的 STW。此外，CMS 在并发执行时会占用一部分 CPU 资源，对吞吐量有一定影响。</li></ul></li><li><p><strong>G1 垃圾回收器 (G1 Garbage Collector)</strong></p><ul><li><strong>特点</strong>：JDK 7 中推出，JDK 9 中成为默认垃圾回收器。它将堆内存划分为多个大小相等的区域（Region），以增量方式进行回收。具备可预测的暂停时间模型，允许用户设置期望的 STW 目标。</li><li><strong>适用场景</strong>：适用于大内存（通常建议 4GB 以上）和多核 CPU 环境。旨在替代 CMS，提供更低的暂停时间和更好的吞吐量平衡。适合大数据量、需要软实时响应的应用。</li></ul></li><li><p><strong>ZGC (The Z Garbage Collector) / Shenandoah GC</strong></p><ul><li><strong>特点</strong>：ZGC (JDK 11 推出)、Shenandoah (JDK 12 推出) 是超低延迟的垃圾回收器。它们的目标是将 STW 时间控制在极低的水平（通常在 10ms 以下），即使在处理 TB 级别的堆内存时也能保持低延迟。</li><li><strong>适用场景</strong>：适用于对响应时间有极高要求的应用，如金融交易系统、大数据实时分析等。</li><li><strong>限制</strong>：目前只支持较新的 JDK 版本，且可能存在一些不成熟的特性或配置复杂度。</li></ul></li></ul><h2 id="垃圾回收器选择依据" tabindex="-1"><a class="header-anchor" href="#垃圾回收器选择依据"><span>垃圾回收器选择依据</span></a></h2><p>综合以上特点，选择垃圾回收器时可以遵循以下原则：</p><ol><li><p><strong>根据硬件资源判断</strong>：</p><ul><li><strong>单核 CPU 或内存较小 (MB 级别)</strong>：选择 Serial GC，简单高效。</li><li><strong>多核 CPU 且内存适中 (GB 级别)</strong>：可以考虑 Parallel 系列（追求高吞吐量）或 CMS（追求低延迟）。</li></ul></li><li><p><strong>根据业务类型和性能目标判断</strong>：</p><ul><li><strong>追求高吞吐量 (Throughput)</strong>：如果应用是批处理任务、数据分析等后台作业，对单次停顿时间不敏感，更关注单位时间内完成的工作量，则选择 Parallel Scavenge 和 Parallel Old 组合。</li><li><strong>追求低延迟 (Low Latency)</strong>：如果应用是实时交易系统、Web 服务等需要快速响应的应用，对 STW 时间非常敏感，则优先选择 CMS、G1、ZGC 或 Shenandoah。</li></ul></li><li><p><strong>根据堆内存大小判断</strong>：</p><ul><li><strong>小堆内存 (几百 MB 到 1-2 GB)</strong>：Serial、Parallel、CMS 都能很好地工作。</li><li><strong>中大堆内存 (4GB 到几十 GB)</strong>：G1 是一个很好的通用选择，能够平衡吞吐量和延迟。</li><li><strong>超大堆内存 (几十 GB 到 TB 级别)</strong>：ZGC 或 Shenandoah 是最佳选择，它们旨在解决超大堆内存下的超低延迟问题。</li></ul></li><li><p><strong>根据 JDK 版本判断</strong>：</p><ul><li><strong>JDK 8 及以前</strong>：Parallel 系列是默认的，CMS 也是常用选择。G1 在 JDK 7 引入，JDK 8 中逐渐成熟。</li><li><strong>JDK 9 及以后</strong>：G1 成为默认垃圾回收器。</li><li><strong>JDK 11 及以后</strong>：可以考虑使用 ZGC。</li><li><strong>JDK 12 及以后</strong>：可以考虑使用 Shenandoah。</li></ul></li></ol>',7)]))}const g=r(a,[["render",e]]),d=JSON.parse('{"path":"/notes/interview/gmmjnz7o/","title":"垃圾回收器选择","lang":"zh-CN","frontmatter":{"title":"垃圾回收器选择","createTime":"2025/08/29 17:11:19","permalink":"/notes/interview/gmmjnz7o/"},"readingTime":{"minutes":3.68,"words":1103},"git":{"createdTime":1756719716000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JVM/垃圾回收器选择.md","headers":[]}');export{g as comp,d as data};
