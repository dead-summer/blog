import{a as o,c as n,e as t,d as a,b as s,f as e,r as c,o as l}from"./app-CAzY0Upz.js";const i={};function h(g,r){const d=c("Mermaid");return l(),n("div",null,[r[0]||(r[0]=t("p",null,[e("ReentrantLock 是 Java 并发包 ("),t("code",null,"java.util.concurrent.locks"),e(") 中 "),t("code",null,"Lock"),e(" 接口的核心实现类，提供了比 "),t("code",null,"synchronized"),e(" 关键字更灵活的锁机制。其底层基于 AQS ("),t("code",null,"AbstractQueuedSynchronizer"),e(") 框架实现，支持可重入性、公平锁、非公平锁等高级特性。")],-1)),a(d,{code:"eJylj0EOgjAQRddyii41Bg5ACAmJSzbiCSZ1NI1tkc50YdS7W4oR6NbZ/Te/f36lBqKDgqsDk23OyqFk1VvRdpkIE9ei7eVNPCMYp6qUZXQXkFjXP7rXwbXdzdrblLB7jFFf9F5c6BAtO7CcnPortDmellHB2MjBhy8mzzvUCLSixMA4y8Gjn+SUH1tWr6JIipdCmbtGExhF43qd53UsVQpPSNkHAI5kYg=="}),r[1]||(r[1]=s('<h2 id="aqs-abstractqueuedsynchronizer" tabindex="-1"><a class="header-anchor" href="#aqs-abstractqueuedsynchronizer"><span>AQS (AbstractQueuedSynchronizer)</span></a></h2><p>AQS 是一个用于构建阻塞锁和同步器的框架，主要由两部分组成：</p><ol><li><strong>state 属性</strong>：一个 <code>volatile</code> 修饰的整型变量，用于表示共享资源的状态。 <ul><li>支持<strong>独占模式</strong>（单线程访问）和<strong>共享模式</strong>（多线程并发访问）。</li><li>使用 CAS (Compare and Swap) 机制更新 <code>state</code>，确保线程安全。</li></ul></li><li><strong>FIFO 等待队列</strong>：一个双向链表实现的队列，用于存储未竞争到锁的线程。 <ul><li>竞争失败的线程会被打包为 <code>Node</code> 节点，按顺序加入队列尾部。</li><li>释放锁时，队列头部节点被唤醒以重新竞争资源。</li></ul></li></ol><p>两种共工作模式的特点如下：</p><table><thead><tr><th>模式</th><th>特点</th><th>典型实现类</th></tr></thead><tbody><tr><td><strong>独占模式</strong></td><td>同一时刻仅一个线程可访问资源</td><td><code>ReentrantLock</code></td></tr><tr><td><strong>共享模式</strong></td><td>允许多个线程同时访问资源</td><td><code>CountDownLatch</code></td></tr></tbody></table><h4 id="state-属性在不同实现中的含义" tabindex="-1"><a class="header-anchor" href="#state-属性在不同实现中的含义"><span>state 属性在不同实现中的含义</span></a></h4><table><thead><tr><th>实现类</th><th>state 值的含义</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>- <code>state = 0</code>：资源未被加锁。<br>- <code>state = 1</code>：资源已被加锁。<br>- <code>state &gt; 1</code>：可重入锁（当前线程多次加锁）。</td></tr><tr><td>CountDownLatch</td><td><code>state</code> 表示剩余计数（倒计时值）。</td></tr></tbody></table><h2 id="reentrantlock-和-synchronized-的比较" tabindex="-1"><a class="header-anchor" href="#reentrantlock-和-synchronized-的比较"><span>ReentrantLock 和 Synchronized 的比较</span></a></h2><table><thead><tr><th>特性</th><th>ReentrantLock</th><th>Synchronized</th></tr></thead><tbody><tr><td><strong>实现层面</strong></td><td>JDK 代码层面实现（基于 AQS）。</td><td>JVM 层面实现（依赖操作系统指令）。</td></tr><tr><td><strong>用法</strong></td><td>需显式调用 <code>lock()</code> 和 <code>unlock()</code>。</td><td>修饰方法或代码块（隐式加解锁）。</td></tr><tr><td><strong>公平锁支持</strong></td><td>支持公平锁和非公平锁。</td><td>仅支持非公平锁。</td></tr><tr><td><strong>可重入性</strong></td><td>支持。</td><td>支持。</td></tr><tr><td><strong>使用场景</strong></td><td>复杂场景（如需要超时、中断或条件变量）。</td><td>简单场景（代码简单、无高级需求）。</td></tr></tbody></table><h2 id="reentrantlock-如何实现公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#reentrantlock-如何实现公平锁和非公平锁"><span>ReentrantLock 如何实现公平锁和非公平锁</span></a></h2><p>公平与非公平是指：</p><ul><li><strong>公平锁</strong>：线程严格按请求顺序分配锁（FIFO 队列中的等待线程优先）。</li><li><strong>非公平锁</strong>：允许线程插队尝试抢占锁（新线程可直接竞争，无需入队）。</li></ul><p><strong>ReentrantLock 实现机制</strong>：</p><ul><li><strong>公平锁</strong>：线程竞争锁时，先检查 FIFO 队列是否有等待线程。若有，则新线程加入队列尾部等待；否则尝试获取锁。</li><li><strong>非公平锁</strong>：线程竞争锁时，直接尝试 CAS 抢占 <code>state</code>。若失败，再打包为 <code>Node</code> 加入队列尾部等待。</li><li><strong>默认行为</strong>：ReentrantLock 默认非公平锁（提升吞吐量），但公平性相对队列中的等待线程而言。队列中的线程始终按顺序唤醒。</li></ul>',14))])}const u=o(i,[["render",h]]),b=JSON.parse('{"path":"/notes/interview/yow1n5vx/","title":"ReentrantLock","lang":"zh-CN","frontmatter":{"title":"ReentrantLock","createTime":"2025/08/26 15:27:06","permalink":"/notes/interview/yow1n5vx/"},"readingTime":{"minutes":2.37,"words":710},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/ReentrantLock.md","headers":[]}');export{u as comp,b as data};
