import{a,c as i,b as n,o as l}from"./app-CAzY0Upz.js";const t={};function e(r,s){return l(),i("div",null,s[0]||(s[0]=[n(`<h2 id="常见索引结构" tabindex="-1"><a class="header-anchor" href="#常见索引结构"><span>常见索引结构</span></a></h2><p>索引是数据库优化查询性能的核心机制。不同索引结构在查询效率、存储方式和支持的操作上存在显著差异。</p><h3 id="哈希表" tabindex="-1"><a class="header-anchor" href="#哈希表"><span>哈希表</span></a></h3><p>哈希表基于哈希函数实现键值映射，适用于精确匹配查询。</p><ul><li><strong>工作方式</strong>： <ul><li>通过哈希函数将输入键映射为固定长度的哈希值，定位存储桶（bucket）。</li><li>每个存储桶包含键值对，查询时直接根据哈希值访问对应存储桶。</li></ul></li><li><strong>优点</strong>： <ul><li>等值查询效率极高，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><strong>缺点</strong>： <ul><li>不支持范围查询，需全表扫描，时间复杂度退化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li><li>哈希冲突可能影响性能，需额外处理（如链地址法）。</li></ul></li><li><strong>适用场景</strong>： <ul><li>键值数据库或需要快速等值查询的场景，如缓存系统。</li></ul></li></ul><h3 id="二叉搜索树" tabindex="-1"><a class="header-anchor" href="#二叉搜索树"><span>二叉搜索树</span></a></h3><p>二叉搜索树使用节点结构存储数据，但存在严重性能瓶颈。</p><ul><li><strong>工作方式</strong>： <ul><li>每个节点存储一个键值对，左子树键值小于节点，右子树键值大于节点。</li><li>查询时从根节点开始，比较键值后递归选择左或右子树，直至找到目标或确认不存在。</li></ul></li><li><strong>问题</strong>： <ul><li>数据量大时树高度激增（例如百万数据时高度约 20 层），导致查询需多次磁盘 I/O，效率低下。</li><li>不平衡树（如倾斜树）进一步恶化性能，实际场景中较少直接使用。</li></ul></li><li><strong>适用场景</strong>： <ul><li>小规模数据或内存操作，需额外平衡机制（如 AVL 树或红黑树）。</li></ul></li></ul><h3 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树"><span>B 树</span></a></h3><p>B 树是一种自平衡树结构，非叶子节点同时存储索引键和记录数据。</p><ul><li><strong>工作方式</strong>： <ul><li>每个节点包含多个键和指向子节点的指针，节点大小固定为磁盘页。</li><li>查询时从根节点开始，根据键值比较选择子节点，逐层定位目标数据。</li><li>插入/删除时通过节点分裂或合并保持平衡，确保树高度较低。</li></ul></li><li><strong>特点</strong>： <ul><li>每个节点大小固定为磁盘页（通常 16 KB），存储索引键和关联记录。</li><li>通过多叉结构维持平衡，确保操作时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(\\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><strong>优点</strong>： <ul><li>相比二叉树，数据量大时树高度更低（例如百万数据时高度约 3-4 层），减少 I/O 次数。</li></ul></li><li><strong>缺点</strong>： <ul><li>节点存储记录数据，导致单个节点有效索引键较少（分支因子小），树高度仍较高。</li><li>范围查询效率低，需遍历多个节点。</li></ul></li><li><strong>适用场景</strong>： <ul><li>适合点查询为主的数据库场景，如早期文件系统。</li></ul></li></ul><h3 id="b-树-1" tabindex="-1"><a class="header-anchor" href="#b-树-1"><span>B+ 树</span></a></h3><p>B+ 树是 B 树的优化版本，非叶子节点仅存储索引键，数据集中在叶子节点。</p><ul><li><strong>工作方式</strong>： <ul><li>非叶子节点存储索引键和子节点指针，查询时通过键值比较逐层定位到叶子节点。</li><li>叶子节点存储索引键和完整记录，通过双向链表连接，便于顺序遍历。</li><li>插入/删除时通过节点分裂或合并保持平衡，维持低树高。</li></ul></li><li><strong>特点</strong>： <ul><li>非叶子节点只存储索引键，叶子节点存储索引键和完整记录。</li><li>叶子节点间通过双向链表连接，支持高效顺序访问。</li></ul></li><li><strong>优点</strong>： <ul><li>分支因子大（单个节点可存储更多索引键），树高度显著降低（例如百万数据时高度约 2-3 层），I/O 次数更少。</li><li>范围查询高效，通过链表直接遍历叶子节点。</li><li>查询稳定性高，数据始终在叶子节点获取。</li></ul></li><li><strong>适用场景</strong>： <ul><li>现代关系型数据库（如 MySQL InnoDB）的首选索引结构，适合点查询和范围查询。</li></ul></li></ul><h3 id="b-树与-b-树的区别" tabindex="-1"><a class="header-anchor" href="#b-树与-b-树的区别"><span>B 树与 B+ 树的区别</span></a></h3><table><thead><tr><th>特性</th><th>B 树</th><th>B+ 树</th></tr></thead><tbody><tr><td><strong>数据存储</strong></td><td>所有节点存储索引键 + 记录</td><td>非叶子节点仅存索引键；叶子节点存索引键 + 记录</td></tr><tr><td><strong>分支因子</strong></td><td>较低（节点存储记录占用空间）</td><td>较高（节点仅存索引键）</td></tr><tr><td><strong>范围查询</strong></td><td>不支持高效范围查询</td><td>支持（叶子节点双向链表）</td></tr><tr><td><strong>查询稳定性</strong></td><td>数据可能在中途节点获取（不稳定）</td><td>数据仅在叶子节点获取（稳定）</td></tr><tr><td><strong>适用场景</strong></td><td>点查询为主</td><td>点查询和范围查询兼顾</td></tr></tbody></table><h2 id="聚集索引和二级索引" tabindex="-1"><a class="header-anchor" href="#聚集索引和二级索引"><span>聚集索引和二级索引</span></a></h2><p>在 InnoDB 存储引擎中，索引主要分为聚集索引 (Clustered Index) 和二级索引 (Secondary Index)。</p><h3 id="聚集索引-clustered-index" tabindex="-1"><a class="header-anchor" href="#聚集索引-clustered-index"><span>聚集索引 (Clustered Index)</span></a></h3><ul><li><strong>定义</strong>: 叶子节点存储完整行数据，物理存储顺序与索引逻辑顺序一致。</li><li><strong>结构</strong>: 每张表<strong>有且仅有</strong>一个聚集索引。</li><li><strong>选择规则</strong>: <ol><li>如果表定义了 <code>PRIMARY KEY</code>，则主键索引就是聚集索引。</li><li>如果没有 <code>PRIMARY KEY</code>，InnoDB 会选择第一个<strong>不包含 NULL 值</strong>的 <code>UNIQUE</code> 索引作为聚集索引。</li><li>如果以上两者都没有，InnoDB 会隐式地创建一个名为 <code>GEN_CLUST_INDEX</code> 的 6 字节隐藏主键作为聚集索引。</li></ol></li><li><strong>叶子节点存储内容</strong>: <code>主键值</code> + <code>完整的行记录</code>。</li></ul><h3 id="二级索引-secondary-index" tabindex="-1"><a class="header-anchor" href="#二级索引-secondary-index"><span>二级索引 (Secondary Index)</span></a></h3><ul><li><strong>定义</strong>: 二级索引，也称为非聚集索引。它的叶子节点不存储完整的行数据，而是存储<strong>索引键的值</strong>和对应记录的<strong>主键值</strong>。</li><li><strong>结构</strong>: 一张表可以拥有多个二级索引。</li><li><strong>叶子节点存储内容</strong>: <code>索引列的值</code> + <code>主键值</code>。</li></ul><h3 id="回表和索引覆盖" tabindex="-1"><a class="header-anchor" href="#回表和索引覆盖"><span>回表和索引覆盖</span></a></h3><h4 id="回表-table-access-by-index-rowid" tabindex="-1"><a class="header-anchor" href="#回表-table-access-by-index-rowid"><span>回表 (Table Access by Index RowID)</span></a></h4><ul><li><strong>定义</strong>: 使用二级索引查询时，若所需列未完全覆盖，需用主键值回查聚集索引获取完整数据。这个<strong>再次查询聚集索引</strong>的过程，就称为“回表”。</li><li><strong>示例</strong>:<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- age 列上存在二级索引</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> id, age, </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">name</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> student </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 20</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>执行过程</strong>: <ol><li>在 <code>age</code> 索引树中搜索 <code>age = 20</code> 的记录，找到对应的叶子节点。</li><li>从叶子节点中获取该记录的<strong>主键值</strong> (例如 <code>id = 101</code>)。</li><li>使用获取到的主键值 <code>101</code>，回到<strong>主键索引 (聚集索引)</strong> 中进行查找。</li><li>在主键索引的叶子节点中找到 <code>id = 101</code> 的完整行记录，并从中读取 <code>id</code>, <code>age</code>, <code>name</code> 字段返回。</li></ol></li><li><strong>影响</strong>: 回表操作需要进行两次索引查找，增加了额外的磁盘 I/O 和查询开销，应尽量避免。</li></ul><h4 id="索引覆盖-covering-index" tabindex="-1"><a class="header-anchor" href="#索引覆盖-covering-index"><span>索引覆盖 (Covering Index)</span></a></h4><ul><li><strong>定义</strong>: 当一个查询语句所需要获取的所有列数据，都恰好能从一个二级索引的叶子节点中直接获取时，就不再需要进行回表操作。这种情况就称为“索引覆盖”。</li><li><strong>示例</strong>:<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">-- age 列上存在二级索引</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SELECT</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> id, age </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">FROM</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> student </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 20</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>执行过程</strong>: <ol><li>在 <code>age</code> 索引树中搜索 <code>age = 20</code> 的记录，找到对应的叶子节点。</li><li>二级索引的叶子节点本身就存储了 <code>age</code> 和 <code>主键 id</code> 的值。查询所需的所有列 (<code>id</code>, <code>age</code>) 均已获取。</li><li>直接返回结果，无需回表查询主键索引。</li></ol></li><li><strong>优势</strong>: 索引覆盖是一种高效的查询优化策略，它减少了查询主键索引的步骤，避免了回表带来的性能损耗，显著提升了查询效率。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="为什么使用-b-树作为索引的数据结构" tabindex="-1"><a class="header-anchor" href="#为什么使用-b-树作为索引的数据结构"><span>为什么使用 B+ 树作为索引的数据结构？</span></a></h3><p>数据库选择 B+ 树，其实是一个历史演进的过程，而并不是在众多索引方式中选出来的结果。</p><ol><li><strong>首先是哈希表</strong>：查单个值很快，但完全不支持范围查询，而且在磁盘上扩展和冲突处理都很低效，所以不适合数据库。</li><li><strong>然后是二叉树</strong>：逻辑上能查和遍历，但每个节点太小，树高太大，大量数据时磁盘 I/O 次数太多，即使平衡二叉树也不够友好。</li><li><strong>接着是 B 树</strong>：它是专门为磁盘设计的多路平衡树，每个节点能容纳很多关键字，树高大幅下降，I/O 大幅减少。但 B 树的缺点是数据分散在所有节点，范围查询需要反复在树中跳，效率不理想。</li><li><strong>最后演进到 B+ 树</strong>：它把所有数据都放在叶子节点，内部节点只存索引键，这样树更矮更轻；同时叶子节点通过链表顺序连接，非常适合范围查询。再加上继承了 B 树的平衡和动态特性，所以成为数据库和文件系统的标准索引结构。</li></ol>`,31)]))}const d=a(t,[["render",e]]),h=JSON.parse('{"path":"/notes/interview/a6sbp81y/","title":"B+树索引","lang":"zh-CN","frontmatter":{"title":"B+树索引","createTime":"2025/08/29 20:13:13","permalink":"/notes/interview/a6sbp81y/"},"readingTime":{"minutes":7.28,"words":2183},"git":{"createdTime":1756719850000,"updatedTime":1757065358000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":3,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/MySQL/B+树索引.md","headers":[]}');export{d as comp,h as data};
