import{a as e,c as s,b as i,o as t}from"./app-CAzY0Upz.js";const d={};function n(r,a){return t(),s("div",null,a[0]||(a[0]=[i(`<h2 id="迭代器的概念" tabindex="-1"><a class="header-anchor" href="#迭代器的概念"><span>迭代器的概念</span></a></h2><p>迭代器是一种设计模式，它提供了一种统一的方式来顺序访问聚合对象中各个元素，而无需暴露该对象的内部表示。在 Java 中，迭代器主要通过 <code>Iterator</code> 接口实现，用于遍历各种集合类型。</p><h2 id="迭代器的实现原理" tabindex="-1"><a class="header-anchor" href="#迭代器的实现原理"><span>迭代器的实现原理</span></a></h2><h3 id="集合的遍历方式" tabindex="-1"><a class="header-anchor" href="#集合的遍历方式"><span>集合的遍历方式</span></a></h3><p>Java 集合的常见遍历方式包括：</p><ol><li><strong>迭代器遍历 (Iterator Traversal)</strong>：显式使用 <code>Iterator</code> 对象的 <code>hasNext()</code> 和 <code>next()</code> 方法进行遍历。</li><li><strong>增强 For 循环遍历 (Enhanced For-Loop Traversal)</strong>：<code>for-each</code> 循环，是迭代器遍历的语法糖。</li><li><strong>Lambda 表达式遍历 (Lambda Expression Traversal)</strong>：结合 Java 8 Stream API 或 <code>forEach</code> 方法进行遍历。</li></ol><h3 id="增强-for-循环的底层实现" tabindex="-1"><a class="header-anchor" href="#增强-for-循环的底层实现"><span>增强 For 循环的底层实现</span></a></h3><p>增强 For 循环的底层实现原理就是调用了集合的迭代器方法。任何实现了 <code>Iterable</code> 接口的类都可以使用增强 For 循环，<code>Iterable</code> 接口要求实现 <code>iterator()</code> 方法，该方法返回一个 <code>Iterator</code> 对象。</p><h3 id="迭代器的优势" tabindex="-1"><a class="header-anchor" href="#迭代器的优势"><span>迭代器的优势</span></a></h3><ul><li><strong>统一遍历接口</strong>：迭代器提供了一种统一的、标准化的方式来遍历不同类型的集合（如 <code>List</code>、<code>Set</code>、<code>Map</code> 等），而无需了解或暴露底层数据结构的具体实现细节。</li><li><strong>解耦</strong>：将集合的遍历操作与集合本身解耦，使得集合的内部结构变化不会影响遍历代码。</li><li><strong>设计模式</strong>：迭代器模式是 GoF 23 种设计模式之一，其核心思想是提供一种顺序访问聚合对象元素的方法，同时隐藏其底层表示。</li></ul><h3 id="迭代器出现的原因" tabindex="-1"><a class="header-anchor" href="#迭代器出现的原因"><span>迭代器出现的原因</span></a></h3><p>如果没有迭代器，每当需要遍历一种新的数据结构时，开发人员就必须学习并掌握其特有的遍历机制。例如，对于数组、链表、哈希表等不同的底层实现，可能需要不同的遍历逻辑。迭代器的引入，使得无论底层数据结构如何变化，只需掌握一种通用的迭代器遍历方式即可，极大地简化了开发。</p><h2 id="iterator-接口定义" tabindex="-1"><a class="header-anchor" href="#iterator-接口定义"><span><code>Iterator</code> 接口定义</span></a></h2><p>在 Java 中，<code>Iterator</code> 接口定义了迭代器的基本行为：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> interface</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Iterator</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">E</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    boolean</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> hasNext</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 检查是否还有下一个元素</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    E </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">next</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">           // 获取下一个元素</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> remove</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">      // 删除当前元素（可选操作）</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="迭代器遍历的内部工作原理" tabindex="-1"><a class="header-anchor" href="#迭代器遍历的内部工作原理"><span>迭代器遍历的内部工作原理</span></a></h2><p>每个具体的集合类（如 <code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>HashMap</code> 等）都会通过其内部类实现 <code>Iterator</code> 接口，并结合自身的数据结构特点来定制 <code>hasNext()</code>、<code>next()</code> 和 <code>remove()</code> 方法的逻辑。</p><ul><li><strong><code>ArrayList</code></strong>：其内部迭代器通常利用数组的索引来追踪当前元素的位置，<code>hasNext()</code> 检查索引是否超出数组边界，<code>next()</code> 返回当前索引位置的元素并递增索引。</li><li><strong><code>LinkedList</code></strong>：其内部迭代器利用链表的节点指针（<code>Node</code> 引用）来遍历，<code>hasNext()</code> 检查当前节点是否为 <code>null</code>，<code>next()</code> 返回当前节点的值并将指针移动到下一个节点。</li><li><strong><code>HashMap</code></strong>：<code>HashMap</code> 的迭代器通常会遍历其内部的哈希桶数组（<code>Node[] table</code>），并在每个桶内遍历链表或红黑树结构。</li></ul>`,18)]))}const h=e(d,[["render",n]]),l=JSON.parse('{"path":"/notes/interview/d858hssy/","title":"迭代器","lang":"zh-CN","frontmatter":{"title":"迭代器","createTime":"2025/09/03 18:18:59","permalink":"/notes/interview/d858hssy/"},"readingTime":{"minutes":2.73,"words":820},"git":{"createdTime":1757065260000,"updatedTime":1757065260000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/Java基础/迭代器.md","headers":[]}');export{h as comp,l as data};
