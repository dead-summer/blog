import{a,c as t,b as l,o as i}from"./app-CAzY0Upz.js";const d={};function n(o,e){return i(),t("div",null,e[0]||(e[0]=[l('<p>类的生命周期是 Java 虚拟机（JVM）管理类的核心机制，涵盖了从类被加载到内存到最终被卸载的完整过程。它将经历加载、链接（验证、准备、解析）、初始化、使用、卸载五个阶段。</p><h2 id="加载-loading" tabindex="-1"><a class="header-anchor" href="#加载-loading"><span>加载（Loading）</span></a></h2><h3 id="核心任务" tabindex="-1"><a class="header-anchor" href="#核心任务"><span>核心任务</span></a></h3><p>加载阶段的核心任务是通过类的全限定名（如 <code>java.lang.String</code>）查找字节码文件（<code>.class</code>），将其二进制数据读入内存，并在方法区生成该类的运行时数据结构（如类元信息、常量池等），同时在堆中创建一个 <code>java.lang.Class</code> 对象作为访问该类数据的入口。</p><h3 id="触发条件" tabindex="-1"><a class="header-anchor" href="#触发条件"><span>触发条件</span></a></h3><p>类首次“主动使用”时会触发加载，常见的主动使用场景包括：</p><ul><li>使用 <code>new</code> 关键字实例化对象。</li><li>访问类的静态字段（被 <code>final</code> 修饰的编译期常量除外）。</li><li>调用类的静态方法。</li><li>使用反射（如 <code>Class.forName()</code>）动态加载类。</li><li>初始化子类时，如果父类尚未加载，会先触发父类的加载。</li><li>启动类（包含 <code>main()</code> 方法的类）。</li></ul><h3 id="关键点" tabindex="-1"><a class="header-anchor" href="#关键点"><span>关键点</span></a></h3><ul><li><strong>类加载器（ClassLoader）：</strong> 负责加载过程，支持自定义加载逻辑（如从网络、加密文件加载）。</li><li><strong>被动引用不会触发加载：</strong> 例如，通过子类引用父类的静态字段，只会触发父类的加载，子类不会被加载。</li></ul><h2 id="链接-linking" tabindex="-1"><a class="header-anchor" href="#链接-linking"><span>链接（Linking）</span></a></h2><p>链接阶段分为三个子阶段：验证、准备、解析。</p><h3 id="验证-verification" tabindex="-1"><a class="header-anchor" href="#验证-verification"><span>验证（Verification）</span></a></h3><p>验证字节码是否符合 JVM 规范，防止恶意代码破坏虚拟机。包括：</p><ul><li><strong>文件格式验证：</strong> 验证字节码文件的魔数（<code>0xCAFEBABE</code>）、版本号、长度等是否符合规范。</li><li><strong>元数据验证：</strong> 对类的语义进行校验，如是否存在父类、是否继承了 <code>final</code> 类、抽象类的抽象方法是否都已实现等。</li><li><strong>字节码验证：</strong> 分析数据流和控制流，确保程序语义合法，例如类型转换是否安全。</li><li><strong>符号引用验证：</strong> 确保后续解析阶段能正确完成，例如引用的类、字段、方法是否存在且可访问。</li></ul><h3 id="准备-preparation" tabindex="-1"><a class="header-anchor" href="#准备-preparation"><span>准备（Preparation）</span></a></h3><p>为类变量（即被 <code>static</code> 修饰的变量）分配内存并设置初始值（零值）。例如</p><ul><li><strong><code>static</code> 常量：</strong> 若类变量定义为 <code>static int value = 42;</code>，则在此阶段 <code>value</code> 被初始化为 <code>0</code>，而非 <code>42</code>（真正的赋值操作在初始化阶段执行）。</li><li><strong><code>static final</code> 常量：</strong> 若类变量定义为 <code>static final int VALUE = 42;</code>（即编译期常量），则在此阶段直接赋值为 <code>42</code>。</li></ul><h3 id="解析-resolution" tabindex="-1"><a class="header-anchor" href="#解析-resolution"><span>解析（Resolution）</span></a></h3><p>将常量池中的符号引用（Symbolic Reference）替换为直接引用（Direct Reference）。</p><ul><li><strong>符号引用：</strong> 以一组符号来描述所引用的目标，可以是任何形式的字面量，例如将 <code>java.lang.Object</code> 这样的字符串表示。</li><li><strong>直接引用：</strong> 直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li><li><strong>解析过程：</strong> 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和动态调用点等符号引用进行。例如，将 <code>java.lang.Object</code> 替换为指向方法区中 <code>Object</code> 类元数据的指针。</li></ul><h2 id="初始化-initialization" tabindex="-1"><a class="header-anchor" href="#初始化-initialization"><span>初始化（Initialization）</span></a></h2><h3 id="核心任务-1" tabindex="-1"><a class="header-anchor" href="#核心任务-1"><span>核心任务</span></a></h3><p>执行类构造器 <code>&lt;clinit&gt;()</code> 方法（由编译器自动收集类变量的赋值操作和静态代码块 <code>static{}</code> 中的语句生成），完成类变量的赋值和静态代码块的执行。</p><h3 id="触发条件-1" tabindex="-1"><a class="header-anchor" href="#触发条件-1"><span>触发条件</span></a></h3><p>类的主动使用（同加载阶段），且必须保证父类已初始化。</p><h3 id="关键规则" tabindex="-1"><a class="header-anchor" href="#关键规则"><span>关键规则</span></a></h3><ul><li>JVM 保证 <code>&lt;clinit&gt;()</code> 方法的线程安全性，在多线程环境下初始化仅执行一次。</li><li>父类的 <code>&lt;clinit&gt;()</code> 方法会优先于子类的 <code>&lt;clinit&gt;()</code> 方法执行。</li><li><strong>被动引用不会触发初始化：</strong><ul><li>通过子类引用父类的静态字段，只会触发父类的初始化。</li><li>通过数组定义引用类（如 <code>MyClass[] arr = new MyClass[10];</code>），不会触发 <code>MyClass</code> 的初始化。</li><li>访问类的 <code>final static</code> 常量（当常量值在编译期可确定时，视为“编译期常量”），不会触发类的初始化。</li></ul></li></ul><h2 id="使用-using" tabindex="-1"><a class="header-anchor" href="#使用-using"><span>使用（Using）</span></a></h2><p>类完成初始化后，进入可用状态，可以进行以下操作：</p><ul><li>创建对象实例（<code>new</code>）。</li><li>访问静态字段或调用静态方法。</li><li>通过反射调用类的方法或构造器。</li><li>作为父类被其子类初始化时触发初始化。</li></ul><h2 id="卸载-unloading" tabindex="-1"><a class="header-anchor" href="#卸载-unloading"><span>卸载（Unloading）</span></a></h2><h3 id="触发条件-2" tabindex="-1"><a class="header-anchor" href="#触发条件-2"><span>触发条件</span></a></h3><p>当同时满足以下三个条件时，JVM 会回收类的元数据（方法区）及对应的 <code>Class</code> 对象：</p><ol><li>该类的所有实例已被垃圾回收（堆中无存活对象）。</li><li>该类的 <code>Class</code> 对象未被任何地方引用（如反射、静态变量）。</li><li>加载该类的 <code>ClassLoader</code> 实例已被回收。</li></ol><h3 id="常见场景" tabindex="-1"><a class="header-anchor" href="#常见场景"><span>常见场景</span></a></h3><ul><li>使用自定义类加载器动态加载的类，如热部署场景。</li><li>若类的 <code>ClassLoader</code> 未被回收（如缓存泄漏），则类无法卸载。</li></ul><h2 id="类的生命周期阶段总结" tabindex="-1"><a class="header-anchor" href="#类的生命周期阶段总结"><span>类的生命周期阶段总结</span></a></h2><table><thead><tr><th style="text-align:left;">阶段</th><th style="text-align:left;">核心任务</th><th style="text-align:left;">关键规则</th></tr></thead><tbody><tr><td style="text-align:left;">加载</td><td style="text-align:left;">读取字节码，生成 <code>Class</code> 对象</td><td style="text-align:left;">类加载器负责，支持自定义逻辑</td></tr><tr><td style="text-align:left;">链接</td><td style="text-align:left;">验证、准备、解析符号引用</td><td style="text-align:left;">准备阶段仅赋零值，解析可能延迟到初始化后</td></tr><tr><td style="text-align:left;">初始化</td><td style="text-align:left;">执行 <code>&lt;clinit&gt;()</code>，完成静态赋值</td><td style="text-align:left;">父类优先，线程安全，被动引用不触发</td></tr><tr><td style="text-align:left;">使用</td><td style="text-align:left;">通过实例化、反射等方式使用类</td><td style="text-align:left;">类的功能完全可用</td></tr><tr><td style="text-align:left;">卸载</td><td style="text-align:left;">回收类元数据，依赖 GC 和 <code>ClassLoader</code> 回收</td><td style="text-align:left;">需同时满足实例、<code>Class</code> 对象、<code>ClassLoader</code> 回收</td></tr></tbody></table><h2 id="常见异常" tabindex="-1"><a class="header-anchor" href="#常见异常"><span>常见异常</span></a></h2><ul><li><strong><code>NoClassDefFoundError</code>：</strong><ul><li>类在编译期存在，但运行时找不到（如类文件被删除，或类加载器无法加载）。</li><li>这通常发生在类路径配置错误或部署问题导致 JVM 无法在运行时找到所需的类文件。</li></ul></li><li><strong><code>ClassNotFoundException</code>：</strong><ul><li>动态加载类时未找到（如 <code>Class.forName()</code> 传入了错误的类名或类文件不存在）。</li><li>这通常是应用程序尝试通过名称加载一个不存在的类时抛出的。</li></ul></li></ul>',40)]))}const c=a(d,[["render",n]]),r=JSON.parse('{"path":"/notes/interview/mfci36gv/","title":"类的生命周期","lang":"zh-CN","frontmatter":{"title":"类的生命周期","createTime":"2025/08/29 15:55:35","permalink":"/notes/interview/mfci36gv/"},"readingTime":{"minutes":5.13,"words":1538},"git":{"createdTime":1756719716000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JVM/类的生命周期.md","headers":[]}');export{c as comp,r as data};
