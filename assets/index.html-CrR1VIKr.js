import{a as l,c as n,b as e,e as a,f as t,o}from"./app-CAzY0Upz.js";const i={};function c(r,s){return o(),n("div",null,s[0]||(s[0]=[e('<h3 id="使用线程池的好处" tabindex="-1"><a class="header-anchor" href="#使用线程池的好处"><span>使用线程池的好处</span></a></h3><p>线程池通过资源管理和线程复用，避免了频繁创建和销毁线程带来的性能开销。线程创建和销毁涉及系统调用、内存分配和上下文切换，资源消耗较高。线程池预先创建并维护一组线程（核心线程），在任务提交时直接复用空闲线程，而非新建线程。这降低了系统资源消耗（如 CPU 和内存），提高了任务处理效率和系统吞吐量。同时，线程池提供了任务队列、拒绝策略等机制，增强了系统的稳定性和可控性。</p><h3 id="线程池的核心参数" tabindex="-1"><a class="header-anchor" href="#线程池的核心参数"><span>线程池的核心参数</span></a></h3><p>线程池的核心行为由以下七个参数定义（以 <code>ThreadPoolExecutor</code> 为例）：</p><ol><li><strong>核心线程数 (<code>corePoolSize</code>)</strong>：线程池长期维持的最小线程数量，即使空闲也不会被销毁。</li><li><strong>最大线程数 (<code>maximumPoolSize</code>)</strong>：线程池允许创建的最大线程总数（包括核心线程和临时线程）。</li><li><strong>临时线程存活时间 (<code>keepAliveTime</code>)</strong>：当线程数超过核心线程数时，临时线程在空闲状态下的最大存活时间。</li><li><strong>存活时间单位 (<code>unit</code>)</strong>：临时线程存活时间的单位（例如 <code>TimeUnit.SECONDS</code>）。</li><li><strong>任务阻塞队列 (<code>workQueue</code>)</strong>：用于缓存待执行任务的队列（例如 <code>ArrayBlockingQueue</code> 或 <code>LinkedBlockingQueue</code>）。</li><li><strong>线程工厂 (<code>threadFactory</code>)</strong>：用于创建新线程的工厂类（例如 <code>ThreadFactory</code> 接口实现），可定制线程名称、优先级等属性。</li><li><strong>拒绝策略 (<code>rejectedExecutionHandler</code>)</strong>：当任务队列满且线程数达到最大值时，处理新提交任务的策略（例如 <code>AbortPolicy</code>）。</li></ol><h3 id="线程池的工作流程" tabindex="-1"><a class="header-anchor" href="#线程池的工作流程"><span>线程池的工作流程</span></a></h3><p>线程池处理任务的流程遵循以下逻辑：</p><ol><li>任务提交时，优先分配至空闲的核心线程执行。</li><li>若核心线程均处于工作状态（满负载），任务进入阻塞队列等待。</li><li>若阻塞队列已满，线程池创建临时线程（非核心线程）执行新任务，但总线程数不超过最大线程数。</li><li>当线程数达到最大线程数且队列满时，触发拒绝策略处理新任务。</li></ol><h3 id="任务拒绝策略及其选择" tabindex="-1"><a class="header-anchor" href="#任务拒绝策略及其选择"><span>任务拒绝策略及其选择</span></a></h3><p>当线程池无法接受新任务时，拒绝策略定义处理行为。常见策略包括：</p><ul><li><strong><code>AbortPolicy</code></strong>：默认策略，抛出 <code>RejectedExecutionException</code> 异常。适用于允许部分任务失败的非关键场景（如日志记录），但需谨慎使用以避免关键任务丢失（如支付订单）。</li><li><strong><code>DiscardPolicy</code></strong>：静默丢弃新任务，不抛出异常。适用于允许少量任务丢失的低优先级场景（如临时缓存更新或心跳上报）。</li><li><strong><code>DiscardOldestPolicy</code></strong>：移除队列中最早的任务，并尝试提交新任务。适用于实时性要求高的场景（如流数据处理），其中新任务比旧任务价值更高。</li><li><strong><code>CallerRunsPolicy</code></strong>：将任务回退至提交任务的调用线程执行。适用于不允许任务丢失且可接受延迟的场景（如批处理作业），能自然降低提交速率。</li></ul><p><strong>选择原则</strong>：根据业务重要性、任务实时性和系统容错能力决策。关键任务优先选用 <code>CallerRunsPolicy</code> 或定制策略；非关键任务可选 <code>DiscardPolicy</code> 或 <code>AbortPolicy</code>。</p><h3 id="核心线程数和最大线程数的设定" tabindex="-1"><a class="header-anchor" href="#核心线程数和最大线程数的设定"><span>核心线程数和最大线程数的设定</span></a></h3><p>线程数的设定需结合任务类型和系统资源，推荐分步优化：</p>',14),a("ul",null,[a("li",null,[a("p",null,[a("strong",null,"CPU 密集型任务"),t("（如复杂计算）：")]),a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow"),a("annotation",{encoding:"application/x-tex"})])])]),a("span",{class:"katex-html","aria-hidden":"true"})])])]),a("p",null,"\\text{线程数} \\approx \\text{CPU 核数} + 1"),a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow"),a("annotation",{encoding:"application/x-tex"})])])]),a("span",{class:"katex-html","aria-hidden":"true"})])])]),a("p",null,"原因：任务主要消耗 CPU，线程上下文切换开销高，过多线程会降低性能。")]),a("li",null,[a("p",null,[a("strong",null,"I/O 密集型任务"),t("（如网络或磁盘操作）：")]),a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow"),a("annotation",{encoding:"application/x-tex"})])])]),a("span",{class:"katex-html","aria-hidden":"true"})])])]),a("p",{CPU:"",核数:""},"\\text{线程数} \\approx 2 \\times \\text"),a("p",{class:"katex-block"},[a("span",{class:"katex-display"},[a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[a("semantics",null,[a("mrow"),a("annotation",{encoding:"application/x-tex"})])])]),a("span",{class:"katex-html","aria-hidden":"true"})])])]),a("p",null,"原因：I/O 等待时 CPU 可切换线程。")])],-1),e('<p>线程数可参考公式：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>线程数</mtext><mo>=</mo><mtext>CPU 核数</mtext><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mtext>线程等待时间</mtext><mi mathvariant="normal">/</mi><mtext>线程运行总时间</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\text{线程数} = \\text{CPU 核数} \\times (1 + \\text{线程等待时间} / \\text{线程运行总时间}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">线程数</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">CPU </span><span class="mord cjk_fallback">核数</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord cjk_fallback">线程等待时间</span></span><span class="mord">/</span><span class="mord text"><span class="mord cjk_fallback">线程运行总时间</span></span><span class="mclose">)</span></span></span></span></span></p><ul><li>CPU 密集型中线程等待时间无线趋近于 0。</li><li>IO 密集型中线程等待时间无限趋近于线程总运行时间。</li></ul><p>在实际需求中，应先根据公式确定一个初始值，再结合实际业务情况来实践优化：</p><ul><li><strong>压测</strong>：模拟高并发场景（如 JMeter 工具），调整线程数以最大化 CPU 利用率（目标 70%-80%）和最小化任务平均耗时。</li><li><strong>上线后监控</strong>：结合运行时指标（如队列堆积情况）动态调整。</li></ul><div class="hint-container note"><p class="hint-container-title">注</p><p>线程数过多会导致频繁上下文切换，降低性能；需考虑应用中的其他线程和混合任务类型（如 I/O 与计算并存），建议核心线程数固定，最大线程数预留缓冲。</p></div><h3 id="项目上线后线程池的监控指标" tabindex="-1"><a class="header-anchor" href="#项目上线后线程池的监控指标"><span>项目上线后线程池的监控指标</span></a></h3><p>为保障线程池稳定运行，需监控以下指标：</p><ol><li><p><strong>运行时状态指标</strong></p><ul><li><strong>核心线程数</strong>：当前活跃的核心线程数量。 若低于配置值，可能线程回收过度；若等于配置值且任务堆积，需增大核心线程数。</li><li><strong>活跃线程数</strong>：正在执行任务的线程总数。 若持续接近最大线程数，表明负载过高，需扩容或优化任务逻辑。</li><li><strong>队列大小</strong>：任务队列中的待处理任务数。 若长期满载，表明任务处理慢，需增大队列容量或提升任务效率。</li></ul></li><li><p><strong>任务处理效率指标</strong></p><ul><li><strong>任务提交速率</strong>：单位时间提交的任务数。 结合任务完成速率评估吞吐量饱和度。</li><li><strong>任务完成速率</strong>：单位时间完成的任务数。 若低于提交速率，存在堆积风险。</li><li><strong>任务平均耗时</strong>：任务从提交到完成的平均时间。 耗时突增可能因性能问题（如慢 SQL）。</li><li><strong>任务等待时间</strong>：任务在队列的平均等待时间。 过长等待表明核心线程不足或任务执行慢。</li></ul></li><li><p><strong>资源占用指标</strong></p><ul><li><strong>CPU 使用率</strong>：线程池所在节点的 CPU 占用。 高 CPU 使用率但低吞吐量可能因锁竞争；低 CPU 使用率但队列堆积可能因 I/O 阻塞。</li><li><strong>内存占用</strong>：线程池任务消耗的内存（堆或直接内存）。 关注是否有大对象或内存泄漏风险（如 OOM）。</li></ul></li><li><p><strong>异常情况指标</strong></p><ul><li><strong>拒绝任务数</strong>：被拒绝的任务总数。 若拒绝任务数过高，则调整线程数或队列容量。</li><li><strong>线程创建/销毁频率</strong>：单位时间线程的生命周期变化。 频繁变化（线程池震荡）可能因存活时间过短或任务具有突发性。</li><li><strong>线程阻塞时间</strong>：线程因 I/O 或锁等待的阻塞时间占比（可通过 <code>ThreadMXBean</code> 或 APM 工具如 SkyWalking 监控）。</li><li><strong>死锁检测</strong>：监控线程死锁（使用 <code>ThreadMXBean.findDeadlockedThreads()</code>）。</li></ul></li></ol><h3 id="为什么不推荐使用-jdk-的-executors-创建线程池" tabindex="-1"><a class="header-anchor" href="#为什么不推荐使用-jdk-的-executors-创建线程池"><span>为什么不推荐使用 JDK 的 <code>Executors</code> 创建线程池</span></a></h3><p><code>Executors</code> 是 JDK 提供的线程池工厂类，但其返回的线程池存在资源耗尽风险，不推荐使用：</p><ul><li><p><strong><code>newFixedThreadPool</code> 和 <code>newSingleThreadPool</code></strong></p><ul><li><strong>问题</strong>：这两个方法创建的线程池使用的是 <code>LinkedBlockingQueue</code> 作为任务队列，而该队列的默认容量是 <code>Integer.MAX_VALUE</code>（约 21 亿）。这意味着任务队列几乎是“无界”的，当任务提交速度远超线程池处理速度时，队列会不断积累任务，最终可能耗尽内存，导致内存溢出。</li><li><strong>场景</strong>：例如，在高并发场景下，如果任务执行时间较长，提交的任务会持续堆积，队列占用的内存会无限制增长，最终导致系统崩溃。</li></ul></li><li><p><strong><code>newCachedThreadPool</code></strong></p><ul><li><strong>问题</strong>：<code>newCachedThreadPool</code> 创建的线程池允许根据任务需求动态创建线程，最大线程数也是 <code>Integer.MAX_VALUE</code>。在高并发场景下，如果任务提交速度很快，线程池可能会创建大量线程（每个线程都会占用系统资源，如内存和 CPU）。这可能导致： <ul><li><strong>内存溢出</strong>：大量线程的创建会消耗大量内存（每个线程的栈空间通常在 512KB 到 1MB 之间）。</li><li><strong>系统崩溃</strong>：过多线程竞争 CPU 资源，可能导致上下文切换开销激增，系统性能严重下降，甚至崩溃。</li></ul></li><li><strong>场景</strong>：例如，短时间内接收到大量任务请求，线程池会无限制地创建新线程，最终耗尽系统资源。</li></ul></li></ul><p><strong>推荐替代方案</strong>：直接使用 <code>ThreadPoolExecutor</code> 构造函数，显式指定参数（如队列容量和线程数上限），规避资源风险并提供更细粒度控制。</p><h3 id="动态线程池" tabindex="-1"><a class="header-anchor" href="#动态线程池"><span>动态线程池</span></a></h3><p>在实际应用中，任务负载动态变化且环境复杂（如混合 I/O 与计算），需实现动态线程池以灵活调优：</p><ul><li><strong>核心思路</strong>：将线程池参数（如核心线程数、最大线程数）从代码迁移至分布式配置中心（如 Nacos 或 Apollo），支持运行时动态调整并即时生效。</li><li><strong>实施步骤</strong>： <ol><li>监控线上指标（如队列堆积和 CPU 使用率）。</li><li>通过配置中心更新参数，无需重启服务。</li><li>结合压测结果持续优化，确保线程池适应业务峰值。</li></ol></li></ul>',16)]))}const d=l(i,[["render",c]]),m=JSON.parse('{"path":"/notes/interview/fhz7aw89/","title":"线程池","lang":"zh-CN","frontmatter":{"title":"线程池","createTime":"2025/08/25 19:38:42","permalink":"/notes/interview/fhz7aw89/"},"readingTime":{"minutes":7.79,"words":2336},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/线程池.md","headers":[]}');export{d as comp,m as data};
