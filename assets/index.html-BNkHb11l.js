import{a as n,c as r,b as o,d as a,r as i,o as s}from"./app-CAzY0Upz.js";const c={};function d(l,e){const t=i("Mermaid");return s(),r("div",null,[e[0]||(e[0]=o('<p>CAS（Compare And Swap）是一种无锁并发编程的核心机制，用于实现原子操作。它通过硬件指令（如 CPU 的 <code>cmpxchg</code> 指令）确保操作的原子性，避免线程阻塞。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p>CAS 的原理涉及三个操作数：内存位置（V）、预期原值（A）和新值（B）。操作过程如下：</p><ol><li><strong>读取并计算</strong>：线程从主内存中读取共享变量的当前值（V），拷贝到线程工作内存中，进行计算操作得到新值（B）。</li><li><strong>比较并交换</strong>：线程将预期原值（A）与新值（B）一起提交到主内存。 <ul><li>如果主内存中的共享变量值等于预期原值（A），说明在此期间无其他线程修改该变量，操作安全，将新值（B）写入主内存。</li><li>如果主内存中的共享变量值不等于预期原值（A），说明在此期间其他线程已修改该变量，操作不安全，线程不执行写入，而是进入自旋状态。</li></ul></li><li><strong>自旋重试</strong>：线程重新读取主内存中的共享变量值，重复上述计算和比较过程，直至成功更新或达到重试上限。</li></ol>',4)),a(t,{code:"eJx9kM1OwkAUhfc+xbwAr2AiLSCujZsJC1e6NK67wGhbbC0lQSkESKOxidFAS0KkoVheZu7MdOUrOJ3Kz4q7/r5z7r1Xt5c31+hcPUJiypiHCbg9Eidg6DDpgz4jyy9w+5npQnOFLhql0jFSMLUXfD6GVsSWa/ZhwyIgP6NCacgkBeWgivn0lU09SD3B0l6UZ5QLQpVEBdPwmaf32dsDHfnQ9nPiBJG4vdtB9kqnkjsaG8Zs8qihKobI2IQiMAagB1trXyCxs3FqmK+HguPmJ/VsZn3T5l2BVuU+p5h2HXELbXXA8n9XTyzp0rFfIDWJ1HFmOqL28KsKoy4NZWdrPE3FK0QCD19IbGWDjobO/kvhfcbnwV7pH1Fm2fg="}),e[1]||(e[1]=o('<h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><p>CAS 广泛应用于 Java 并发框架中，典型场景包括：</p><ul><li><strong>AQS（AbstractQueuedSynchronizer）</strong>：在 <code>java.util.concurrent.locks</code> 包中，AQS 使用 CAS 管理同步状态（如 <code>state</code> 变量），实现锁的获取和释放。例如，<code>ReentrantLock</code> 通过 CAS 确保线程安全地修改锁状态。</li><li><strong>JUC（Java Util Concurrent）原子类</strong>：如 <code>AtomicInteger</code>、<code>AtomicReference</code> 等，这些类结合 CAS 和 <code>volatile</code> 关键字（保证可见性）实现线程安全。例如，<code>AtomicInteger.incrementAndGet()</code> 方法通过 CAS 自旋更新值，避免 <code>synchronized</code> 锁的开销。</li></ul><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h2><ul><li><p><strong>优点</strong>：</p><ol><li><strong>无锁并发</strong>：通过自旋而非阻塞实现线程安全，减少上下文切换和锁竞争，提升高并发场景下的性能。</li><li><strong>简单高效</strong>：适用于轻量级操作（如计数器更新），代码实现简洁，且硬件支持确保原子性。</li></ol></li><li><p><strong>缺点</strong>：</p><ol><li><strong>自旋消耗 CPU</strong>：在竞争激烈时，线程可能频繁自旋重试，导致 CPU 资源浪费，影响整体系统吞吐量。</li><li><strong>ABA 问题</strong>：如果共享变量值被其他线程修改为 B 后又改回 A，CAS 可能误判为未修改，导致数据不一致。解决方案包括使用版本号（如 <code>AtomicStampedReference</code>）。</li><li><strong>适用场景有限</strong>：仅适合简单操作（如单变量更新），复杂操作需结合其他机制（如锁或 <code>synchronized</code>）。</li></ol></li></ul>',5))])}const m=n(c,[["render",d]]),p=JSON.parse('{"path":"/notes/interview/0403wn25/","title":"CAS","lang":"zh-CN","frontmatter":{"title":"CAS","createTime":"2025/08/26 16:55:30","permalink":"/notes/interview/0403wn25/"},"readingTime":{"minutes":2.53,"words":758},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/CAS.md","headers":[]}');export{m as comp,p as data};
