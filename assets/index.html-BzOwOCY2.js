import{a as e,c as d,b as l,o}from"./app-CAzY0Upz.js";const c={};function a(r,t){return o(),d("div",null,t[0]||(t[0]=[l('<p>执行计划（Execution Plan）是 SQL 语句经 MySQL 查询优化器优化后的具体执行方案，是 SQL 性能分析与优化的关键依据。通过 <code>EXPLAIN</code> 命令可获取执行计划，进而解析以下信息：</p><ul><li>数据表的查询顺序</li><li>数据查询操作类型</li><li>可能命中与实际命中的索引</li><li>每张表的扫描行数</li><li>其他关键执行细节</li></ul><h2 id="执行计划字段" tabindex="-1"><a class="header-anchor" href="#执行计划字段"><span>执行计划字段</span></a></h2><p>执行计划结果包含 12 列，含义如下：</p><table><thead><tr><th style="text-align:left;">列名</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:left;"><code>id</code></td><td style="text-align:left;"><code>SELECT</code> 查询的序列号。相同 <code>id</code> 值表示同一组操作，按序从上到下执行；不同 <code>id</code> 值表示不同的查询组，<code>id</code> 值越大优先级越高。</td></tr><tr><td style="text-align:left;"><code>select_type</code></td><td style="text-align:left;">查询的类型，用于区分普通查询、联合查询、子查询等。</td></tr><tr><td style="text-align:left;"><code>table</code></td><td style="text-align:left;">当前操作所涉及的表名。</td></tr><tr><td style="text-align:left;"><code>partitions</code></td><td style="text-align:left;">匹配的分区信息，对于未分区的表，该列为 <code>NULL</code>。</td></tr><tr><td style="text-align:left;"><code>type</code></td><td style="text-align:left;"><strong>表访问方法</strong>，是衡量查询性能的关键指标，描述了 MySQL 如何查找表中的行。</td></tr><tr><td style="text-align:left;"><code>possible_keys</code></td><td style="text-align:left;">可能被查询优化器选择的索引列表。</td></tr><tr><td style="text-align:left;"><code>key</code></td><td style="text-align:left;">实际被查询优化器选择并使用的索引。如果为 <code>NULL</code>，表示没有使用索引。</td></tr><tr><td style="text-align:left;"><code>key_len</code></td><td style="text-align:left;">实际使用的索引的长度（字节数）。这个值可以帮助判断复合索引中使用了多少列。</td></tr><tr><td style="text-align:left;"><code>ref</code></td><td style="text-align:left;">表示与索引进行比较的列或常量。例如，<code>const</code> 表示常量，<code>col_name</code> 表示某个列。</td></tr><tr><td style="text-align:left;"><code>rows</code></td><td style="text-align:left;"><strong>预估扫描的行数</strong>，表示 MySQL 认为执行查询时必须检查的行数。此值越小越好。</td></tr><tr><td style="text-align:left;"><code>filtered</code></td><td style="text-align:left;">表示经过 <code>WHERE</code> 条件过滤后，剩余记录的百分比。该值越高，表示过滤效果越好。</td></tr><tr><td style="text-align:left;"><code>Extra</code></td><td style="text-align:left;"><strong>额外执行信息</strong>，包含 MySQL 执行查询的详细信息和潜在的性能警告。</td></tr></tbody></table><h3 id="select-type" tabindex="-1"><a class="header-anchor" href="#select-type"><span><code>select_type</code></span></a></h3><p>查询的类型，主要用于<strong>区分普通查询、联合查询、子查询等复杂的查询</strong>，常见的值有：</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>SIMPLE</code></td><td style="text-align:left;">简单的 <code>SELECT</code> 查询，不包含 <code>UNION</code> 或子查询。</td></tr><tr><td style="text-align:left;"><code>PRIMARY</code></td><td style="text-align:left;">对于包含子查询或 <code>UNION</code> 的复杂查询，此为最外层 <code>SELECT</code>。</td></tr><tr><td style="text-align:left;"><code>SUBQUERY</code></td><td style="text-align:left;">在 <code>FROM</code> 子句之外的子查询中的首个 <code>SELECT</code>。</td></tr><tr><td style="text-align:left;"><code>DERIVED</code></td><td style="text-align:left;">在 <code>FROM</code> 子句中的子查询（派生表）中的 <code>SELECT</code>。</td></tr><tr><td style="text-align:left;"><code>UNION</code></td><td style="text-align:left;"><code>UNION</code> 操作中，第二个或后续 <code>SELECT</code>。</td></tr><tr><td style="text-align:left;"><code>UNION RESULT</code></td><td style="text-align:left;"><code>UNION</code> 操作的结果集。</td></tr></tbody></table><h3 id="type" tabindex="-1"><a class="header-anchor" href="#type"><span><code>type</code></span></a></h3><p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：</p><p><code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>index_merge</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p><p>常见的几种类型具体含义如下：</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;"><code>system</code></td><td style="text-align:left;">表中只有一行数据（系统表），这是 <code>const</code> 类型的一个特例，直接从内存中返回。</td></tr><tr><td style="text-align:left;"><code>const</code></td><td style="text-align:left;">通过主键或唯一索引进行等值查询，并且查询优化器将查询转换为一个常量。仅扫描一行数据。</td></tr><tr><td style="text-align:left;"><code>eq_ref</code></td><td style="text-align:left;">在联表查询中，使用主键或唯一索引作为连接条件。对于驱动表的每一行，被驱动表仅匹配一行。</td></tr><tr><td style="text-align:left;"><code>ref</code></td><td style="text-align:left;">使用非唯一索引进行等值查询。可能会匹配到多行数据。</td></tr><tr><td style="text-align:left;"><code>index_merge</code></td><td style="text-align:left;">表示使用了索引合并优化，即利用多个索引来查找并合并结果集。</td></tr><tr><td style="text-align:left;"><code>range</code></td><td style="text-align:left;">对索引进行范围扫描，例如 <code>BETWEEN</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> 等操作。</td></tr><tr><td style="text-align:left;"><code>index</code></td><td style="text-align:left;">全索引扫描，通过遍历整个索引树来获取数据。通常比 <code>ALL</code> 效率高，因为无需回表，但仍需扫描所有索引条目。</td></tr><tr><td style="text-align:left;"><code>ALL</code></td><td style="text-align:left;"><strong>全表扫描</strong>，表示 MySQL 遍历整个表来查找匹配的行。这是性能最差的类型，通常需要优先优化。</td></tr></tbody></table><h3 id="extra" tabindex="-1"><a class="header-anchor" href="#extra"><span><code>Extra</code></span></a></h3><p><code>Extra</code> 列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p><table><thead><tr><th>值</th><th>说明</th><th>性能影响</th></tr></thead><tbody><tr><td><code>Using index</code></td><td>使用覆盖索引（无需回表）</td><td>✅ 高效</td></tr><tr><td><code>Using index condition</code></td><td>使用索引条件下推（存储引擎层提前过滤）</td><td>✅ 优化生效</td></tr><tr><td><code>Using where</code></td><td>使用 <code>WHERE</code> 过滤（未用索引时出现）</td><td>⚠️ 需检查索引使用</td></tr><tr><td><code>Using filesort</code></td><td><strong>文件排序</strong>（磁盘排序，非索引排序）</td><td>❌ 高开销，需优化</td></tr><tr><td><code>Using temporary</code></td><td><strong>创建临时表</strong>（常见于 <code>GROUP BY</code> / <code>ORDER BY</code>）</td><td>❌ 高开销，需优化</td></tr><tr><td><code>Using join buffer</code></td><td>使用连接缓存（驱动表未用索引时出现）</td><td>⚠️ 建议优化关联字段索引</td></tr></tbody></table><div class="hint-container caution"><p class="hint-container-title">重要警示</p><p>出现 <code>Using filesort</code> 或 <code>Using temporary</code> 通常预示性能瓶颈，需优先优化。</p></div>',17)]))}const s=e(c,[["render",a]]),i=JSON.parse('{"path":"/notes/interview/gaacfygl/","title":"执行计划分析","lang":"zh-CN","frontmatter":{"title":"执行计划分析","createTime":"2025/08/30 15:19:42","permalink":"/notes/interview/gaacfygl/"},"readingTime":{"minutes":3.76,"words":1127},"git":{"createdTime":1756719850000,"updatedTime":1757065358000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":3,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/MySQL/执行计划分析.md","headers":[]}');export{s as comp,i as data};
