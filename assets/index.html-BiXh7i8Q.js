import{a as r,c as n,b as e,d as t,r as a,o as d}from"./app-CAzY0Upz.js";const l={};function c(s,o){const i=a("Mermaid");return d(),n("div",null,[o[0]||(o[0]=e('<p>每个 Java 对象在内存中都有一个对象头（Object Header），其中包含 Mark Word 区域。Mark Word 存储对象的运行时数据，包括哈希码（Hash Code）、锁状态标志位（Lock Flag）、GC 分代年龄（GC Age）等。锁状态标志位标识了 <code>Synchronized</code> 的当前状态，为锁升级提供基础支持。</p><h2 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h2><p><code>Synchronized</code> 的实现是分层的，涉及 Java 语言、字节码、JVM 逻辑和操作系统等多个层面：</p><ul><li><p><strong>语言层面</strong>： <code>synchronized</code> 是一个关键字，用于修饰代码块或方法。它定义了临界区（Critical Section），确保同一时间只有一个线程能访问共享资源。</p></li><li><p><strong>字节码层面</strong>： <code>synchronized</code> 对应两条 JVM 字节码指令：</p><ul><li><code>monitorenter</code>：进入临界区，表示需要加锁。</li><li><code>monitorexit</code>：退出临界区，表示需要解锁。 这些指令在编译时生成，指导 JVM 在运行时执行锁操作。</li></ul></li><li><p><strong>JVM 逻辑层面</strong>： JVM 通过 Monitor（监视器）来管理线程竞争。每个锁对象关联一个 Monitor，其内部由三个逻辑区域组成：</p><ul><li><strong>Owner</strong>：当前持有锁的线程。</li><li><strong>EntryList</strong>：等待锁的阻塞线程队列。当锁被占用时，竞争失败的线程进入此队列阻塞。</li><li><strong>WaitSet</strong>：通过 <code>obj.wait()</code> 进入等待状态的线程队列。当线程调用 <code>obj.wait()</code> 时，会释放锁并加入 WaitSet；等待 <code>obj.notify()</code> 唤醒后，重新竞争锁。 具体流程：</li></ul><ol><li>线程执行 <code>monitorenter</code> 时，JVM 检查锁对象的 Monitor。</li><li>若 Owner 为空，线程成为 Owner。</li><li>若 Owner 被占用，线程进入 EntryList 阻塞。</li><li>线程执行 <code>monitorexit</code> 时，JVM 释放锁，并唤醒 EntryList 中的线程进行锁竞争。</li></ol></li><li><p><strong>操作系统层面</strong>： 重量级锁（Heavyweight Lock）涉及用户态到内核态的切换，JVM 需向操作系统申请互斥量（Mutex）。这会导致性能开销较大，尤其在频繁加锁的场景中。</p></li></ul><h3 id="锁升级过程" tabindex="-1"><a class="header-anchor" href="#锁升级过程"><span>锁升级过程</span></a></h3><p><code>Synchronized</code> 在 JDK 1.6 后引入了锁升级机制，针对不同线程竞争强度进行优化，过程分为四个阶段：</p>',6)),t(i,{code:"eJxLL0osyFDwCeJSAALH6GfTF7yc0hiroKtrV/N81/7nK7pfLpv2bM3CF+v2v5y+rkbBKfppY//TCRNBisBanMBKny6Z9WTHKoiG56vnPdnVWaPgHP1i7+6X7f3Pdy2Hq3aGGAxW8bRrwdPO5TUKLtEv23uR1AEAFCdMXQ=="}),o[1]||(o[1]=e("<ul><li><p><strong>无锁到偏向锁</strong>： 初始状态下，锁为无锁（Lock-Free）。当线程首次进入 <code>Synchronized</code> 代码块时，JVM 将锁标记为偏向锁（Biased Lock），并在锁对象的 Mark Word 中记录线程 ID。此后，该线程重入锁时，通过比较线程 ID 直接获取锁，避免了加锁开销。此机制优化了无竞争或低竞争的重入场景。</p></li><li><p><strong>偏向锁到轻量级锁</strong>： 当其他线程尝试获取锁时（竞争出现），JVM 撤销偏向锁。多个线程通过 CAS（Compare-And-Swap）自旋竞争锁：</p><ol><li>将锁对象头的 Mark Word 复制到线程栈的锁记录（Lock Record）中。</li><li>线程尝试 CAS 操作，将 Mark Word 更新为指向锁记录的指针。</li><li>若 CAS 成功，线程获得轻量级锁（Lightweight Lock）。此阶段通过自旋减少阻塞，适用于低至中等竞争场景。</li></ol></li><li><p><strong>轻量级锁到重量级锁</strong>： 当竞争加剧（多个线程短时间高并发请求），轻量级锁的自旋会占用 CPU 资源。JVM 触发锁膨胀（Lock Inflation），将锁升级为重量级锁。重量级锁基于 Monitor 机制，竞争失败的线程直接阻塞（不占用 CPU），由操作系统调度。此机制适配高竞争场景。</p></li></ul><p>Synchronized 的锁升级设计旨在适配不同竞争强度的场景：</p><ul><li>偏向锁优化单线程重入。</li><li>轻量级锁通过自旋减少阻塞开销。</li><li>重量级锁在激烈竞争中避免 CPU 浪费。</li></ul><p>该机制平衡了性能与资源利用率，是 Java 并发编程的核心优化之一。</p>",4))])}const m=r(l,[["render",c]]),g=JSON.parse('{"path":"/notes/interview/522fyxos/","title":"Synchronized","lang":"zh-CN","frontmatter":{"title":"Synchronized","createTime":"2025/08/26 15:07:24","permalink":"/notes/interview/522fyxos/"},"readingTime":{"minutes":3.24,"words":971},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/Synchronized.md","headers":[]}');export{m as comp,g as data};
