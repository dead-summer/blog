import{a as e,c as i,b as n,o as a}from"./app-CAzY0Upz.js";const l={};function d(p,s){return a(),i("div",null,s[0]||(s[0]=[n(`<h2 id="秒杀系统" tabindex="-1"><a class="header-anchor" href="#秒杀系统"><span>秒杀系统</span></a></h2><h3 id="在你的秒杀场景下-是如何解决超卖问题的" tabindex="-1"><a class="header-anchor" href="#在你的秒杀场景下-是如何解决超卖问题的"><span>在你的秒杀场景下，是如何解决超卖问题的？</span></a></h3><p>在秒杀这种高并发场景下，库存的准确性至关重要，超卖问题是必须解决的核心挑战。解决超卖问题的关键在于，<strong>如何在高并发环境下对库存进行原子性的扣减操作</strong>。</p><p>我主要通过以下几种方式来综合解决：</p><ol><li><p><strong>前端层面拦截</strong>：</p><ul><li>通过 JS 或前端页面，对秒杀按钮进行置灰处理。当用户点击一次后，按钮变为不可用，防止用户因网络延迟而重复点击，向后端发送大量无效请求。这是一种初步的流量削减手段。</li></ul></li><li><p>后端数据库层面控制：</p><p>这是解决超卖问题的根本。主要利用数据库的事务和锁机制。</p><ul><li><p><strong>使用乐观锁 (Optimistic Locking)</strong>：</p><ul><li><p><strong>原理</strong>：在商品库存表中增加一个 <code>version</code> 字段（版本号）。</p></li><li><p><strong>流程</strong>：</p><ol><li><p>查询库存时，将 <code>version</code> 字段一同查出：<code>SELECT stock, version FROM products WHERE id = ?</code>。</p></li><li><p>在应用程序中判断库存是否足够。</p></li><li><p>如果库存足够，执行更新操作，更新条件中必须包含版本号：<code>UPDATE products SET stock = stock - 1, version = version + 1 WHERE id = ? AND stock &gt; 0 AND version = ?</code>。</p></li></ol></li><li><p><strong>效果</strong>：如果多个线程同时执行更新，只有第一个线程的 <code>UPDATE</code> 语句能成功（因为它的 <code>version</code> 匹配），其他线程会因为 <code>version</code> 不匹配而更新失败（返回影响行数为 0）。更新失败的线程可以进行重试或直接告知用户秒杀失败。</p></li><li><p><strong>优点</strong>：乐观锁避免了使用数据库的排他锁，减少了线程阻塞，在高并发读多写少的场景下性能较好。</p></li></ul></li><li><p><strong>使用悲观锁 (Pessimistic Locking)</strong>：</p><ul><li><p><strong>原理</strong>：在事务中，通过 <code>SELECT ... FOR UPDATE</code> 语句对库存记录行加排他锁。</p></li><li><p><strong>流程</strong>：</p><p>SQL</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>START TRANSACTION;</span></span>
<span class="line"><span>SELECT stock FROM products WHERE id = ? FOR UPDATE;</span></span>
<span class="line"><span>-- 在应用代码中判断库存是否足够</span></span>
<span class="line"><span>-- 如果足够，则执行 UPDATE</span></span>
<span class="line"><span>UPDATE products SET stock = stock - 1 WHERE id = ?;</span></span>
<span class="line"><span>COMMIT;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>效果</strong>：当一个事务通过 <code>FOR UPDATE</code> 锁住某行记录后，其他任何试图修改或锁定该行的事务都会被阻塞，直到前一个事务提交或回滚。这保证了同一时间只有一个线程能操作库存，从而避免了超卖。</p></li><li><p><strong>缺点</strong>：悲观锁会长时间持有锁，导致其他线程等待，降低了并发性能。在秒杀场景下，如果锁竞争激烈，可能会造成大量线程阻塞，甚至导致数据库连接池耗尽。</p></li></ul></li></ul></li><li><p>使用 Redis 原子操作：</p><p>为了进一步提升性能，可以将库存预热到 Redis 中，利用 Redis 的单线程特性和原子操作来扣减库存。</p><ul><li><p><strong><code>DECR</code> 命令</strong>：</p><ol><li><p>系统启动时，将商品库存加载到 Redis 中，例如 <code>SET stock:product_id 100</code>。</p></li><li><p>用户秒杀时，执行 <code>DECR stock:product_id</code> 命令。</p></li><li><p><code>DECR</code> 是原子操作。如果执行后返回值大于等于 <code>0</code>，则表示抢购成功；如果小于 <code>0</code>，则表示库存已空，抢购失败。对于已经失败的请求，需要立即执行 <code>INCR</code> 将库存加回来。</p></li></ol></li><li><p>Lua 脚本：</p><p>为了将“判断库存并扣减”这个组合操作变为原子性，可以使用 Lua 脚本。</p><p>Lua</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>local stock = redis.call(&#39;get&#39;, KEYS[1])</span></span>
<span class="line"><span>if tonumber(stock) &gt; 0 then</span></span>
<span class="line"><span>    redis.call(&#39;decr&#39;, KEYS[1])</span></span>
<span class="line"><span>    return 1</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>    return 0</span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 <code>EVAL</code> 命令执行此脚本，可以保证整个操作的原子性，避免了 <code>DECR</code> 后判断的非原子性问题。</p></li></ul></li></ol><p>在我的项目中，采用了**“Redis 预减库存 + 数据库乐观锁”**的组合方案：</p><ul><li><p><strong>流量入口层</strong>：使用 Redis 的原子操作（如 Lua 脚本）进行库存预减。绝大部分请求在 Redis 层就被过滤掉了，只有成功抢到资格的请求才能进入后续流程。</p></li><li><p><strong>持久化层</strong>：成功通过 Redis 预减库存的请求，会进入创建订单的流程。在数据库层面，通过<strong>乐观锁</strong>来扣减真实库存，这作为最后一道防线，确保了数据库层面库存的最终准确性，并解决了 Redis 可能因宕机导致的数据丢失问题。</p></li></ul>`,7)]))}const t=e(l,[["render",d]]),c=JSON.parse('{"path":"/notes/interview/x9wji5c1/","title":"黑马点评","lang":"zh-CN","frontmatter":{"title":"黑马点评","createTime":"2025/07/24 22:40:57","permalink":"/notes/interview/x9wji5c1/"},"readingTime":{"minutes":3.61,"words":1083},"git":{"createdTime":1753699516000,"updatedTime":1753699516000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/项目/黑马点评.md","headers":[]}');export{t as comp,c as data};
