import{a as l,c as a,b as r,o as s}from"./app-CAzY0Upz.js";const i={};function t(o,e){return s(),a("div",null,e[0]||(e[0]=[r('<h2 id="全量同步" tabindex="-1"><a class="header-anchor" href="#全量同步"><span>全量同步</span></a></h2><p>全量同步发生在 Slave 节点首次连接 Master 或数据差异过大时，涉及完整数据集的传输。</p><h3 id="全量同步流程" tabindex="-1"><a class="header-anchor" href="#全量同步流程"><span>全量同步流程</span></a></h3><ol><li><strong>同步请求</strong>：Slave 向 Master 发送同步请求，声明自身 replid 和 offset。</li><li><strong>首次同步判断</strong>：Master 校验 Slave 的 replid： <ul><li>若与 Master 的 replid 不同，判定为第一次同步，进入全量流程。</li></ul></li><li><strong>版本信息返回</strong>：Master 返回自身 replid 和 offset，Slave 保存该信息。</li><li><strong>RDB 文件生成</strong>： <ul><li>Master 执行 <code>BGSAVE</code> 命令，生成 RDB 快照文件。</li><li>生成期间，Master 将新写入命令记录到 <code>repl_baklog</code>（内存缓冲区）。</li></ul></li><li><strong>RDB 文件传输</strong>：Master 发送 RDB 文件至 Slave。</li><li><strong>数据加载与命令重放</strong>： <ul><li>Slave 清空本地数据，加载 RDB 文件。</li><li>Master 发送 <code>repl_baklog</code> 中的缓冲命令，Slave 执行以同步最新数据。</li></ul></li></ol><h3 id="判断是否为第一次同步" tabindex="-1"><a class="header-anchor" href="#判断是否为第一次同步"><span>判断是否为第一次同步</span></a></h3><p>Master 通过比对 replid 判断是否首次同步；offset 用于增量同步时的数据定位：</p><ul><li><strong>Replication ID (replid)</strong>： <ul><li>唯一标识数据集，Master 生成唯一 replid，Slave 继承 Master 的 replid。</li><li>若 Slave 的 replid 与 Master 不同，则判定为第一次同步（需全量同步）。</li></ul></li><li><strong>Offset（偏移量）</strong>： <ul><li>记录 <code>repl_baklog</code> 中的命令位置，随数据写入递增。</li><li>若 Slave 的 offset 小于 Master，说明数据落后，但仅当 replid 一致时才触发增量同步。</li></ul></li></ul><h2 id="增量同步" tabindex="-1"><a class="header-anchor" href="#增量同步"><span>增量同步</span></a></h2><p>增量同步适用于 Slave 短暂断连后恢复连接，仅传输差异数据，提升效率。</p><h3 id="增量同步流程" tabindex="-1"><a class="header-anchor" href="#增量同步流程"><span>增量同步流程</span></a></h3><ol><li><strong>同步请求</strong>：Slave 向 Master 发送同步请求，携带自身 replid 和 offset。</li><li><strong>非首次同步判断</strong>：Master 校验 replid 一致且 offset 有效，返回 <code>CONTINUE</code> 响应。</li><li><strong>命令传输</strong>：Master 根据 Slave 的 offset，从 <code>repl_baklog</code> 缓冲区提取未同步命令并发送。</li><li><strong>命令执行</strong>：Slave 接收并执行命令，完成数据同步。</li></ol><div class="hint-container note"><p class="hint-container-title">注</p><p>复制积压缓冲区（<code>repl_backlog</code>）是一个固定大小的环形缓冲区。如果 Slave 断开连接的时间过长，导致其需要同步的 <code>offset</code> 对应的数据已经被 Master 的新数据覆盖，Master 将无法提供增量同步所需的数据。在这种情况下，Master 会强制 Slave 进行全量同步。</p></div><h2 id="实践优化" tabindex="-1"><a class="header-anchor" href="#实践优化"><span>实践优化</span></a></h2><p>全量同步资源消耗高（磁盘 I/O、网络 I/O），优化目标包括减少全量同步频率、提升效率及降低 Master 负载。</p><h3 id="针对全量同步的优化思路" tabindex="-1"><a class="header-anchor" href="#针对全量同步的优化思路"><span>针对全量同步的优化思路</span></a></h3><ol><li><strong>开启无磁盘复制（Diskless Replication）</strong>： <ul><li>配置 <code>repl-diskless-sync yes</code>。</li><li>启用后，Master 在进行全量同步时将不再生成 RDB 文件到磁盘，而是直接将 RDB 数据通过网络流式传输给 Slave。</li><li>这可以显著减少磁盘 I/O，提高全量同步的效率，尤其是在 SSD 性能不佳或磁盘 I/O 成为瓶颈的环境中。但会增加 Master 的网络 I/O 压力。</li></ul></li><li><strong>控制 Redis 单节点内存占用</strong>： <ul><li>较小的内存占用意味着 RDB 文件更小，从而减少全量同步时的磁盘 I/O（如果未开启无磁盘复制）和网络 I/O。</li><li>合理规划数据存储，避免单个 Redis 实例存储过大数据量。</li></ul></li><li><strong>减少全量同步的概率</strong>： <ul><li><strong>适当提高 <code>repl_backlog</code> 内存缓冲区的大小</strong>： <ul><li>通过配置 <code>repl-backlog-size</code> 参数来调整。</li><li>更大的缓冲区可以保留更长时间的命令历史，从而允许 Slave 在断开连接较长时间后仍能进行增量同步，减少全量同步的发生。</li><li>缓冲区大小应根据 Master 的写入速度和 Slave 的平均断线时间来估算。</li></ul></li><li><strong>尽快实现故障恢复</strong>：当 Slave 宕机时，应尽快恢复，以避免其断连时间过长，导致 <code>repl_backlog</code> 中的数据被覆盖。</li></ul></li></ol><h3 id="优化-master-同步压力" tabindex="-1"><a class="header-anchor" href="#优化-master-同步压力"><span>优化 Master 同步压力</span></a></h3><p>如果存在大量 Slave 节点直接连接到 Master 进行数据同步，Master 的 CPU、内存和网络带宽都可能成为瓶颈。</p><ol><li><strong>限制一个 Master 上的 Slave 节点数量</strong>： <ul><li>根据 Master 的硬件资源和网络带宽，合理限制直接连接的 Slave 数量。</li></ul></li><li><strong>采用主 - 从 - 从链式复制结构</strong>： <ul><li>在大型部署中，可以采用链式复制（<code>Master -&gt; Slave1 -&gt; Slave2 -&gt; ...</code>）或树状复制结构。</li><li>这种方式可以分散 Master 的复制压力，提高整体系统的可伸缩性。但需要注意，链条越长，数据同步的延迟可能越高。</li></ul></li></ol>',19)]))}const d=l(i,[["render",t]]),c=JSON.parse('{"path":"/notes/interview/xebdd7yg/","title":"主从数据同步","lang":"zh-CN","frontmatter":{"title":"主从数据同步","createTime":"2025/09/02 18:05:34","permalink":"/notes/interview/xebdd7yg/"},"readingTime":{"minutes":3.75,"words":1125},"git":{"createdTime":1757065439000,"updatedTime":1757065439000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Redis/主从数据同步.md","headers":[]}');export{d as comp,c as data};
