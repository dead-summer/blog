import{a,c as s,b as t,d as e,r as i,o as d}from"./app-CAzY0Upz.js";const r={};function l(g,o){const n=i("Mermaid");return d(),s("div",null,[o[0]||(o[0]=t('<h2 id="日志层级与作用域" tabindex="-1"><a class="header-anchor" href="#日志层级与作用域"><span>日志层级与作用域</span></a></h2><table><thead><tr><th>日志类型</th><th>所属层级</th><th>作用引擎</th><th>核心用途</th></tr></thead><tbody><tr><td><strong>Redo Log</strong></td><td>存储引擎层</td><td>仅 InnoDB</td><td>保证事务持久性</td></tr><tr><td><strong>Undo Log</strong></td><td>存储引擎层</td><td>仅 InnoDB</td><td>事务原子性 &amp; MVCC 支持</td></tr><tr><td><strong>BinLog</strong></td><td>Server 层</td><td>所有引擎</td><td>数据备份/主从同步/灾难恢复</td></tr></tbody></table><h2 id="redo-log-重做日志" tabindex="-1"><a class="header-anchor" href="#redo-log-重做日志"><span>Redo Log（重做日志）</span></a></h2><p>Redo Log 是 InnoDB 存储引擎用于保证事务 <strong>持久性 (Durability)</strong> 的核心机制。它属于<strong>物理日志</strong>，记录的是数据页在磁盘上的物理修改（页号 + 偏移量 + 修改内容），而不是 SQL 语句。</p><h3 id="redo-log-保证事务持久性的原理" tabindex="-1"><a class="header-anchor" href="#redo-log-保证事务持久性的原理"><span>Redo Log 保证事务持久性的原理</span></a></h3><h4 id="_1-wal-技术" tabindex="-1"><a class="header-anchor" href="#_1-wal-技术"><span>1. WAL 技术</span></a></h4><p>直接刷盘痛点：</p><ol><li><strong>性能问题</strong>：每次数据修改都需磁盘 I/O（随机写），效率极低</li><li><strong>持久性风险</strong>：异步刷盘时崩溃会导致内存脏页丢失</li></ol><p>为了平衡数据安全与系统性能，InnoDB 采用了 <strong>预写日志 (Write-Ahead Logging, WAL)</strong> 技术。当数据发生变更时，InnoDB 不会立即将修改后的数据页（称为脏页）写入磁盘，取而代之的步骤是：</p><ol><li><strong>记录日志</strong>: 首先将数据的物理修改内容记录到 Redo Log 中。</li><li><strong>日志刷盘</strong>: 在事务提交时，确保 Redo Log 被成功写入磁盘。</li><li><strong>延迟刷盘</strong>: 内存中的脏页则会在后续某个时间点由后台线程异步刷回磁盘。</li></ol><h4 id="_2-崩溃恢复流程" tabindex="-1"><a class="header-anchor" href="#_2-崩溃恢复流程"><span>2. 崩溃恢复流程</span></a></h4><ul><li><strong>崩溃前</strong>：有些脏页可能还停留在内存中，还没刷到磁盘。</li><li><strong>崩溃后</strong>：数据库重启时，InnoDB 会扫描 Redo Log： <ul><li>如果发现日志里记录了某个事务的完整提交信息，就用日志对数据文件进行 <strong>重做 (redo)</strong>，恢复事务修改过的数据页，确保数据不会丢失。</li><li>如果日志记录不完整（事务未提交），则直接丢弃。</li></ul></li></ul><p>这样，Redo Log 通过 <strong>先写日志，再写数据</strong> 的策略，确保了事务提交的持久性。</p><h4 id="_3-redo-log-与-binlog-的配合" tabindex="-1"><a class="header-anchor" href="#_3-redo-log-与-binlog-的配合"><span>3. Redo Log 与 BinLog 的配合</span></a></h4><ul><li>InnoDB 事务提交时会同时写 <strong>Redo Log</strong>（存储引擎层，保证崩溃恢复）和 <strong>BinLog</strong>（Server 层，保证复制和归档）。</li><li>为避免主从不一致，MySQL 采用 <strong>两阶段提交 (Two-Phase Commit, 2PC)</strong> 协调 Redo Log 和 BinLog： <ol><li><strong>prepare 阶段</strong>：写入 Redo Log 并标记为 prepare 状态。</li><li><strong>写 BinLog</strong>：生成事务对应的 BinLog 并刷盘。</li><li><strong>commit 阶段</strong>：将 Redo Log 状态修改为 commit，事务提交完成。</li></ol></li></ul><p>这样即使在 <strong>BinLog 已写成功但 Redo Log 未提交</strong> 或 <strong>Redo Log 已提交但 BinLog 未写成功</strong> 的场景下，也能通过恢复逻辑避免数据不一致。</p><h2 id="undo-log-回滚日志" tabindex="-1"><a class="header-anchor" href="#undo-log-回滚日志"><span>Undo Log（回滚日志）</span></a></h2><p>Undo Log 是 InnoDB 存储引擎的逻辑日志，主要承担两大核心职责：保证事务的 <strong>原子性 (Atomicity)</strong> 和支持 <strong>多版本并发控制 (MVCC)</strong>。</p><h3 id="undo-log-保证事务原子性的原理" tabindex="-1"><a class="header-anchor" href="#undo-log-保证事务原子性的原理"><span>Undo Log 保证事务原子性的原理</span></a></h3><p>Undo Log 记录了与数据修改操作完全相反的逻辑操作。</p><ul><li>当执行 <code>INSERT</code> 时，它记录一条对应的 <code>DELETE</code>。</li><li>当执行 <code>UPDATE</code> 时，它记录一个将数据恢复到修改前版本的 <code>UPDATE</code>。</li><li>当执行 <code>DELETE</code> 时，它记录一条对应的 <code>INSERT</code>。</li></ul><p>如果事务执行过程中发生错误或用户主动执行 <code>ROLLBACK</code>，InnoDB 就会利用 Undo Log 执行反向操作，将数据恢复至事务开始前的状态，从而保证事务的原子性。</p>',22)),e(n,{code:"eJxLL0osyFDwCeJSUHCMfrp38tPO3mdTNzzrXfdiYU+sgq6unYJT9LM5Dc+mbQjNS8lX8MlPjwUqdQLJ1BTl5+TEF+Rn5pWkFtUoOEc/m778eWfHszlrkJU6Y1HqEv1s9ha4aj09vVguAKvCOpQ="}),o[1]||(o[1]=t('<h3 id="undo-log-支持-mvcc-的原理" tabindex="-1"><a class="header-anchor" href="#undo-log-支持-mvcc-的原理"><span>Undo Log 支持 MVCC 的原理</span></a></h3><p>当一行数据被修改时，InnoDB 会将该行的旧版本数据存入 Undo Log，并通过数据行中的隐藏字段 <code>roll_pointer</code> (回滚指针) 将所有历史版本串联起来，形成一个 <strong>版本链</strong>。</p><p>当一个读事务（<code>SELECT</code>）启动时，InnoDB 会为其创建一个读视图（Read View）。在读取数据时，InnoDB 会沿着版本链，根据读视图的规则找到对当前事务可见的那个版本，从而实现非阻塞的并发读取。</p><h2 id="binlog-二进制日志" tabindex="-1"><a class="header-anchor" href="#binlog-二进制日志"><span>BinLog（二进制日志）</span></a></h2><p>BinLog 是 MySQL Server 层的归档日志，记录了所有对数据库表结构（DDL）和表数据（DML）进行修改的操作。它不记录 <code>SELECT</code> 或 <code>SHOW</code> 等查询操作。</p><h3 id="binlog-的主要用途" tabindex="-1"><a class="header-anchor" href="#binlog-的主要用途"><span>BinLog 的主要用途</span></a></h3><ul><li><strong>主从复制</strong>: Master 节点将 BinLog 事件传输给 Slave 节点，Slave 通过重放这些事件来达到与 Master 数据一致的效果。</li><li><strong>数据恢复</strong>: 可用于基于时间点的精确恢复。通过结合全量备份文件和指定时间段内的 BinLog，可以将数据库恢复到任意时刻的状态。</li></ul><h3 id="binlog-的写入时机" tabindex="-1"><a class="header-anchor" href="#binlog-的写入时机"><span>BinLog 的写入时机</span></a></h3><p>事务提交时，Server 层会将该事务中的所有操作写入 BinLog。</p><h3 id="binlog-的三种格式对比" tabindex="-1"><a class="header-anchor" href="#binlog-的三种格式对比"><span>BinLog 的三种格式对比</span></a></h3><table><thead><tr><th>格式</th><th>记录内容</th><th>优点</th><th>缺点</th><th>应用场景</th></tr></thead><tbody><tr><td><strong>Statement</strong></td><td>SQL 原文</td><td>日志量小</td><td>主从不一致风险（如使用 <code>NOW()</code> 等时间函数，导致主从同步后数据不相同）</td><td>基本弃用</td></tr><tr><td><strong>Row</strong></td><td>行数据变更（前/后镜像）</td><td>数据一致性 100% 保证</td><td>日志体积大，网络 I/O 高</td><td>强一致性场景</td></tr><tr><td><strong>Mixed</strong></td><td>自动选择 Statement 或 Row</td><td>性能与一致性平衡</td><td>仍需人工监控</td><td>生产环境默认配置</td></tr></tbody></table><h2 id="日志协作流程" tabindex="-1"><a class="header-anchor" href="#日志协作流程"><span>日志协作流程</span></a></h2>',12)),e(n,{code:"eJwrTi0sTc1LTnXJTEwvSszlUgCCgsSikszkzILEvBIF55zM1LwSDOHg1KKy1CIMYc+8vHwXJwxhl8zibC6wKMQ4XTs7iAFWCk/7J77Yul0hNMDFMcRV4cmu7qddC8EqIQqAKiFmWik861z+YmHPs6kbnvWue7J/3bMpO8HqINJI6p5Pmf+sY4JCaF5KvoJPfrqCxsuG3S/2TXw6e96z3bM08eoJSoXped658vmENog1aHpAnrGCuvRZ/4Qnu5Y8m77tacd2uG5U52NX3jZTwSkzD6YYzeyne5qerV0KNPJFS//LhVvf7+lwzkhNzi7Iz8wreb+nkwsAEcG1iQ=="}),o[2]||(o[2]=t('<div class="hint-container note"><p class="hint-container-title">注</p><p>Redo Log 与 BinLog 通过<strong>两阶段提交（2PC）</strong> 保证一致性，先写 Redo Log（prepare）→ 写 BinLog → 提交 Redo Log（commit）。</p></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><h3 id="直接刷脏页和写入-redo-log-不都是一次磁盘-io-吗-为什么选择后者" tabindex="-1"><a class="header-anchor" href="#直接刷脏页和写入-redo-log-不都是一次磁盘-io-吗-为什么选择后者"><span>直接刷脏页和写入 Redo Log 不都是一次磁盘 IO 吗？为什么选择后者？</span></a></h3><p>刷脏页和写 Redo Log 虽然都涉及一次磁盘 IO，但代价完全不同：</p><ol><li>刷脏页是随机写，写整页；Redo Log 是顺序写，写量小。</li><li>Redo Log 可以先落盘保证事务持久性，再异步、批量地刷脏页，提高并发性能。</li><li>即使宕机，Redo Log 也能恢复数据，直接刷脏页做不到。</li></ol><p>所以数据库普遍采用 “先写日志 (WAL)，再刷脏页” 的机制。</p><h3 id="事务执行流程" tabindex="-1"><a class="header-anchor" href="#事务执行流程"><span>事务执行流程</span></a></h3><p>以 UPDATE 为例，假设执行 SQL 语句：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">UPDATE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> accounts </span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">SET</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> balance </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> balance </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 100</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> WHERE</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> id </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>InnoDB 在内存中找到 <code>id=1</code> 所在的数据页，并修改其 <code>balance</code> 字段。</li><li>生成一条 Redo Log，记录：“在数据页 A 的偏移量 B 处，将值从 500 修改为 400”。</li><li>事务提交时，将这条 Redo Log 写入磁盘。</li><li>若此时数据库崩溃，即使包含 <code>id=1</code> 的数据页尚未刷盘，重启后 InnoDB 依然能通过 Redo Log 恢复此次修改，保证数据的持久性。</li></ol>',10))])}const p=a(r,[["render",l]]),c=JSON.parse('{"path":"/notes/interview/lfoy5mdk/","title":"日志","lang":"zh-CN","frontmatter":{"title":"日志","createTime":"2025/07/26 20:00:24","permalink":"/notes/interview/lfoy5mdk/"},"readingTime":{"minutes":5.75,"words":1724},"git":{"createdTime":1753699516000,"updatedTime":1757065358000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":4,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/MySQL/日志.md","headers":[]}');export{p as comp,c as data};
