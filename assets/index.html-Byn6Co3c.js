import{a as i,c as a,b as e,o as h}from"./app-CAzY0Upz.js";const n={};function l(k,s){return h(),a("div",null,s[0]||(s[0]=[e(`<h2 id="_5-1-hashmap-的工作原理" tabindex="-1"><a class="header-anchor" href="#_5-1-hashmap-的工作原理"><span>5.1 HashMap 的工作原理</span></a></h2><p><code>HashMap</code> 是一种键 - 值（key-value）映射表，它通过 key 快速查找对应的 value。<code>HashMap</code> 内部使用一个大数组存储所有 value，并根据 key 直接计算出 value 应该存储在哪个索引，从而实现快速存取。这种方式是一种典型的空间换时间策略。</p><h2 id="_5-2-key-的比较" tabindex="-1"><a class="header-anchor" href="#_5-2-key-的比较"><span>5.2 Key 的比较</span></a></h2><p>当我们使用 <code>key</code> 从 <code>Map</code> 中获取 <code>value</code> 时，传入的 <code>key</code> 对象不一定与当初放入 <code>Map</code> 中的 <code>key</code> 对象是同一个对象。 换句话说，两个 <code>key</code> 对象可能是内容相同，但并非指向内存中的同一地址。</p><p>为了验证这一点，参考以下示例代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> java</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">util</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">HashMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> java</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">util</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> key1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">a</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> HashMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 123</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> key2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">a</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 123</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key1 </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> key2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // false</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">key1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">equals</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">key2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // true</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码的运行结果可以看出，<code>key1 == key2</code> 的结果是 <code>false</code>，这意味着 <code>key1</code> 和 <code>key2</code> 指向的是不同的对象。 但是，<code>key1.equals(key2)</code> 的结果是 <code>true</code>，这意味着 <code>key1</code> 和 <code>key2</code> 的内容相同。</p><p><code>HashMap</code> 内部通过 <code>equals()</code> 方法比较 <code>key</code> 是否相等。 因此，作为 <code>HashMap</code> 的 <code>key</code> 的对象，必须正确覆写 <code>equals()</code> 方法。 这与在 <code>List</code> 中查找元素时需要正确覆写 <code>equals()</code> 方法是类似的。 如果 <code>key</code> 对象没有正确覆写 <code>equals()</code> 方法，<code>HashMap</code> 可能无法正确地找到对应的 <code>value</code>。</p><h2 id="_5-3-hashcode-方法的作用" tabindex="-1"><a class="header-anchor" href="#_5-3-hashcode-方法的作用"><span>5.3 hashCode() 方法的作用</span></a></h2><p><code>HashMap</code> 通过 <code>key</code> 对象的 <code>hashCode()</code> 方法计算索引，相同的 <code>key</code> 对象（使用 <code>equals()</code> 判断时返回 <code>true</code>）必须计算出相同的索引，否则相同的 <code>key</code> 每次取出的 <code>value</code> 就不一定对。</p><p>因此，正确使用 <code>Map</code> 必须保证：</p><ol><li><p>作为 <code>key</code> 的对象必须正确覆写 <code>equals()</code> 方法，相等的两个 <code>key</code> 实例调用 <code>equals()</code> 必须返回 <code>true</code>；</p></li><li><p>作为 <code>key</code> 的对象还必须正确覆写 <code>hashCode()</code> 方法，且 <code>hashCode()</code> 方法要严格遵循以下规范：</p><ul><li>如果两个对象相等，则两个对象的 <code>hashCode()</code> 必须相等；</li><li>如果两个对象不相等，则两个对象的 <code>hashCode()</code> 尽量不要相等。</li></ul></li></ol><p>对应两个实例 <code>a</code> 和 <code>b</code>：</p><ul><li>如果 <code>a</code> 和 <code>b</code> 相等，那么 <code>a.equals(b)</code> 一定为 <code>true</code>，则 <code>a.hashCode()</code> 必须等于 <code>b.hashCode()</code>；</li><li>如果 <code>a</code> 和 <code>b</code> 不相等，那么 <code>a.equals(b)</code> 一定为 <code>false</code>，则 <code>a.hashCode()</code> 和 <code>b.hashCode()</code> 尽量不要相等。</li></ul><p>第一条规范是正确性，必须保证实现，否则 <code>HashMap</code> 不能正常工作。第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的 <code>hashCode()</code>，会造成 <code>Map</code> 内部存储冲突，使存取的效率下降。</p><h2 id="_5-4-hashcode-方法的编写" tabindex="-1"><a class="header-anchor" href="#_5-4-hashcode-方法的编写"><span>5.4 hashCode() 方法的编写</span></a></h2><p>在正确实现 <code>equals()</code> 的基础上，还需要正确实现 <code>hashCode()</code>。<code>equals()</code> 中用到的用于比较的每一个字段，都必须在 <code>hashCode()</code> 中用于计算；<code>equals()</code> 中没有使用到的字段，绝不可放在 <code>hashCode()</code> 中计算。</p><p>以 <code>Person</code> 类为例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Person</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> firstName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lastName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> age</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把需要比较的字段找出来：</p><ul><li><code>firstName</code></li><li><code>lastName</code></li><li><code>age</code></li></ul><p>然后，引用类型使用 <code>Objects.equals()</code> 比较，基本类型使用 <code>==</code> 比较。</p><p>在正确实现 <code>equals()</code> 的基础上，我们还需要正确实现 <code>hashCode()</code>，即上述 3 个字段分别相同的实例，<code>hashCode()</code> 返回的 <code>int</code> 必须相同：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Person</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> firstName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lastName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> age</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    @</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Override</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> hashCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> h</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        h </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 31</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> h </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> firstName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hashCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        h </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 31</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> h </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lastName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hashCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        h </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 31</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> h </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> h</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码展示了如何手动实现 <code>hashCode()</code> 方法。</p><p><code>String</code> 类已经正确实现了 <code>hashCode()</code> 方法，我们在计算 <code>Person</code> 的 <code>hashCode()</code> 时，反复使用 <code>31 * h</code>，这样做的目的是为了尽量把不同的 <code>Person</code> 实例的 <code>hashCode()</code> 均匀分布到整个 <code>int</code> 范围。</p><p>和实现 <code>equals()</code> 方法遇到的问题类似，如果 <code>firstName</code> 或 <code>lastName</code> 为 <code>null</code>，上述代码工作起来就会抛 <code>NullPointerException</code>。为了解决这个问题，我们在计算 <code>hashCode()</code> 的时候，经常借助 <code>Objects.hash()</code> 来计算：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> hashCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Objects</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hash</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">firstName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> lastName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> age</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Objects.hash()</code> 方法可以处理 <code>null</code> 值，避免空指针异常。</p><h2 id="_5-5-延伸阅读" tabindex="-1"><a class="header-anchor" href="#_5-5-延伸阅读"><span>5.5 延伸阅读</span></a></h2><h3 id="_5-5-1-hashmap-的数组大小" tabindex="-1"><a class="header-anchor" href="#_5-5-1-hashmap-的数组大小"><span>5.5.1 HashMap 的数组大小</span></a></h3><p><code>HashMap</code> 初始化时默认的数组大小只有 16，任何 <code>key</code>，无论它的 <code>hashCode()</code> 有多大，都可以简单地通过：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hashCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0xf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 0xf = 15</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>把索引确定在 0 ~ 15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>这段代码展示了如何将 <code>hashCode()</code> 的结果转换为 <code>HashMap</code> 内部数组的索引。</p><ul><li><code>key.hashCode()</code> 获取 key 对象的哈希码，它是一个 32 位的整数。</li><li><code>&amp; 0xf</code> 是一个按位与运算，其中 <code>0xf</code> 是一个十六进制数，相当于十进制的 15。这个操作的目的是保留 <code>hashCode()</code> 的低 4 位，其余位全部置为 0。</li><li>由于低 4 位的取值范围是 0000 到 1111，即十进制的 0 到 15，因此 <code>index</code> 的取值范围被限制在 0 到 15 之间，正好对应数组的索引范围。</li></ul><h3 id="_5-5-2-hashmap-的扩容" tabindex="-1"><a class="header-anchor" href="#_5-5-2-hashmap-的扩容"><span>5.5.2 HashMap 的扩容</span></a></h3><p>添加超过一定数量的 <code>key-value</code> 时，<code>HashMap</code> 会在内部自动扩容，每次扩容一倍，即长度为 16 的数组扩展为长度 32，相应地，需要重新确定 <code>hashCode()</code> 计算的索引位置。例如，对长度为 32 的数组计算 <code>hashCode()</code> 对应的索引，计算方式要改为：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> index</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hashCode</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0x1f</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 0x1f = 31</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>由于扩容会导致重新分布已有的 <code>key-value</code>，所以，频繁扩容对 <code>HashMap</code> 的性能影响很大。如果我们确定要使用一个容量为 <code>10000</code> 个 <code>key-value</code> 的 <code>HashMap</code>，更好的方式是创建 <code>HashMap</code> 时就指定容量：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> HashMap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;&gt;(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>虽然指定容量是 <code>10000</code>，但 <code>HashMap</code> 内部的数组长度总是 2<sup>n</sup>，因此，实际数组长度被初始化为比 <code>10000</code> 大的 <code>16384</code>（2<sup>14</sup>）。</p><h3 id="_5-5-3-哈希冲突" tabindex="-1"><a class="header-anchor" href="#_5-5-3-哈希冲突"><span>5.5.3 哈希冲突</span></a></h3><p>如果不同的两个 <code>key</code>，例如 <code>&quot;a&quot;</code> 和 <code>&quot;b&quot;</code>，它们的 <code>hashCode()</code> 恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求 <code>hashCode()</code> 尽量不相等），那么，当我们放入：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">a</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Person</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Xiao Ming</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">put</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">b</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Person</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Xiao Hong</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>时，由于计算出的数组索引相同，后面放入的 <code>&quot;Xiao Hong&quot;</code> 不会把 <code>&quot;Xiao Ming&quot;</code> 覆盖。</p><p>在 <code>HashMap</code> 内部，确实可能存在不同的 <code>key</code>，映射到相同的 <code>hashCode()</code>，即相同的数组索引上。</p><p>我们就假设 <code>&quot;a&quot;</code> 和 <code>&quot;b&quot;</code> 这两个 <code>key</code> 最终计算出的索引都是 5，那么，在 <code>HashMap</code> 的数组中，实际存储的不是一个 <code>Person</code> 实例，而是一个 <code>List</code>，它包含两个 <code>Entry</code>，一个是 <code>&quot;a&quot;</code> 的映射，一个是 <code>&quot;b&quot;</code> 的映射。</p><p>在查找的时候，例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Person</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> map</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">get</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">a</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>HashMap</code> 内部通过 <code>&quot;a&quot;</code> 找到的实际上是 <code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个 <code>List</code>，并找到一个 <code>Entry</code>，它的 <code>key</code> 字段是 <code>&quot;a&quot;</code>，才能返回对应的 <code>Person</code> 实例。</p><p>我们把不同的 <code>key</code> 具有相同的 <code>hashCode()</code> 的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用 <code>List</code> 存储 <code>hashCode()</code> 相同的 <code>key-value</code>。显然，如果冲突的概率越大，这个 <code>List</code> 就越长，<code>Map</code> 的 <code>get()</code> 方法效率就越低。</p><p><code>hashCode()</code> 方法编写得越好，<code>HashMap</code> 工作的效率就越高。</p>`,53)]))}const t=i(n,[["render",l]]),p=JSON.parse('{"path":"/notes/LXFJava/zb8n8s4w/","title":"编写hashCode方法","lang":"zh-CN","frontmatter":{"title":"编写hashCode方法","createTime":"2025/07/18 18:33:44","permalink":"/notes/LXFJava/zb8n8s4w/"},"readingTime":{"minutes":6.11,"words":1834},"git":{"createdTime":1752909749000,"updatedTime":1752909749000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/廖雪峰Java/8.集合/5.编写hashCode方法.md","headers":[]}');export{t as comp,p as data};
