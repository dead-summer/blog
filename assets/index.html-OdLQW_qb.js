import{a as c,c as h,b as n,d as a,e,w as i,r as t,o as m}from"./app-CAzY0Upz.js";const u={};function g(v,s){const l=t("CodeRepl"),r=t("VPIcon"),o=t("CodeTabs");return m(),h("div",null,[s[5]||(s[5]=n(`<h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span><strong>问题</strong></span></a></h2><div class="hint-container question"><p class="hint-container-title">208.实现 Trie (前缀树)</p><p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin" target="_blank" rel="noopener noreferrer">Trie</a></strong>（发音类似 &quot;try&quot;）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul></div><div class="hint-container example"><p class="hint-container-title">示例</p><p><strong>输入</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span></span>
<span class="line"><span>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>[null, null, true, false, true, null, true]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>解释</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Trie trie = new Trie();</span></span>
<span class="line"><span>trie.insert(&quot;apple&quot;);</span></span>
<span class="line"><span>trie.search(&quot;apple&quot;);   // 返回 True</span></span>
<span class="line"><span>trie.search(&quot;app&quot;);     // 返回 False</span></span>
<span class="line"><span>trie.startsWith(&quot;app&quot;); // 返回 True</span></span>
<span class="line"><span>trie.insert(&quot;app&quot;);</span></span>
<span class="line"><span>trie.search(&quot;app&quot;);     // 返回 True</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习"><span><strong>练习</strong></span></a></h2>`,4)),a(l,{editable:"",title:"实现 Trie (前缀树)"},{default:i(()=>s[0]||(s[0]=[e("div",{class:"language-python line-numbers-mode","data-highlighter":"shiki","data-ext":"python",style:{"--shiki-light":"#393a34","--shiki-dark":"#dbd7caee","--shiki-light-bg":"#ffffff","--shiki-dark-bg":"#121212"}},[e("pre",{class:"shiki shiki-themes vitesse-light vitesse-dark vp-code"},[e("code",{class:"language-python"},[e("span",{class:"line"},[e("span",{style:{"--shiki-light":"#A0ADA0","--shiki-dark":"#758575DD"}},"# your python code")])])]),e("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[e("div",{class:"line-number"})])],-1)])),_:1,__:[0]}),s[6]||(s[6]=e("h2",{id:"思路",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#思路"},[e("span",null,[e("strong",null,"思路")])])],-1)),e("details",null,[s[3]||(s[3]=e("summary",null,"北海啊，要多想！",-1)),a(o,{id:"57",data:[{id:"Java"}]},{title0:i(({value:d,isActive:p})=>[a(r,{provider:"iconify",name:"vscode-icons:file-type-java"}),s[1]||(s[1]=e("span",null,"Java",-1))]),tab0:i(({value:d,isActive:p})=>s[2]||(s[2]=[e("div",{class:"language-java line-numbers-mode","data-highlighter":"shiki","data-ext":"java",style:{"--shiki-light":"#393a34","--shiki-dark":"#dbd7caee","--shiki-light-bg":"#ffffff","--shiki-dark-bg":"#121212"}},[e("pre",{class:"shiki shiki-themes vitesse-light vitesse-dark vp-code"},[e("code",{class:"language-java"},[e("span",{class:"line"})])]),e("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[e("div",{class:"line-number"})])],-1)])),_:1}),s[4]||(s[4]=n('<p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul>',2))])])}const f=c(u,[["render",g]]),b=JSON.parse('{"path":"/notes/leetcode/mf9sz6e2/","title":"实现 Trie (前缀树)","lang":"zh-CN","frontmatter":{"aside":false,"title":"实现 Trie (前缀树)","createTime":"2025/08/01 13:01:34","permalink":"/notes/leetcode/mf9sz6e2/"},"readingTime":{"minutes":1.04,"words":313},"git":{"createdTime":1754045234000,"updatedTime":1754386436000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":3,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/Leetcode代码微光集/Hot100/9.图论/208.实现Trie(前缀树).md","headers":[]}');export{f as comp,b as data};
