import{a as s,c as a,b as e,o as n}from"./app-CAzY0Upz.js";const t={};function l(h,i){return n(),a("div",null,i[0]||(i[0]=[e(`<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h2><p>Java 原子类 是指 <code>java.util.concurrent.atomic</code> 包中提供的一组线程安全的类，用于实现无锁（lock-free）的变量操作。常见的原子类包括：</p><ul><li><strong>原子更新基本类型</strong>：如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></li><li><strong>原子更新数组</strong>：如 <code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code></li><li><strong>原子更新引用</strong>：如 <code>AtomicReference</code>、<code>AtomicStampedReference</code></li><li><strong>原子更新属性</strong>：如 <code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code></li></ul><p>这些类通过 <strong>CAS（Compare-And-Swap）</strong> 机制以及底层硬件支持，实现对变量的线程安全操作，而无需使用传统的锁（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="为什么原子类的操作是原子性的" tabindex="-1"><a class="header-anchor" href="#为什么原子类的操作是原子性的"><span>为什么原子类的操作是原子性的？</span></a></h3><p>Java 原子类的操作之所以具备原子性，核心依赖于 <strong>CAS（Compare-And-Swap）</strong> 操作，该机制基于 CPU 的原子指令（如 x86 平台的 <code>CMPXCHG</code> 指令）实现。CAS 是一种乐观锁机制，其基本流程如下：</p><ol><li><strong>比较</strong>：检查当前内存中的值是否等于预期值。</li><li><strong>交换</strong>：如果相等，则将内存中的值更新为新值。</li><li><strong>返回结果</strong>：返回操作是否成功。</li></ol><p>原子类底层通过 <code>Unsafe</code> 类实现 CAS 操作。<code>Unsafe</code> 是 Java 提供的一个可以进行底层内存操作的类，其方法直接通过 JNI（Java Native Interface） 调用 C/C++ 实现，最终转化为一条 CPU 的原子指令。</p><div class="hint-container example"><p class="hint-container-title">AtomicInteger 的 incrementAndGet</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> incrementAndGet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> unsafe</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getAndAddInt</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> valueOffset</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>getAndAddInt()</code> 方法通过循环不断尝试 CAS 操作，直到成功为止，确保操作具备原子性。</p></div><div class="hint-container info"><p class="hint-container-title">CAS 原理伪代码</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">boolean </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">compareAndSwap</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int*</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> address</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> expectedValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> newValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">address </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> expectedValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">        *</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">address </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> newValue</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">        return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该伪代码仅用于说明逻辑，实际实现依赖于硬件平台的原子指令。</p></div><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h2><p>Java 原子类适用于需要<strong>轻量级线程安全操作</strong>的场景，尤其是在并发环境中仅需对<strong>单一变量</strong>进行原子更新时。其优势在于：</p><ul><li><strong>简单</strong>：API 设计简洁，易于使用。</li><li><strong>高效</strong>：避免了锁的上下文切换和阻塞开销，资源占用低。</li><li><strong>线程安全</strong>：通过 CAS 操作保证并发下的数据一致性。</li></ul><h3 id="常见应用场景" tabindex="-1"><a class="header-anchor" href="#常见应用场景"><span>常见应用场景</span></a></h3><ol><li><p><strong>计数器</strong> 适用于高并发环境下的请求计数、任务完成数统计、在线用户数统计等。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">AtomicInteger</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> requestCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> AtomicInteger</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">requestCount</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">incrementAndGet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>状态标识</strong> 在多线程环境中用于维护某个状态标志（如是否初始化完成）。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">AtomicBoolean</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> initialized</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> AtomicBoolean</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">initialized</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">compareAndSet</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">false</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> true</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">))</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // 执行初始化逻辑</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>累加器</strong> 用于并行计算中的中间结果聚合（如并行流中的计数器）。</p></li><li><p><strong>高性能缓存或状态控制</strong> 在需要频繁读写共享变量的场景中，使用原子类可以避免锁竞争，提高系统吞吐量。</p></li></ol><h2 id="适用性对比" tabindex="-1"><a class="header-anchor" href="#适用性对比"><span>适用性对比</span></a></h2><table><thead><tr><th>机制</th><th>原子类</th><th><code>synchronized</code> / <code>Lock</code></th></tr></thead><tbody><tr><td>实现方式</td><td>CAS（无锁）</td><td>阻塞式锁</td></tr><tr><td>性能</td><td>高效（无阻塞）</td><td>有上下文切换开销</td></tr><tr><td>适用粒度</td><td>单个变量的操作</td><td>任意代码块或变量</td></tr><tr><td>适用场景</td><td>简单、高频的共享变量更新</td><td>复杂逻辑或临界区保护</td></tr></tbody></table>`,18)]))}const k=s(t,[["render",l]]),r=JSON.parse('{"path":"/notes/interview/uvjs93bc/","title":"原子类","lang":"zh-CN","frontmatter":{"title":"原子类","createTime":"2025/08/27 15:47:49","permalink":"/notes/interview/uvjs93bc/"},"readingTime":{"minutes":2.62,"words":785},"git":{"createdTime":1756719649000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Java/JUC/原子类.md","headers":[]}');export{k as comp,r as data};
