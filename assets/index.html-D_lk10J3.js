import{a as o,c as e,b as i,o as n}from"./app-CAzY0Upz.js";const a={};function r(l,t){return n(),e("div",null,t[0]||(t[0]=[i('<p>在 MySQL 中，RR (REPEATABLE READ) 和 RC (READ COMMITTED) 是两种不同的事务隔离级别，主要区别体现在快照读行为、锁机制和主从同步要求上。以下是详细对比：</p><h2 id="快照读-snapshot-read" tabindex="-1"><a class="header-anchor" href="#快照读-snapshot-read"><span>快照读 (Snapshot Read)</span></a></h2><p>快照读是一种基于多版本并发控制 (MVCC) 的读取机制，它通过数据的历史版本快照来显示查询结果，而不受其他并发事务的未提交更改影响。</p><ul><li><strong>适用隔离级别</strong>：仅在 READ COMMITTED 和 REPEATABLE READ 级别下生效。</li><li><strong>行为差异</strong>： <ul><li><strong>READ COMMITTED (RC)</strong>：事务中的每次查询前都会创建一个新的 ReadView（快照视图）。新建的 ReadView 会更新除 <code>creator_trx_id</code> 外的所有字段，因此可能导致不可重复读现象。</li><li><strong>REPEATABLE READ (RR)</strong>：事务仅在第一次查询时创建 ReadView，后续所有查询共享同一个 ReadView，从而解决不可重复读问题。</li></ul></li><li><strong>核心原理</strong>：ReadView 的生成时机不同（RC 每次查询新建，RR 首次查询新建），这是 MVCC 实现的关键。</li></ul><h2 id="锁机制-locking-mechanism" tabindex="-1"><a class="header-anchor" href="#锁机制-locking-mechanism"><span>锁机制 (Locking Mechanism)</span></a></h2><p>MySQL 使用锁来保证事务的隔离性，RR 和 RC 在锁类型和范围上存在显著差异：</p><ul><li><strong>锁类型</strong>： <ul><li><strong>Record Lock</strong>：记录锁，锁定索引记录本身。</li><li><strong>Gap Lock</strong>：间隙锁，锁定索引记录之间的间隙（防止新记录插入）。</li><li><strong>Next-Key Lock</strong>：Record Lock 和 Gap Lock 的组合，锁定索引记录及其左开右闭的间隙范围（例如 <code>(a, b]</code>）。</li></ul></li><li><strong>行为差异</strong>： <ul><li><strong>READ COMMITTED (RC)</strong>：仅使用 Record Lock（针对索引记录加锁），不支持 Gap Lock 或 Next-Key Lock。因此，无法完全防止幻读（Phantom Read）。</li><li><strong>REPEATABLE READ (RR)</strong>：支持 Record Lock、Gap Lock 和 Next-Key Lock。通过 Gap Lock 和 Next-Key Lock 锁定索引间隙，有效解决幻读问题。</li></ul></li></ul><h2 id="主从同步-master-slave-replication" tabindex="-1"><a class="header-anchor" href="#主从同步-master-slave-replication"><span>主从同步 (Master-Slave Replication)</span></a></h2><p>在数据主从同步中，BinLog 格式对事务隔离级别有严格要求：</p><ul><li><strong>BinLog 格式</strong>：MySQL 支持三种格式： <ul><li><strong>STATEMENT</strong>：基于 SQL 语句的复制。</li><li><strong>ROW</strong>：基于行变化的复制。</li><li><strong>MIXED</strong>：混合模式，自动选择 STATEMENT 或 ROW。</li></ul></li><li><strong>行为差异</strong>： <ul><li><strong>READ COMMITTED (RC)</strong>：仅支持 ROW 格式的 BinLog。因为 RC 允许不可重复读，基于 STATEMENT 的复制可能导致从库数据不一致。</li><li><strong>REPEATABLE READ (RR)</strong>：支持所有格式（STATEMENT、ROW 和 MIXED）。RR 的一致性保证使其兼容基于语句的复制。</li></ul></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><div class="hint-container question"><p class="hint-container-title">为什么互联网公司选择使用 **Read Committed** 隔离级别？</p><ol><li><p>互联网业务的特点：高并发</p><ul><li>互联网公司和传统企业最大的差异之一，就是 <strong>并发量</strong>。例如：2020 年双十一当天，订单创建峰值达到 <strong>58.3 万笔/秒</strong>。</li><li>要扛得住这种并发量，系统需要在数据库层面尽量减少锁冲突，提高吞吐量。</li></ul></li><li><p>RC 相比 RR 的优势</p><ul><li><p><strong>提升并发度</strong></p><ul><li><strong>RC 隔离级别</strong>：只对被修改的记录加行级锁，不会额外加 Gap Lock 和 Next-Key Lock。</li><li><strong>RR 隔离级别</strong>：除了行级锁，还会加 Gap Lock 和 Next-Key Lock，锁范围更大，导致并发度下降。</li></ul></li><li><p><strong>降低死锁概率</strong></p><ul><li>RR 因为锁范围更大，多个事务更容易发生 <strong>相互等待</strong>，从而导致死锁。</li><li>RC 避免了 Gap Lock 和 Next-Key Lock，锁冲突和死锁概率大幅降低。</li></ul></li></ul></li></ol></div>',12)]))}const R=o(a,[["render",r]]),c=JSON.parse('{"path":"/notes/interview/ky0gapeq/","title":"RR和RC的区别","lang":"zh-CN","frontmatter":{"title":"RR和RC的区别","createTime":"2025/08/30 17:19:32","permalink":"/notes/interview/ky0gapeq/"},"readingTime":{"minutes":2.79,"words":836},"git":{"createdTime":1756719850000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/MySQL/RR和RC的区别.md","headers":[]}');export{R as comp,c as data};
