import{a as s,c as n,b as t,o as e}from"./app-CAzY0Upz.js";const i={};function l(r,a){return e(),n("div",null,a[0]||(a[0]=[t('<h2 id="基础数据类型" tabindex="-1"><a class="header-anchor" href="#基础数据类型"><span>基础数据类型</span></a></h2><h3 id="string-字符串" tabindex="-1"><a class="header-anchor" href="#string-字符串"><span>String（字符串）</span></a></h3><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途"><span>用途</span></a></h4><ul><li><strong>计数器</strong>：例如，文章阅读量、用户点赞数。</li><li><strong>分布式锁</strong>：通过 <code>SET NX EX</code> 命令实现。</li><li><strong>存储序列化对象</strong>：如 JSON 格式的用户信息。</li></ul><h4 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现"><span>底层实现</span></a></h4><ul><li><strong>SDS（Simple Dynamic String，简单动态字符串）</strong>：Redis 自主实现的动态字符串结构，相较于 C 语言的字符串，具有自动扩容、记录长度、二进制安全等优点。</li><li><strong>整数编码（Embedded String）</strong>：如果存储的字符串可以表示为 64 位有符号整数，Redis 会将其存储为整数类型，以节省内存并提高操作效率。</li></ul><h3 id="hash-哈希" tabindex="-1"><a class="header-anchor" href="#hash-哈希"><span>Hash（哈希）</span></a></h3><h4 id="用途-1" tabindex="-1"><a class="header-anchor" href="#用途-1"><span>用途</span></a></h4><ul><li><strong>缓存对象</strong>：存储结构化数据，例如，一个用户对象的所有属性。</li></ul><h4 id="底层实现-1" tabindex="-1"><a class="header-anchor" href="#底层实现-1"><span>底层实现</span></a></h4><ul><li><strong>ZipList（压缩列表）</strong>：当哈希表中元素数量较少且所有键值对的长度都较小时使用。它是一种连续内存存储结构，节省空间。</li><li><strong>Dict（哈希表）</strong>：当不满足 ZipList 的条件时，Redis 会将底层存储结构从 ZipList 转换为 Dict。</li><li><strong>Listpack（列表包）</strong>：Redis 7.0 以后，Listpack 取代了 ZipList 作为底层实现。</li></ul><h3 id="list-列表" tabindex="-1"><a class="header-anchor" href="#list-列表"><span>List（列表）</span></a></h3><h4 id="用途-2" tabindex="-1"><a class="header-anchor" href="#用途-2"><span>用途</span></a></h4><ul><li><strong>消息队列</strong>：实现简单的先进先出（FIFO）或后进先出（LIFO）队列。</li><li><strong>朋友圈点赞/评论列表</strong>：按时间顺序展示动态。</li></ul><h4 id="底层实现-2" tabindex="-1"><a class="header-anchor" href="#底层实现-2"><span>底层实现</span></a></h4><ul><li><strong>QuickList（快速列表）</strong>：双向链表和 ZipList 或 Listpack 的混合体。</li></ul><h3 id="set-集合" tabindex="-1"><a class="header-anchor" href="#set-集合"><span>Set（集合）</span></a></h3><h4 id="用途-3" tabindex="-1"><a class="header-anchor" href="#用途-3"><span>用途</span></a></h4><ul><li><strong>共同关注</strong>：通过 <code>SINTER</code> 命令求两个用户共同关注的人。</li><li><strong>数据去重</strong>：Set 自动保证元素的唯一性。</li><li><strong>标签系统</strong>：存储某个对象的所有标签。</li></ul><h4 id="底层实现-3" tabindex="-1"><a class="header-anchor" href="#底层实现-3"><span>底层实现</span></a></h4><ul><li><strong>IntSet（整数集合）</strong>：当集合中所有元素都是整数且元素数量较少时使用。</li><li><strong>Dict（哈希表）</strong>：当不满足 IntSet 的条件时，Redis 会将底层存储结构从 IntSet 转换为 Dict。Set 在 Dict 中只使用键存储元素，值通常设为 <code>NULL</code>。</li></ul><h3 id="zset-有序集合" tabindex="-1"><a class="header-anchor" href="#zset-有序集合"><span>ZSet（有序集合）</span></a></h3><h4 id="用途-4" tabindex="-1"><a class="header-anchor" href="#用途-4"><span>用途</span></a></h4><ul><li><strong>排行榜</strong>：根据分数对元素进行排序，例如游戏积分榜。</li><li><strong>延时队列</strong>：利用分数作为时间戳，实现定时任务。</li></ul><h4 id="底层实现-4" tabindex="-1"><a class="header-anchor" href="#底层实现-4"><span>底层实现</span></a></h4><ul><li><strong>ZipList（压缩列表）/Listpack（列表包）</strong>：当有序集合中元素数量较少（默认小于 128 个）且所有元素成员的长度都较小（默认小于 64 字节）时使用。</li><li><strong>Dict + SkipList（字典 + 跳表）</strong>：当不满足 ZipList/Listpack 的条件时，Redis 会使用 Dict 和 SkipList 两种数据结构来共同实现 ZSet。 <ul><li><strong>Dict（哈希表）</strong>：用于存储成员（member）到分数（score）的映射，可以通过成员快速查找其分数，时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li><li><strong>SkipList（跳表）</strong>：用于存储成员和分数，并按照分数进行排序。它是一个多层链表，可以实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(\\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的查找、插入和删除操作，特别适用于范围查询和按分数排序。</li></ul></li></ul><h3 id="bitmap-位图" tabindex="-1"><a class="header-anchor" href="#bitmap-位图"><span>BitMap（位图）</span></a></h3><h4 id="用途-5" tabindex="-1"><a class="header-anchor" href="#用途-5"><span>用途</span></a></h4><ul><li><strong>用户签到记录</strong>：每个位代表一天，记录用户是否签到。</li><li><strong>布隆过滤器</strong>：作为布隆过滤器的底层数据结构。</li><li><strong>统计活跃用户</strong>：通过位运算快速统计特定时间段的活跃用户。</li></ul><h4 id="底层实现-5" tabindex="-1"><a class="header-anchor" href="#底层实现-5"><span>底层实现</span></a></h4><ul><li><strong>String</strong>：BitMap 本质上是 String 类型，Redis 将 String 视为一个字节数组，每个字节包含 8 个位，通过位操作（<code>SETBIT</code>, <code>GETBIT</code>, <code>BITCOUNT</code> 等）来操作这些位。</li></ul><h3 id="hyperloglog-基数估算" tabindex="-1"><a class="header-anchor" href="#hyperloglog-基数估算"><span>HyperLogLog（基数估算）</span></a></h3><h4 id="用途-6" tabindex="-1"><a class="header-anchor" href="#用途-6"><span>用途</span></a></h4><ul><li><strong>基数统计</strong>：估算一个集合中不重复元素的数量（例如，网站 UV 统计），允许一定误差但占用极少内存。</li></ul><h4 id="底层实现-6" tabindex="-1"><a class="header-anchor" href="#底层实现-6"><span>底层实现</span></a></h4><ul><li><strong>String</strong>：HyperLogLog 的底层也是 String 类型，它使用了一种基于概率的数据结构，通过哈希函数和位模式来估算基数。</li></ul><h3 id="geo-地理空间" tabindex="-1"><a class="header-anchor" href="#geo-地理空间"><span>Geo（地理空间）</span></a></h3><h4 id="用途-7" tabindex="-1"><a class="header-anchor" href="#用途-7"><span>用途</span></a></h4><ul><li><strong>附近的人/地点查询</strong>：根据经纬度查询指定范围内的地理位置。</li><li><strong>地理位置范围查询</strong></li></ul><h4 id="底层实现-7" tabindex="-1"><a class="header-anchor" href="#底层实现-7"><span>底层实现</span></a></h4><ul><li><strong>ZSet（有序集合）</strong>：Geo 的底层实现是 ZSet。每个地理位置（成员）被编码成一个 52 位的 Geohash 整数作为 ZSet 的分数，经纬度信息存储为 ZSet 的成员。利用 ZSet 的范围查询能力实现地理位置查询。</li></ul><h3 id="stream-流" tabindex="-1"><a class="header-anchor" href="#stream-流"><span>Stream（流）</span></a></h3><h4 id="用途-8" tabindex="-1"><a class="header-anchor" href="#用途-8"><span>用途</span></a></h4><ul><li><strong>消息队列</strong>：提供持久化、消费者组、消息确认等功能，比 List 更适合作为消息队列。</li><li><strong>事件日志记录</strong></li></ul><h4 id="底层实现-8" tabindex="-1"><a class="header-anchor" href="#底层实现-8"><span>底层实现</span></a></h4><ul><li><strong>Radix Tree（基数树）</strong>：用于存储 Stream 的消息 ID，实现高效的 ID 查找和范围查询。</li><li><strong>Listpack（列表包）</strong>：用于存储 Stream 的消息内容（键值对）。</li></ul><h2 id="核心数据结构" tabindex="-1"><a class="header-anchor" href="#核心数据结构"><span>核心数据结构</span></a></h2><h3 id="dict-哈希表" tabindex="-1"><a class="header-anchor" href="#dict-哈希表"><span>Dict（哈希表）</span></a></h3><p>Dict 是 Redis 哈希键（Hash）的底层实现之一，采用数组加链表的哈希表结构处理键值对存储和哈希冲突。</p><h4 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理"><span>底层原理</span></a></h4><ul><li><strong>结构设计</strong>：基于数组和链表的哈希表实现，包含两个哈希表数组 <code>ht[0]</code> 和 <code>ht[1]</code>。 <ul><li><code>ht[0]</code>：当前活动哈希表，用于存储数据。</li><li><code>ht[1]</code>：备用哈希表，仅在 rehash 过程中使用。</li></ul></li><li><strong>哈希函数</strong>：使用 MurmurHash 或 SipHash 算法计算键的哈希值，确保均匀分布。哈希值通过取模运算（<code>index = hash(key) % size</code>）定位到数组索引。</li></ul><h4 id="rehash-扩容与收缩" tabindex="-1"><a class="header-anchor" href="#rehash-扩容与收缩"><span>Rehash（扩容与收缩）</span></a></h4><p>当键值对数量变化触发负载因子（<code>used_entries / size</code>）阈值时，Redis 执行 rehash：</p><ul><li><strong>扩容</strong>：负载因子超过 1（默认）时，创建 <code>ht[1]</code>，其大小为 <code>ht[0]</code> 的两倍（向上取整为 2 的幂），以降低冲突概率。</li><li><strong>收缩</strong>：负载因子低于 0.1 时，创建更小的 <code>ht[1]</code>（大小为 <code>ht[0]</code> 的 1/2），节省内存。</li></ul><h4 id="渐进式-rehash" tabindex="-1"><a class="header-anchor" href="#渐进式-rehash"><span>渐进式 Rehash</span></a></h4><p>为避免一次性迁移数据导致阻塞，Redis 采用渐进式 rehash：</p><ul><li>在 rehash 期间，<code>ht[0]</code> 和 <code>ht[1]</code> 共存。</li><li><strong>操作规则</strong>： <ul><li>新增键值对直接写入 <code>ht[1]</code>。</li><li>查询、修改或删除操作先在 <code>ht[0]</code> 查找，未命中时再查 <code>ht[1]</code>。</li></ul></li><li><strong>迁移机制</strong>：每次处理客户端命令时，Redis 迁移 <code>ht[0]</code> 的一个桶到 <code>ht[1]</code>。当 <code>ht[0]</code> 为空时，释放 <code>ht[0]</code> 并将 <code>ht[1]</code> 设置为新活动表。</li></ul><h3 id="ziplist-压缩列表" tabindex="-1"><a class="header-anchor" href="#ziplist-压缩列表"><span>ZipList（压缩列表）</span></a></h3><p>ZipList 是 Redis 列表（List）和哈希（Hash）的底层实现之一，适用于小数据存储，以连续内存节省空间。</p><h4 id="底层原理-1" tabindex="-1"><a class="header-anchor" href="#底层原理-1"><span>底层原理</span></a></h4><ul><li><strong>内存布局</strong>： 一段连续内存块，包含： <ul><li><strong>头部</strong>：<code>zlbytes</code>（总字节数）、<code>zltail</code>（尾节点偏移量）、<code>zllen</code>（节点数）。</li><li><strong>节点</strong>：每个节点存储 <code>prevlen</code>（前驱节点长度）、<code>encoding</code>（数据类型编码）、<code>content</code>（实际数据）。节点双向链接，通过 <code>prevlen</code> 实现反向遍历。</li></ul></li><li><strong>编码优化</strong>：使用变长编码（如整数用 1-5 字节存储），减少内存占用。例如，小整数直接内联存储。</li></ul><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h4><ul><li><strong>内存高效</strong>：无指针开销，适合存储少量小尺寸元素（如短字符串或整数）。</li><li><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 遍历</strong>：支持顺序访问，但随机访问需遍历。</li></ul><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h4><ul><li><strong>修改成本高</strong>：插入或删除元素可能触发内存重分配和数据移动，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li><li><strong>连锁更新（Cascade Update）</strong>：当节点长度变化导致 <code>prevlen</code> 字段需扩展时（例如，从 1 字节扩展到 5 字节），后续节点的 <code>prevlen</code> 可能连锁更新。最坏情况下，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，影响性能。</li></ul><h3 id="quicklist-快速列表" tabindex="-1"><a class="header-anchor" href="#quicklist-快速列表"><span>QuickList（快速列表）</span></a></h3><p>QuickList 是 Redis 列表（List）的主要底层实现，结合双向链表和压缩列表，平衡内存与性能。</p><h4 id="底层原理-2" tabindex="-1"><a class="header-anchor" href="#底层原理-2"><span>底层原理</span></a></h4><ul><li><p><strong>结构设计</strong>：双向链表结构，每个节点（QuickListNode）存储一个 ZipList 或 Listpack。</p><ul><li><strong>链表节点</strong>：包含指向前驱和后继的指针，以及子列表的指针。</li><li><strong>子列表</strong>：默认为 ZipList，Redis 7.0 后支持 Listpack，存储多个元素。</li></ul></li><li><p><strong>内存管理</strong>：通过配置参数（如 <code>list-max-ziplist-size</code>）控制子列表大小。例如，子列表元素过多时自动分裂，反之合并。</p></li></ul><h4 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1"><span>特点</span></a></h4><ul><li><strong>高效操作</strong>： <ul><li>头部/尾部插入/删除：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（通过链表指针）。</li><li>范围查询：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>（但子列表连续存储减少遍历开销）。</li></ul></li><li><strong>内存优化</strong>：子列表连续存储减少指针开销，内存利用率高。</li><li><strong>灵活性</strong>：支持动态调整子列表大小，适应数据变化。</li></ul><h3 id="skiplist-跳表" tabindex="-1"><a class="header-anchor" href="#skiplist-跳表"><span>SkipList（跳表）</span></a></h3><p>SkipList 是 Redis 有序集合（ZSet）的底层实现之一，用于高效范围查询和排序。</p><h5 id="底层原理-3" tabindex="-1"><a class="header-anchor" href="#底层原理-3"><span>底层原理</span></a></h5><ul><li><strong>多层索引结构</strong>：基于有序链表，添加多层索引（L0 为数据层，L1-LN 为索引层）。 <ul><li><strong>节点结构</strong>：存储分数（score）、成员（member）和前进指针数组（<code>forward[]</code>）。指针数组高度由随机算法确定（概率为 1/2 的幂次）。</li><li><strong>查找过程</strong>：从最高层开始，比较分数并“跳跃”到下一节点，逐步降层至数据层。时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(\\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</li></ul></li><li><strong>排序机制</strong>：所有元素按分数升序存储，分数相同时按字典序排序成员。</li></ul><h4 id="特点-2" tabindex="-1"><a class="header-anchor" href="#特点-2"><span>特点</span></a></h4><ul><li><strong>高效查找</strong>：平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(\\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的查找、插入和删除性能。</li><li><strong>范围查询优化</strong>：高层索引快速定位范围起点，实现 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(\\log N + M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> 的范围查询（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> 为结果数）。</li><li><strong>空间换时间</strong>：索引层占用额外内存（平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 空间），但提升查询效率。</li><li><strong>随机性</strong>：新节点层数由随机算法决定，确保平衡性。</li></ul><h3 id="listpack-列表包" tabindex="-1"><a class="header-anchor" href="#listpack-列表包"><span>Listpack（列表包）</span></a></h3><p>Listpack 是 Redis 5.0 引入的结构，用于替代 ZipList，解决其性能缺陷。</p><h4 id="底层原理-4" tabindex="-1"><a class="header-anchor" href="#底层原理-4"><span>底层原理</span></a></h4><ul><li><strong>内存布局</strong>：连续内存块，包含： <ul><li><strong>头部</strong>：<code>lp_bytes</code>（总字节数）、<code>lp_len</code>（元素数）。</li><li><strong>节点</strong>：每个节点存储 <code>encoding</code>（数据类型和长度编码）、<code>content</code>（数据）、<code>back_len</code>（节点总长度，包括自身）。移除了 <code>prevlen</code> 字段，<code>back_len</code> 明确记录当前节点长度。</li></ul></li><li><strong>编码机制</strong>：<code>back_len</code> 使用变长整数存储（1-5 字节），确保长度变化不影响后续节点。</li></ul><h4 id="特点-3" tabindex="-1"><a class="header-anchor" href="#特点-3"><span>特点</span></a></h4><ul><li><strong>解决连锁更新</strong>：节点长度变化仅影响自身，不触发后续更新（时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>）。</li><li><strong>内存高效</strong>：连续存储减少指针开销，内存利用率优于链表。</li><li><strong>兼容性</strong>：作为 ZipList 的替代，用于哈希（Hash）和列表（List）等场景。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><div class="hint-container question"><p class="hint-container-title">为什么 ZSet 需要存储两份数据？</p><p>ZSet 需要同时支持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的成员到分数的查找（通过 Dict）和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\\mathcal{O}(\\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> 的按分数范围查找/排序（通过 SkipList）。这是其特性需求，为了在不同操作场景下都能保持高效性能。</p></div>',85)]))}const p=s(i,[["render",l]]),m=JSON.parse('{"path":"/notes/interview/94rnngf5/","title":"数据类型","lang":"zh-CN","frontmatter":{"title":"数据类型","createTime":"2025/08/30 18:19:55","permalink":"/notes/interview/94rnngf5/"},"readingTime":{"minutes":8.74,"words":2622},"git":{"createdTime":1756721248000,"updatedTime":1756721248000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":1,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/Redis/数据类型.md","headers":[]}');export{p as comp,m as data};
