import{a as o,c as t,b as d,o as r}from"./app-CAzY0Upz.js";const i={};function n(a,e){return r(),t("div",null,e[0]||(e[0]=[d('<h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h2><p><strong>MVCC (Multi-Version Concurrency Control)</strong> 是一种通过维护数据行多版本实现并发控制的技术，核心目标是允许读写操作<strong>无锁并发执行</strong>。</p><p>在 MySQL InnoDB 引擎中，它实现了 <strong>READ COMMITTED</strong>（读已提交）和 <strong>REPEATABLE READ</strong>（可重复读）两个隔离级别的并发控制。</p><p>MVCC 的实现主要依赖于以下三个核心组件：</p><ol><li><p><strong>隐藏字段 (Hidden Columns)</strong>: InnoDB 会在每行数据后面添加两个隐藏字段：</p><ul><li><code>trx_id</code>: 记录了最后一个修改该数据行的事务 ID。</li><li><code>roll_pointer</code>: 指向该数据行的上一个版本，这些历史版本存储在 Undo Log 中，通过 <code>roll_pointer</code> 形成一个版本链。</li></ul></li><li><p><strong>Undo Log (回滚日志)</strong>: Undo Log 主要用于存储数据的历史版本。当事务需要修改数据时，会将旧版本的数据快照存入 Undo Log，形成版本链。</p></li><li><p><strong>Read View (读视图)</strong>: 事务在查询时生成的数据可见性快照，包含：</p><ul><li><code>m_ids</code>: 创建 Read View 时，系统中所有活跃事务的 ID 列表。</li><li><code>min_trx_id</code>: <code>m_ids</code> 列表中的最小事务 ID。</li><li><code>max_trx_id</code>: 创建 Read View 时，系统下一个将要分配的事务 ID（即当前最大事务 ID + 1）。</li><li><code>creator_trx_id</code>: 创建该 Read View 的事务自身的 ID。</li></ul></li></ol><h2 id="可见性判断逻辑" tabindex="-1"><a class="header-anchor" href="#可见性判断逻辑"><span>可见性判断逻辑</span></a></h2><p>当一个事务尝试读取某一行数据时，InnoDB 会获取该行数据的最新版本，并将其 <code>trx_id</code> 与当前事务的 Read View 进行比较，遵循以下规则来判断数据的可见性：</p><ol><li><p>如果 <code>trx_id</code> 与 <code>creator_trx_id</code> 相同，意味着是当前事务自己修改了该行数据，因此该版本对当前事务可见。</p></li><li><p>如果 <code>trx_id</code> 小于 <code>min_trx_id</code>，意味着修改该版本的事务在当前事务创建 Read View 之前就已经提交，因此该版本对当前事务可见。</p></li><li><p>如果 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，意味着修改该版本的事务在当前事务创建 Read View 之后才开启，因此该版本对当前事务不可见。此时，需要通过 <code>roll_pointer</code> 沿着 Undo Log 版本链查找上一个版本的数据，并重新进行可见性判断。</p></li><li><p>如果 <code>trx_id</code> 在 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要进一步判断 <code>trx_id</code> 是否存在于 <code>m_ids</code> 列表中：</p><ul><li><strong>如果存在</strong>: 说明在创建 Read View 时，修改该版本的事务仍然是活跃状态（未提交），因此该版本对当前事务不可见。同样需要沿着 Undo Log 版本链查找上一个版本。</li><li><strong>如果不存在</strong>: 说明在创建 Read View 时，修改该版本的事务已经提交，因此该版本对当前事务可见。</li></ul></li></ol><h2 id="不同隔离级别下的实现差异" tabindex="-1"><a class="header-anchor" href="#不同隔离级别下的实现差异"><span>不同隔离级别下的实现差异</span></a></h2><p><strong>读已提交 (READ COMMITTED)</strong> 和<strong>可重复读 (REPEATABLE READ)</strong> 两个隔离级别的主要区别在于创建 Read View 的时机不同：</p><table><thead><tr><th><strong>隔离级别</strong></th><th><strong>Read View 创建时机</strong></th><th><strong>影响</strong></th></tr></thead><tbody><tr><td><strong>读已提交</strong></td><td>每次执行 <code>SELECT</code> 时创建新 Read View</td><td>可能读到其他事务已提交的数据，导致 <strong>不可重复读</strong>。</td></tr><tr><td><strong>可重复读</strong></td><td>仅在第一次 <code>SELECT</code> 时创建 Read View</td><td>后续所有 <code>SELECT</code> 复用同一视图，保证 <strong>可重复读</strong>一致性。</td></tr></tbody></table>',11)]))}const s=o(i,[["render",n]]),l=JSON.parse('{"path":"/notes/interview/rybt9ct0/","title":"MVCC","lang":"zh-CN","frontmatter":{"title":"MVCC","createTime":"2025/07/24 22:24:22","permalink":"/notes/interview/rybt9ct0/"},"readingTime":{"minutes":2.73,"words":818},"git":{"createdTime":1753699516000,"updatedTime":1756719850000,"contributors":[{"name":"dead_summer","username":"","email":"2941325451@qq.com","commits":2,"avatar":"https://gravatar.com/avatar/d7f172441d823f01ad688f425860dbe76a31ea11c9936176bbd8c14670a619f8?d=retro"}]},"filePathRelative":"notes/八股文自救指南/MySQL/MVCC.md","headers":[]}');export{s as comp,l as data};
